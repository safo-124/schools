
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model SuperAdmin
 * 
 */
export type SuperAdmin = $Result.DefaultSelection<Prisma.$SuperAdminPayload>
/**
 * Model School
 * 
 */
export type School = $Result.DefaultSelection<Prisma.$SchoolPayload>
/**
 * Model SchoolAdmin
 * 
 */
export type SchoolAdmin = $Result.DefaultSelection<Prisma.$SchoolAdminPayload>
/**
 * Model Teacher
 * 
 */
export type Teacher = $Result.DefaultSelection<Prisma.$TeacherPayload>
/**
 * Model Student
 * 
 */
export type Student = $Result.DefaultSelection<Prisma.$StudentPayload>
/**
 * Model Parent
 * 
 */
export type Parent = $Result.DefaultSelection<Prisma.$ParentPayload>
/**
 * Model StudentParentLink
 * 
 */
export type StudentParentLink = $Result.DefaultSelection<Prisma.$StudentParentLinkPayload>
/**
 * Model Class
 * 
 */
export type Class = $Result.DefaultSelection<Prisma.$ClassPayload>
/**
 * Model StudentClassEnrollment
 * 
 */
export type StudentClassEnrollment = $Result.DefaultSelection<Prisma.$StudentClassEnrollmentPayload>
/**
 * Model Subject
 * 
 */
export type Subject = $Result.DefaultSelection<Prisma.$SubjectPayload>
/**
 * Model TimetableSlot
 * 
 */
export type TimetableSlot = $Result.DefaultSelection<Prisma.$TimetableSlotPayload>
/**
 * Model StudentAttendance
 * 
 */
export type StudentAttendance = $Result.DefaultSelection<Prisma.$StudentAttendancePayload>
/**
 * Model Assignment
 * 
 */
export type Assignment = $Result.DefaultSelection<Prisma.$AssignmentPayload>
/**
 * Model StudentGrade
 * 
 */
export type StudentGrade = $Result.DefaultSelection<Prisma.$StudentGradePayload>
/**
 * Model FeeStructure
 * 
 */
export type FeeStructure = $Result.DefaultSelection<Prisma.$FeeStructurePayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model InvoiceLineItem
 * 
 */
export type InvoiceLineItem = $Result.DefaultSelection<Prisma.$InvoiceLineItemPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model SchoolAnnouncement
 * 
 */
export type SchoolAnnouncement = $Result.DefaultSelection<Prisma.$SchoolAnnouncementPayload>
/**
 * Model ClassAnnouncement
 * 
 */
export type ClassAnnouncement = $Result.DefaultSelection<Prisma.$ClassAnnouncementPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  SCHOOL_ADMIN: 'SCHOOL_ADMIN',
  TEACHER: 'TEACHER',
  STUDENT: 'STUDENT',
  PARENT: 'PARENT'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const AttendanceStatus: {
  PRESENT: 'PRESENT',
  ABSENT: 'ABSENT',
  LATE: 'LATE',
  EXCUSED: 'EXCUSED'
};

export type AttendanceStatus = (typeof AttendanceStatus)[keyof typeof AttendanceStatus]


export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  OTHER: 'OTHER',
  PREFER_NOT_TO_SAY: 'PREFER_NOT_TO_SAY'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const PaymentStatus: {
  PENDING: 'PENDING',
  PAID: 'PAID',
  PARTIALLY_PAID: 'PARTIALLY_PAID',
  OVERDUE: 'OVERDUE',
  CANCELLED: 'CANCELLED',
  REFUNDED: 'REFUNDED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const TermPeriod: {
  FIRST_TERM: 'FIRST_TERM',
  SECOND_TERM: 'SECOND_TERM',
  THIRD_TERM: 'THIRD_TERM'
};

export type TermPeriod = (typeof TermPeriod)[keyof typeof TermPeriod]


export const DayOfWeek: {
  MONDAY: 'MONDAY',
  TUESDAY: 'TUESDAY',
  WEDNESDAY: 'WEDNESDAY',
  THURSDAY: 'THURSDAY',
  FRIDAY: 'FRIDAY',
  SATURDAY: 'SATURDAY',
  SUNDAY: 'SUNDAY'
};

export type DayOfWeek = (typeof DayOfWeek)[keyof typeof DayOfWeek]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type AttendanceStatus = $Enums.AttendanceStatus

export const AttendanceStatus: typeof $Enums.AttendanceStatus

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type TermPeriod = $Enums.TermPeriod

export const TermPeriod: typeof $Enums.TermPeriod

export type DayOfWeek = $Enums.DayOfWeek

export const DayOfWeek: typeof $Enums.DayOfWeek

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.superAdmin`: Exposes CRUD operations for the **SuperAdmin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SuperAdmins
    * const superAdmins = await prisma.superAdmin.findMany()
    * ```
    */
  get superAdmin(): Prisma.SuperAdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.school`: Exposes CRUD operations for the **School** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schools
    * const schools = await prisma.school.findMany()
    * ```
    */
  get school(): Prisma.SchoolDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.schoolAdmin`: Exposes CRUD operations for the **SchoolAdmin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SchoolAdmins
    * const schoolAdmins = await prisma.schoolAdmin.findMany()
    * ```
    */
  get schoolAdmin(): Prisma.SchoolAdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teacher`: Exposes CRUD operations for the **Teacher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teachers
    * const teachers = await prisma.teacher.findMany()
    * ```
    */
  get teacher(): Prisma.TeacherDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parent`: Exposes CRUD operations for the **Parent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parents
    * const parents = await prisma.parent.findMany()
    * ```
    */
  get parent(): Prisma.ParentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentParentLink`: Exposes CRUD operations for the **StudentParentLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentParentLinks
    * const studentParentLinks = await prisma.studentParentLink.findMany()
    * ```
    */
  get studentParentLink(): Prisma.StudentParentLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.class`: Exposes CRUD operations for the **Class** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classes
    * const classes = await prisma.class.findMany()
    * ```
    */
  get class(): Prisma.ClassDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentClassEnrollment`: Exposes CRUD operations for the **StudentClassEnrollment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentClassEnrollments
    * const studentClassEnrollments = await prisma.studentClassEnrollment.findMany()
    * ```
    */
  get studentClassEnrollment(): Prisma.StudentClassEnrollmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subject`: Exposes CRUD operations for the **Subject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subjects
    * const subjects = await prisma.subject.findMany()
    * ```
    */
  get subject(): Prisma.SubjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.timetableSlot`: Exposes CRUD operations for the **TimetableSlot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TimetableSlots
    * const timetableSlots = await prisma.timetableSlot.findMany()
    * ```
    */
  get timetableSlot(): Prisma.TimetableSlotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentAttendance`: Exposes CRUD operations for the **StudentAttendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentAttendances
    * const studentAttendances = await prisma.studentAttendance.findMany()
    * ```
    */
  get studentAttendance(): Prisma.StudentAttendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assignment`: Exposes CRUD operations for the **Assignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assignments
    * const assignments = await prisma.assignment.findMany()
    * ```
    */
  get assignment(): Prisma.AssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentGrade`: Exposes CRUD operations for the **StudentGrade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentGrades
    * const studentGrades = await prisma.studentGrade.findMany()
    * ```
    */
  get studentGrade(): Prisma.StudentGradeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feeStructure`: Exposes CRUD operations for the **FeeStructure** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeeStructures
    * const feeStructures = await prisma.feeStructure.findMany()
    * ```
    */
  get feeStructure(): Prisma.FeeStructureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoiceLineItem`: Exposes CRUD operations for the **InvoiceLineItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceLineItems
    * const invoiceLineItems = await prisma.invoiceLineItem.findMany()
    * ```
    */
  get invoiceLineItem(): Prisma.InvoiceLineItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.schoolAnnouncement`: Exposes CRUD operations for the **SchoolAnnouncement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SchoolAnnouncements
    * const schoolAnnouncements = await prisma.schoolAnnouncement.findMany()
    * ```
    */
  get schoolAnnouncement(): Prisma.SchoolAnnouncementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.classAnnouncement`: Exposes CRUD operations for the **ClassAnnouncement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassAnnouncements
    * const classAnnouncements = await prisma.classAnnouncement.findMany()
    * ```
    */
  get classAnnouncement(): Prisma.ClassAnnouncementDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Account: 'Account',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    SuperAdmin: 'SuperAdmin',
    School: 'School',
    SchoolAdmin: 'SchoolAdmin',
    Teacher: 'Teacher',
    Student: 'Student',
    Parent: 'Parent',
    StudentParentLink: 'StudentParentLink',
    Class: 'Class',
    StudentClassEnrollment: 'StudentClassEnrollment',
    Subject: 'Subject',
    TimetableSlot: 'TimetableSlot',
    StudentAttendance: 'StudentAttendance',
    Assignment: 'Assignment',
    StudentGrade: 'StudentGrade',
    FeeStructure: 'FeeStructure',
    Invoice: 'Invoice',
    InvoiceLineItem: 'InvoiceLineItem',
    Payment: 'Payment',
    SchoolAnnouncement: 'SchoolAnnouncement',
    ClassAnnouncement: 'ClassAnnouncement'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "account" | "session" | "verificationToken" | "superAdmin" | "school" | "schoolAdmin" | "teacher" | "student" | "parent" | "studentParentLink" | "class" | "studentClassEnrollment" | "subject" | "timetableSlot" | "studentAttendance" | "assignment" | "studentGrade" | "feeStructure" | "invoice" | "invoiceLineItem" | "payment" | "schoolAnnouncement" | "classAnnouncement"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      SuperAdmin: {
        payload: Prisma.$SuperAdminPayload<ExtArgs>
        fields: Prisma.SuperAdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SuperAdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SuperAdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>
          }
          findFirst: {
            args: Prisma.SuperAdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SuperAdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>
          }
          findMany: {
            args: Prisma.SuperAdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>[]
          }
          create: {
            args: Prisma.SuperAdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>
          }
          createMany: {
            args: Prisma.SuperAdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SuperAdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>
          }
          update: {
            args: Prisma.SuperAdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>
          }
          deleteMany: {
            args: Prisma.SuperAdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SuperAdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SuperAdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>
          }
          aggregate: {
            args: Prisma.SuperAdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSuperAdmin>
          }
          groupBy: {
            args: Prisma.SuperAdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<SuperAdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.SuperAdminCountArgs<ExtArgs>
            result: $Utils.Optional<SuperAdminCountAggregateOutputType> | number
          }
        }
      }
      School: {
        payload: Prisma.$SchoolPayload<ExtArgs>
        fields: Prisma.SchoolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          findFirst: {
            args: Prisma.SchoolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          findMany: {
            args: Prisma.SchoolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          create: {
            args: Prisma.SchoolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          createMany: {
            args: Prisma.SchoolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SchoolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          update: {
            args: Prisma.SchoolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          deleteMany: {
            args: Prisma.SchoolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SchoolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          aggregate: {
            args: Prisma.SchoolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchool>
          }
          groupBy: {
            args: Prisma.SchoolGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolCountAggregateOutputType> | number
          }
        }
      }
      SchoolAdmin: {
        payload: Prisma.$SchoolAdminPayload<ExtArgs>
        fields: Prisma.SchoolAdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolAdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolAdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolAdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolAdminPayload>
          }
          findFirst: {
            args: Prisma.SchoolAdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolAdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolAdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolAdminPayload>
          }
          findMany: {
            args: Prisma.SchoolAdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolAdminPayload>[]
          }
          create: {
            args: Prisma.SchoolAdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolAdminPayload>
          }
          createMany: {
            args: Prisma.SchoolAdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SchoolAdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolAdminPayload>
          }
          update: {
            args: Prisma.SchoolAdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolAdminPayload>
          }
          deleteMany: {
            args: Prisma.SchoolAdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolAdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SchoolAdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolAdminPayload>
          }
          aggregate: {
            args: Prisma.SchoolAdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchoolAdmin>
          }
          groupBy: {
            args: Prisma.SchoolAdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolAdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolAdminCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolAdminCountAggregateOutputType> | number
          }
        }
      }
      Teacher: {
        payload: Prisma.$TeacherPayload<ExtArgs>
        fields: Prisma.TeacherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeacherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeacherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          findFirst: {
            args: Prisma.TeacherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeacherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          findMany: {
            args: Prisma.TeacherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>[]
          }
          create: {
            args: Prisma.TeacherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          createMany: {
            args: Prisma.TeacherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TeacherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          update: {
            args: Prisma.TeacherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          deleteMany: {
            args: Prisma.TeacherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeacherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeacherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          aggregate: {
            args: Prisma.TeacherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeacher>
          }
          groupBy: {
            args: Prisma.TeacherGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeacherGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeacherCountArgs<ExtArgs>
            result: $Utils.Optional<TeacherCountAggregateOutputType> | number
          }
        }
      }
      Student: {
        payload: Prisma.$StudentPayload<ExtArgs>
        fields: Prisma.StudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findFirst: {
            args: Prisma.StudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findMany: {
            args: Prisma.StudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          create: {
            args: Prisma.StudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          createMany: {
            args: Prisma.StudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          update: {
            args: Prisma.StudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.StudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      Parent: {
        payload: Prisma.$ParentPayload<ExtArgs>
        fields: Prisma.ParentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          findFirst: {
            args: Prisma.ParentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          findMany: {
            args: Prisma.ParentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>[]
          }
          create: {
            args: Prisma.ParentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          createMany: {
            args: Prisma.ParentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ParentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          update: {
            args: Prisma.ParentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          deleteMany: {
            args: Prisma.ParentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ParentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          aggregate: {
            args: Prisma.ParentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParent>
          }
          groupBy: {
            args: Prisma.ParentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParentCountArgs<ExtArgs>
            result: $Utils.Optional<ParentCountAggregateOutputType> | number
          }
        }
      }
      StudentParentLink: {
        payload: Prisma.$StudentParentLinkPayload<ExtArgs>
        fields: Prisma.StudentParentLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentParentLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentParentLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentLinkPayload>
          }
          findFirst: {
            args: Prisma.StudentParentLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentParentLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentLinkPayload>
          }
          findMany: {
            args: Prisma.StudentParentLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentLinkPayload>[]
          }
          create: {
            args: Prisma.StudentParentLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentLinkPayload>
          }
          createMany: {
            args: Prisma.StudentParentLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StudentParentLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentLinkPayload>
          }
          update: {
            args: Prisma.StudentParentLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentLinkPayload>
          }
          deleteMany: {
            args: Prisma.StudentParentLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentParentLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentParentLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentLinkPayload>
          }
          aggregate: {
            args: Prisma.StudentParentLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentParentLink>
          }
          groupBy: {
            args: Prisma.StudentParentLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentParentLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentParentLinkCountArgs<ExtArgs>
            result: $Utils.Optional<StudentParentLinkCountAggregateOutputType> | number
          }
        }
      }
      Class: {
        payload: Prisma.$ClassPayload<ExtArgs>
        fields: Prisma.ClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findFirst: {
            args: Prisma.ClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findMany: {
            args: Prisma.ClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          create: {
            args: Prisma.ClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          createMany: {
            args: Prisma.ClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          update: {
            args: Prisma.ClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          deleteMany: {
            args: Prisma.ClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          aggregate: {
            args: Prisma.ClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClass>
          }
          groupBy: {
            args: Prisma.ClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassCountArgs<ExtArgs>
            result: $Utils.Optional<ClassCountAggregateOutputType> | number
          }
        }
      }
      StudentClassEnrollment: {
        payload: Prisma.$StudentClassEnrollmentPayload<ExtArgs>
        fields: Prisma.StudentClassEnrollmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentClassEnrollmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentClassEnrollmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentClassEnrollmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentClassEnrollmentPayload>
          }
          findFirst: {
            args: Prisma.StudentClassEnrollmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentClassEnrollmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentClassEnrollmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentClassEnrollmentPayload>
          }
          findMany: {
            args: Prisma.StudentClassEnrollmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentClassEnrollmentPayload>[]
          }
          create: {
            args: Prisma.StudentClassEnrollmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentClassEnrollmentPayload>
          }
          createMany: {
            args: Prisma.StudentClassEnrollmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StudentClassEnrollmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentClassEnrollmentPayload>
          }
          update: {
            args: Prisma.StudentClassEnrollmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentClassEnrollmentPayload>
          }
          deleteMany: {
            args: Prisma.StudentClassEnrollmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentClassEnrollmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentClassEnrollmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentClassEnrollmentPayload>
          }
          aggregate: {
            args: Prisma.StudentClassEnrollmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentClassEnrollment>
          }
          groupBy: {
            args: Prisma.StudentClassEnrollmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentClassEnrollmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentClassEnrollmentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentClassEnrollmentCountAggregateOutputType> | number
          }
        }
      }
      Subject: {
        payload: Prisma.$SubjectPayload<ExtArgs>
        fields: Prisma.SubjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          findFirst: {
            args: Prisma.SubjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          findMany: {
            args: Prisma.SubjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          create: {
            args: Prisma.SubjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          createMany: {
            args: Prisma.SubjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SubjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          update: {
            args: Prisma.SubjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          deleteMany: {
            args: Prisma.SubjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          aggregate: {
            args: Prisma.SubjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubject>
          }
          groupBy: {
            args: Prisma.SubjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubjectCountArgs<ExtArgs>
            result: $Utils.Optional<SubjectCountAggregateOutputType> | number
          }
        }
      }
      TimetableSlot: {
        payload: Prisma.$TimetableSlotPayload<ExtArgs>
        fields: Prisma.TimetableSlotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimetableSlotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetableSlotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimetableSlotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetableSlotPayload>
          }
          findFirst: {
            args: Prisma.TimetableSlotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetableSlotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimetableSlotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetableSlotPayload>
          }
          findMany: {
            args: Prisma.TimetableSlotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetableSlotPayload>[]
          }
          create: {
            args: Prisma.TimetableSlotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetableSlotPayload>
          }
          createMany: {
            args: Prisma.TimetableSlotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TimetableSlotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetableSlotPayload>
          }
          update: {
            args: Prisma.TimetableSlotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetableSlotPayload>
          }
          deleteMany: {
            args: Prisma.TimetableSlotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimetableSlotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TimetableSlotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetableSlotPayload>
          }
          aggregate: {
            args: Prisma.TimetableSlotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimetableSlot>
          }
          groupBy: {
            args: Prisma.TimetableSlotGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimetableSlotGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimetableSlotCountArgs<ExtArgs>
            result: $Utils.Optional<TimetableSlotCountAggregateOutputType> | number
          }
        }
      }
      StudentAttendance: {
        payload: Prisma.$StudentAttendancePayload<ExtArgs>
        fields: Prisma.StudentAttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentAttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentAttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>
          }
          findFirst: {
            args: Prisma.StudentAttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentAttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>
          }
          findMany: {
            args: Prisma.StudentAttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>[]
          }
          create: {
            args: Prisma.StudentAttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>
          }
          createMany: {
            args: Prisma.StudentAttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StudentAttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>
          }
          update: {
            args: Prisma.StudentAttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>
          }
          deleteMany: {
            args: Prisma.StudentAttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentAttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentAttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>
          }
          aggregate: {
            args: Prisma.StudentAttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentAttendance>
          }
          groupBy: {
            args: Prisma.StudentAttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentAttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentAttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<StudentAttendanceCountAggregateOutputType> | number
          }
        }
      }
      Assignment: {
        payload: Prisma.$AssignmentPayload<ExtArgs>
        fields: Prisma.AssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          findFirst: {
            args: Prisma.AssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          findMany: {
            args: Prisma.AssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>[]
          }
          create: {
            args: Prisma.AssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          createMany: {
            args: Prisma.AssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          update: {
            args: Prisma.AssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          deleteMany: {
            args: Prisma.AssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          aggregate: {
            args: Prisma.AssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssignment>
          }
          groupBy: {
            args: Prisma.AssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<AssignmentCountAggregateOutputType> | number
          }
        }
      }
      StudentGrade: {
        payload: Prisma.$StudentGradePayload<ExtArgs>
        fields: Prisma.StudentGradeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentGradeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentGradePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentGradeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentGradePayload>
          }
          findFirst: {
            args: Prisma.StudentGradeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentGradePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentGradeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentGradePayload>
          }
          findMany: {
            args: Prisma.StudentGradeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentGradePayload>[]
          }
          create: {
            args: Prisma.StudentGradeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentGradePayload>
          }
          createMany: {
            args: Prisma.StudentGradeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StudentGradeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentGradePayload>
          }
          update: {
            args: Prisma.StudentGradeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentGradePayload>
          }
          deleteMany: {
            args: Prisma.StudentGradeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentGradeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentGradeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentGradePayload>
          }
          aggregate: {
            args: Prisma.StudentGradeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentGrade>
          }
          groupBy: {
            args: Prisma.StudentGradeGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGradeGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentGradeCountArgs<ExtArgs>
            result: $Utils.Optional<StudentGradeCountAggregateOutputType> | number
          }
        }
      }
      FeeStructure: {
        payload: Prisma.$FeeStructurePayload<ExtArgs>
        fields: Prisma.FeeStructureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeeStructureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeeStructureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload>
          }
          findFirst: {
            args: Prisma.FeeStructureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeeStructureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload>
          }
          findMany: {
            args: Prisma.FeeStructureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload>[]
          }
          create: {
            args: Prisma.FeeStructureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload>
          }
          createMany: {
            args: Prisma.FeeStructureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FeeStructureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload>
          }
          update: {
            args: Prisma.FeeStructureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload>
          }
          deleteMany: {
            args: Prisma.FeeStructureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeeStructureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FeeStructureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload>
          }
          aggregate: {
            args: Prisma.FeeStructureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeeStructure>
          }
          groupBy: {
            args: Prisma.FeeStructureGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeeStructureGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeeStructureCountArgs<ExtArgs>
            result: $Utils.Optional<FeeStructureCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      InvoiceLineItem: {
        payload: Prisma.$InvoiceLineItemPayload<ExtArgs>
        fields: Prisma.InvoiceLineItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceLineItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLineItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceLineItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLineItemPayload>
          }
          findFirst: {
            args: Prisma.InvoiceLineItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLineItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceLineItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLineItemPayload>
          }
          findMany: {
            args: Prisma.InvoiceLineItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLineItemPayload>[]
          }
          create: {
            args: Prisma.InvoiceLineItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLineItemPayload>
          }
          createMany: {
            args: Prisma.InvoiceLineItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InvoiceLineItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLineItemPayload>
          }
          update: {
            args: Prisma.InvoiceLineItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLineItemPayload>
          }
          deleteMany: {
            args: Prisma.InvoiceLineItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceLineItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceLineItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLineItemPayload>
          }
          aggregate: {
            args: Prisma.InvoiceLineItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceLineItem>
          }
          groupBy: {
            args: Prisma.InvoiceLineItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceLineItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceLineItemCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceLineItemCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      SchoolAnnouncement: {
        payload: Prisma.$SchoolAnnouncementPayload<ExtArgs>
        fields: Prisma.SchoolAnnouncementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolAnnouncementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolAnnouncementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolAnnouncementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolAnnouncementPayload>
          }
          findFirst: {
            args: Prisma.SchoolAnnouncementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolAnnouncementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolAnnouncementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolAnnouncementPayload>
          }
          findMany: {
            args: Prisma.SchoolAnnouncementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolAnnouncementPayload>[]
          }
          create: {
            args: Prisma.SchoolAnnouncementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolAnnouncementPayload>
          }
          createMany: {
            args: Prisma.SchoolAnnouncementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SchoolAnnouncementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolAnnouncementPayload>
          }
          update: {
            args: Prisma.SchoolAnnouncementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolAnnouncementPayload>
          }
          deleteMany: {
            args: Prisma.SchoolAnnouncementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolAnnouncementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SchoolAnnouncementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolAnnouncementPayload>
          }
          aggregate: {
            args: Prisma.SchoolAnnouncementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchoolAnnouncement>
          }
          groupBy: {
            args: Prisma.SchoolAnnouncementGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolAnnouncementGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolAnnouncementCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolAnnouncementCountAggregateOutputType> | number
          }
        }
      }
      ClassAnnouncement: {
        payload: Prisma.$ClassAnnouncementPayload<ExtArgs>
        fields: Prisma.ClassAnnouncementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassAnnouncementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassAnnouncementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassAnnouncementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassAnnouncementPayload>
          }
          findFirst: {
            args: Prisma.ClassAnnouncementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassAnnouncementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassAnnouncementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassAnnouncementPayload>
          }
          findMany: {
            args: Prisma.ClassAnnouncementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassAnnouncementPayload>[]
          }
          create: {
            args: Prisma.ClassAnnouncementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassAnnouncementPayload>
          }
          createMany: {
            args: Prisma.ClassAnnouncementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClassAnnouncementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassAnnouncementPayload>
          }
          update: {
            args: Prisma.ClassAnnouncementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassAnnouncementPayload>
          }
          deleteMany: {
            args: Prisma.ClassAnnouncementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassAnnouncementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClassAnnouncementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassAnnouncementPayload>
          }
          aggregate: {
            args: Prisma.ClassAnnouncementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassAnnouncement>
          }
          groupBy: {
            args: Prisma.ClassAnnouncementGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassAnnouncementGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassAnnouncementCountArgs<ExtArgs>
            result: $Utils.Optional<ClassAnnouncementCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    account?: AccountOmit
    session?: SessionOmit
    verificationToken?: VerificationTokenOmit
    superAdmin?: SuperAdminOmit
    school?: SchoolOmit
    schoolAdmin?: SchoolAdminOmit
    teacher?: TeacherOmit
    student?: StudentOmit
    parent?: ParentOmit
    studentParentLink?: StudentParentLinkOmit
    class?: ClassOmit
    studentClassEnrollment?: StudentClassEnrollmentOmit
    subject?: SubjectOmit
    timetableSlot?: TimetableSlotOmit
    studentAttendance?: StudentAttendanceOmit
    assignment?: AssignmentOmit
    studentGrade?: StudentGradeOmit
    feeStructure?: FeeStructureOmit
    invoice?: InvoiceOmit
    invoiceLineItem?: InvoiceLineItemOmit
    payment?: PaymentOmit
    schoolAnnouncement?: SchoolAnnouncementOmit
    classAnnouncement?: ClassAnnouncementOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
    schoolAdmins: number
    teacherLinks: number
    recordedAttendances: number
    recordedPayments: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    schoolAdmins?: boolean | UserCountOutputTypeCountSchoolAdminsArgs
    teacherLinks?: boolean | UserCountOutputTypeCountTeacherLinksArgs
    recordedAttendances?: boolean | UserCountOutputTypeCountRecordedAttendancesArgs
    recordedPayments?: boolean | UserCountOutputTypeCountRecordedPaymentsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSchoolAdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolAdminWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeacherLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRecordedAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentAttendanceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRecordedPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type SuperAdminCountOutputType
   */

  export type SuperAdminCountOutputType = {
    schoolsCreated: number
  }

  export type SuperAdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schoolsCreated?: boolean | SuperAdminCountOutputTypeCountSchoolsCreatedArgs
  }

  // Custom InputTypes
  /**
   * SuperAdminCountOutputType without action
   */
  export type SuperAdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminCountOutputType
     */
    select?: SuperAdminCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SuperAdminCountOutputType without action
   */
  export type SuperAdminCountOutputTypeCountSchoolsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolWhereInput
  }


  /**
   * Count Type SchoolCountOutputType
   */

  export type SchoolCountOutputType = {
    admins: number
    teachers: number
    students: number
    classes: number
    subjects: number
    feeStructures: number
    invoices: number
    timetableSlots: number
    announcements: number
    classAnnouncements: number
  }

  export type SchoolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admins?: boolean | SchoolCountOutputTypeCountAdminsArgs
    teachers?: boolean | SchoolCountOutputTypeCountTeachersArgs
    students?: boolean | SchoolCountOutputTypeCountStudentsArgs
    classes?: boolean | SchoolCountOutputTypeCountClassesArgs
    subjects?: boolean | SchoolCountOutputTypeCountSubjectsArgs
    feeStructures?: boolean | SchoolCountOutputTypeCountFeeStructuresArgs
    invoices?: boolean | SchoolCountOutputTypeCountInvoicesArgs
    timetableSlots?: boolean | SchoolCountOutputTypeCountTimetableSlotsArgs
    announcements?: boolean | SchoolCountOutputTypeCountAnnouncementsArgs
    classAnnouncements?: boolean | SchoolCountOutputTypeCountClassAnnouncementsArgs
  }

  // Custom InputTypes
  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolCountOutputType
     */
    select?: SchoolCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountAdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolAdminWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountTeachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountFeeStructuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeStructureWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountTimetableSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimetableSlotWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountAnnouncementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolAnnouncementWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountClassAnnouncementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassAnnouncementWhereInput
  }


  /**
   * Count Type SchoolAdminCountOutputType
   */

  export type SchoolAdminCountOutputType = {
    createdSchoolAnnouncements: number
  }

  export type SchoolAdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdSchoolAnnouncements?: boolean | SchoolAdminCountOutputTypeCountCreatedSchoolAnnouncementsArgs
  }

  // Custom InputTypes
  /**
   * SchoolAdminCountOutputType without action
   */
  export type SchoolAdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAdminCountOutputType
     */
    select?: SchoolAdminCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SchoolAdminCountOutputType without action
   */
  export type SchoolAdminCountOutputTypeCountCreatedSchoolAnnouncementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolAnnouncementWhereInput
  }


  /**
   * Count Type TeacherCountOutputType
   */

  export type TeacherCountOutputType = {
    classTeacherOf: number
    timetableSlots: number
    gradesGiven: number
    assignmentsCreated: number
    createdClassAnnouncements: number
  }

  export type TeacherCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classTeacherOf?: boolean | TeacherCountOutputTypeCountClassTeacherOfArgs
    timetableSlots?: boolean | TeacherCountOutputTypeCountTimetableSlotsArgs
    gradesGiven?: boolean | TeacherCountOutputTypeCountGradesGivenArgs
    assignmentsCreated?: boolean | TeacherCountOutputTypeCountAssignmentsCreatedArgs
    createdClassAnnouncements?: boolean | TeacherCountOutputTypeCountCreatedClassAnnouncementsArgs
  }

  // Custom InputTypes
  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherCountOutputType
     */
    select?: TeacherCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountClassTeacherOfArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountTimetableSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimetableSlotWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountGradesGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentGradeWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountAssignmentsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountCreatedClassAnnouncementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassAnnouncementWhereInput
  }


  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    parents: number
    enrollments: number
    attendances: number
    grades: number
    invoiceLineItems: number
    invoices: number
  }

  export type StudentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parents?: boolean | StudentCountOutputTypeCountParentsArgs
    enrollments?: boolean | StudentCountOutputTypeCountEnrollmentsArgs
    attendances?: boolean | StudentCountOutputTypeCountAttendancesArgs
    grades?: boolean | StudentCountOutputTypeCountGradesArgs
    invoiceLineItems?: boolean | StudentCountOutputTypeCountInvoiceLineItemsArgs
    invoices?: boolean | StudentCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountParentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentParentLinkWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentClassEnrollmentWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentAttendanceWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentGradeWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountInvoiceLineItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceLineItemWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * Count Type ParentCountOutputType
   */

  export type ParentCountOutputType = {
    children: number
    invoices: number
  }

  export type ParentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | ParentCountOutputTypeCountChildrenArgs
    invoices?: boolean | ParentCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * ParentCountOutputType without action
   */
  export type ParentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentCountOutputType
     */
    select?: ParentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ParentCountOutputType without action
   */
  export type ParentCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentParentLinkWhereInput
  }

  /**
   * ParentCountOutputType without action
   */
  export type ParentCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * Count Type ClassCountOutputType
   */

  export type ClassCountOutputType = {
    studentsEnrolled: number
    currentStudents: number
    timetableSlots: number
    assignments: number
    announcements: number
  }

  export type ClassCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentsEnrolled?: boolean | ClassCountOutputTypeCountStudentsEnrolledArgs
    currentStudents?: boolean | ClassCountOutputTypeCountCurrentStudentsArgs
    timetableSlots?: boolean | ClassCountOutputTypeCountTimetableSlotsArgs
    assignments?: boolean | ClassCountOutputTypeCountAssignmentsArgs
    announcements?: boolean | ClassCountOutputTypeCountAnnouncementsArgs
  }

  // Custom InputTypes
  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassCountOutputType
     */
    select?: ClassCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountStudentsEnrolledArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentClassEnrollmentWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountCurrentStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountTimetableSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimetableSlotWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountAnnouncementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassAnnouncementWhereInput
  }


  /**
   * Count Type SubjectCountOutputType
   */

  export type SubjectCountOutputType = {
    timetableSlots: number
    assignments: number
    grades: number
  }

  export type SubjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    timetableSlots?: boolean | SubjectCountOutputTypeCountTimetableSlotsArgs
    assignments?: boolean | SubjectCountOutputTypeCountAssignmentsArgs
    grades?: boolean | SubjectCountOutputTypeCountGradesArgs
  }

  // Custom InputTypes
  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectCountOutputType
     */
    select?: SubjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountTimetableSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimetableSlotWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentGradeWhereInput
  }


  /**
   * Count Type TimetableSlotCountOutputType
   */

  export type TimetableSlotCountOutputType = {
    attendances: number
  }

  export type TimetableSlotCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendances?: boolean | TimetableSlotCountOutputTypeCountAttendancesArgs
  }

  // Custom InputTypes
  /**
   * TimetableSlotCountOutputType without action
   */
  export type TimetableSlotCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimetableSlotCountOutputType
     */
    select?: TimetableSlotCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TimetableSlotCountOutputType without action
   */
  export type TimetableSlotCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentAttendanceWhereInput
  }


  /**
   * Count Type AssignmentCountOutputType
   */

  export type AssignmentCountOutputType = {
    grades: number
  }

  export type AssignmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grades?: boolean | AssignmentCountOutputTypeCountGradesArgs
  }

  // Custom InputTypes
  /**
   * AssignmentCountOutputType without action
   */
  export type AssignmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentCountOutputType
     */
    select?: AssignmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AssignmentCountOutputType without action
   */
  export type AssignmentCountOutputTypeCountGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentGradeWhereInput
  }


  /**
   * Count Type FeeStructureCountOutputType
   */

  export type FeeStructureCountOutputType = {
    invoiceLineItems: number
  }

  export type FeeStructureCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoiceLineItems?: boolean | FeeStructureCountOutputTypeCountInvoiceLineItemsArgs
  }

  // Custom InputTypes
  /**
   * FeeStructureCountOutputType without action
   */
  export type FeeStructureCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructureCountOutputType
     */
    select?: FeeStructureCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FeeStructureCountOutputType without action
   */
  export type FeeStructureCountOutputTypeCountInvoiceLineItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceLineItemWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    lineItems: number
    payments: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lineItems?: boolean | InvoiceCountOutputTypeCountLineItemsArgs
    payments?: boolean | InvoiceCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountLineItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceLineItemWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    hashedPassword: string | null
    firstName: string | null
    lastName: string | null
    phoneNumber: string | null
    profilePicture: string | null
    isActive: boolean | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    hashedPassword: string | null
    firstName: string | null
    lastName: string | null
    phoneNumber: string | null
    profilePicture: string | null
    isActive: boolean | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    hashedPassword: number
    firstName: number
    lastName: number
    phoneNumber: number
    profilePicture: number
    isActive: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    hashedPassword?: true
    firstName?: true
    lastName?: true
    phoneNumber?: true
    profilePicture?: true
    isActive?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    hashedPassword?: true
    firstName?: true
    lastName?: true
    phoneNumber?: true
    profilePicture?: true
    isActive?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    hashedPassword?: true
    firstName?: true
    lastName?: true
    phoneNumber?: true
    profilePicture?: true
    isActive?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    hashedPassword: string
    firstName: string
    lastName: string
    phoneNumber: string | null
    profilePicture: string | null
    isActive: boolean
    role: $Enums.UserRole
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    hashedPassword?: boolean
    firstName?: boolean
    lastName?: boolean
    phoneNumber?: boolean
    profilePicture?: boolean
    isActive?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    superAdmin?: boolean | User$superAdminArgs<ExtArgs>
    schoolAdmins?: boolean | User$schoolAdminsArgs<ExtArgs>
    teacherLinks?: boolean | User$teacherLinksArgs<ExtArgs>
    studentLink?: boolean | User$studentLinkArgs<ExtArgs>
    parentLink?: boolean | User$parentLinkArgs<ExtArgs>
    recordedAttendances?: boolean | User$recordedAttendancesArgs<ExtArgs>
    recordedPayments?: boolean | User$recordedPaymentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    hashedPassword?: boolean
    firstName?: boolean
    lastName?: boolean
    phoneNumber?: boolean
    profilePicture?: boolean
    isActive?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "hashedPassword" | "firstName" | "lastName" | "phoneNumber" | "profilePicture" | "isActive" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    superAdmin?: boolean | User$superAdminArgs<ExtArgs>
    schoolAdmins?: boolean | User$schoolAdminsArgs<ExtArgs>
    teacherLinks?: boolean | User$teacherLinksArgs<ExtArgs>
    studentLink?: boolean | User$studentLinkArgs<ExtArgs>
    parentLink?: boolean | User$parentLinkArgs<ExtArgs>
    recordedAttendances?: boolean | User$recordedAttendancesArgs<ExtArgs>
    recordedPayments?: boolean | User$recordedPaymentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      superAdmin: Prisma.$SuperAdminPayload<ExtArgs> | null
      schoolAdmins: Prisma.$SchoolAdminPayload<ExtArgs>[]
      teacherLinks: Prisma.$TeacherPayload<ExtArgs>[]
      studentLink: Prisma.$StudentPayload<ExtArgs> | null
      parentLink: Prisma.$ParentPayload<ExtArgs> | null
      recordedAttendances: Prisma.$StudentAttendancePayload<ExtArgs>[]
      recordedPayments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      hashedPassword: string
      firstName: string
      lastName: string
      phoneNumber: string | null
      profilePicture: string | null
      isActive: boolean
      role: $Enums.UserRole
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    superAdmin<T extends User$superAdminArgs<ExtArgs> = {}>(args?: Subset<T, User$superAdminArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    schoolAdmins<T extends User$schoolAdminsArgs<ExtArgs> = {}>(args?: Subset<T, User$schoolAdminsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolAdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teacherLinks<T extends User$teacherLinksArgs<ExtArgs> = {}>(args?: Subset<T, User$teacherLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentLink<T extends User$studentLinkArgs<ExtArgs> = {}>(args?: Subset<T, User$studentLinkArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    parentLink<T extends User$parentLinkArgs<ExtArgs> = {}>(args?: Subset<T, User$parentLinkArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    recordedAttendances<T extends User$recordedAttendancesArgs<ExtArgs> = {}>(args?: Subset<T, User$recordedAttendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recordedPayments<T extends User$recordedPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$recordedPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly hashedPassword: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly profilePicture: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.superAdmin
   */
  export type User$superAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    where?: SuperAdminWhereInput
  }

  /**
   * User.schoolAdmins
   */
  export type User$schoolAdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAdmin
     */
    select?: SchoolAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAdmin
     */
    omit?: SchoolAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAdminInclude<ExtArgs> | null
    where?: SchoolAdminWhereInput
    orderBy?: SchoolAdminOrderByWithRelationInput | SchoolAdminOrderByWithRelationInput[]
    cursor?: SchoolAdminWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchoolAdminScalarFieldEnum | SchoolAdminScalarFieldEnum[]
  }

  /**
   * User.teacherLinks
   */
  export type User$teacherLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    where?: TeacherWhereInput
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    cursor?: TeacherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * User.studentLink
   */
  export type User$studentLinkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * User.parentLink
   */
  export type User$parentLinkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    where?: ParentWhereInput
  }

  /**
   * User.recordedAttendances
   */
  export type User$recordedAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    where?: StudentAttendanceWhereInput
    orderBy?: StudentAttendanceOrderByWithRelationInput | StudentAttendanceOrderByWithRelationInput[]
    cursor?: StudentAttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentAttendanceScalarFieldEnum | StudentAttendanceScalarFieldEnum[]
  }

  /**
   * User.recordedPayments
   */
  export type User$recordedPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>



  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    createdAt: Date
    updatedAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>



  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires" | "createdAt" | "updatedAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    token: string | null
    expires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    token: string | null
    expires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    id: number
    identifier: number
    token: number
    expires: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    id?: true
    identifier?: true
    token?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    id?: true
    identifier?: true
    token?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    id?: true
    identifier?: true
    token?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    id: string
    identifier: string
    token: string
    expires: Date
    createdAt: Date
    updatedAt: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    token?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verificationToken"]>



  export type VerificationTokenSelectScalar = {
    id?: boolean
    identifier?: boolean
    token?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "token" | "expires" | "createdAt" | "updatedAt", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      token: string
      expires: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationTokenWithIdOnly = await prisma.verificationToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly id: FieldRef<"VerificationToken", 'String'>
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
    readonly createdAt: FieldRef<"VerificationToken", 'DateTime'>
    readonly updatedAt: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model SuperAdmin
   */

  export type AggregateSuperAdmin = {
    _count: SuperAdminCountAggregateOutputType | null
    _min: SuperAdminMinAggregateOutputType | null
    _max: SuperAdminMaxAggregateOutputType | null
  }

  export type SuperAdminMinAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SuperAdminMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SuperAdminCountAggregateOutputType = {
    id: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SuperAdminMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SuperAdminMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SuperAdminCountAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SuperAdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SuperAdmin to aggregate.
     */
    where?: SuperAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdmins to fetch.
     */
    orderBy?: SuperAdminOrderByWithRelationInput | SuperAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SuperAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SuperAdmins
    **/
    _count?: true | SuperAdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SuperAdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SuperAdminMaxAggregateInputType
  }

  export type GetSuperAdminAggregateType<T extends SuperAdminAggregateArgs> = {
        [P in keyof T & keyof AggregateSuperAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuperAdmin[P]>
      : GetScalarType<T[P], AggregateSuperAdmin[P]>
  }




  export type SuperAdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SuperAdminWhereInput
    orderBy?: SuperAdminOrderByWithAggregationInput | SuperAdminOrderByWithAggregationInput[]
    by: SuperAdminScalarFieldEnum[] | SuperAdminScalarFieldEnum
    having?: SuperAdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SuperAdminCountAggregateInputType | true
    _min?: SuperAdminMinAggregateInputType
    _max?: SuperAdminMaxAggregateInputType
  }

  export type SuperAdminGroupByOutputType = {
    id: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: SuperAdminCountAggregateOutputType | null
    _min: SuperAdminMinAggregateOutputType | null
    _max: SuperAdminMaxAggregateOutputType | null
  }

  type GetSuperAdminGroupByPayload<T extends SuperAdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SuperAdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SuperAdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SuperAdminGroupByOutputType[P]>
            : GetScalarType<T[P], SuperAdminGroupByOutputType[P]>
        }
      >
    >


  export type SuperAdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    schoolsCreated?: boolean | SuperAdmin$schoolsCreatedArgs<ExtArgs>
    _count?: boolean | SuperAdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["superAdmin"]>



  export type SuperAdminSelectScalar = {
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SuperAdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["superAdmin"]>
  export type SuperAdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    schoolsCreated?: boolean | SuperAdmin$schoolsCreatedArgs<ExtArgs>
    _count?: boolean | SuperAdminCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SuperAdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SuperAdmin"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      schoolsCreated: Prisma.$SchoolPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["superAdmin"]>
    composites: {}
  }

  type SuperAdminGetPayload<S extends boolean | null | undefined | SuperAdminDefaultArgs> = $Result.GetResult<Prisma.$SuperAdminPayload, S>

  type SuperAdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SuperAdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SuperAdminCountAggregateInputType | true
    }

  export interface SuperAdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SuperAdmin'], meta: { name: 'SuperAdmin' } }
    /**
     * Find zero or one SuperAdmin that matches the filter.
     * @param {SuperAdminFindUniqueArgs} args - Arguments to find a SuperAdmin
     * @example
     * // Get one SuperAdmin
     * const superAdmin = await prisma.superAdmin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SuperAdminFindUniqueArgs>(args: SelectSubset<T, SuperAdminFindUniqueArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SuperAdmin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SuperAdminFindUniqueOrThrowArgs} args - Arguments to find a SuperAdmin
     * @example
     * // Get one SuperAdmin
     * const superAdmin = await prisma.superAdmin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SuperAdminFindUniqueOrThrowArgs>(args: SelectSubset<T, SuperAdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SuperAdmin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminFindFirstArgs} args - Arguments to find a SuperAdmin
     * @example
     * // Get one SuperAdmin
     * const superAdmin = await prisma.superAdmin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SuperAdminFindFirstArgs>(args?: SelectSubset<T, SuperAdminFindFirstArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SuperAdmin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminFindFirstOrThrowArgs} args - Arguments to find a SuperAdmin
     * @example
     * // Get one SuperAdmin
     * const superAdmin = await prisma.superAdmin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SuperAdminFindFirstOrThrowArgs>(args?: SelectSubset<T, SuperAdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SuperAdmins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SuperAdmins
     * const superAdmins = await prisma.superAdmin.findMany()
     * 
     * // Get first 10 SuperAdmins
     * const superAdmins = await prisma.superAdmin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const superAdminWithIdOnly = await prisma.superAdmin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SuperAdminFindManyArgs>(args?: SelectSubset<T, SuperAdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SuperAdmin.
     * @param {SuperAdminCreateArgs} args - Arguments to create a SuperAdmin.
     * @example
     * // Create one SuperAdmin
     * const SuperAdmin = await prisma.superAdmin.create({
     *   data: {
     *     // ... data to create a SuperAdmin
     *   }
     * })
     * 
     */
    create<T extends SuperAdminCreateArgs>(args: SelectSubset<T, SuperAdminCreateArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SuperAdmins.
     * @param {SuperAdminCreateManyArgs} args - Arguments to create many SuperAdmins.
     * @example
     * // Create many SuperAdmins
     * const superAdmin = await prisma.superAdmin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SuperAdminCreateManyArgs>(args?: SelectSubset<T, SuperAdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SuperAdmin.
     * @param {SuperAdminDeleteArgs} args - Arguments to delete one SuperAdmin.
     * @example
     * // Delete one SuperAdmin
     * const SuperAdmin = await prisma.superAdmin.delete({
     *   where: {
     *     // ... filter to delete one SuperAdmin
     *   }
     * })
     * 
     */
    delete<T extends SuperAdminDeleteArgs>(args: SelectSubset<T, SuperAdminDeleteArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SuperAdmin.
     * @param {SuperAdminUpdateArgs} args - Arguments to update one SuperAdmin.
     * @example
     * // Update one SuperAdmin
     * const superAdmin = await prisma.superAdmin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SuperAdminUpdateArgs>(args: SelectSubset<T, SuperAdminUpdateArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SuperAdmins.
     * @param {SuperAdminDeleteManyArgs} args - Arguments to filter SuperAdmins to delete.
     * @example
     * // Delete a few SuperAdmins
     * const { count } = await prisma.superAdmin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SuperAdminDeleteManyArgs>(args?: SelectSubset<T, SuperAdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SuperAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SuperAdmins
     * const superAdmin = await prisma.superAdmin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SuperAdminUpdateManyArgs>(args: SelectSubset<T, SuperAdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SuperAdmin.
     * @param {SuperAdminUpsertArgs} args - Arguments to update or create a SuperAdmin.
     * @example
     * // Update or create a SuperAdmin
     * const superAdmin = await prisma.superAdmin.upsert({
     *   create: {
     *     // ... data to create a SuperAdmin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SuperAdmin we want to update
     *   }
     * })
     */
    upsert<T extends SuperAdminUpsertArgs>(args: SelectSubset<T, SuperAdminUpsertArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SuperAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminCountArgs} args - Arguments to filter SuperAdmins to count.
     * @example
     * // Count the number of SuperAdmins
     * const count = await prisma.superAdmin.count({
     *   where: {
     *     // ... the filter for the SuperAdmins we want to count
     *   }
     * })
    **/
    count<T extends SuperAdminCountArgs>(
      args?: Subset<T, SuperAdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SuperAdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SuperAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SuperAdminAggregateArgs>(args: Subset<T, SuperAdminAggregateArgs>): Prisma.PrismaPromise<GetSuperAdminAggregateType<T>>

    /**
     * Group by SuperAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SuperAdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SuperAdminGroupByArgs['orderBy'] }
        : { orderBy?: SuperAdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SuperAdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSuperAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SuperAdmin model
   */
  readonly fields: SuperAdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SuperAdmin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SuperAdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    schoolsCreated<T extends SuperAdmin$schoolsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, SuperAdmin$schoolsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SuperAdmin model
   */
  interface SuperAdminFieldRefs {
    readonly id: FieldRef<"SuperAdmin", 'String'>
    readonly userId: FieldRef<"SuperAdmin", 'String'>
    readonly createdAt: FieldRef<"SuperAdmin", 'DateTime'>
    readonly updatedAt: FieldRef<"SuperAdmin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SuperAdmin findUnique
   */
  export type SuperAdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdmin to fetch.
     */
    where: SuperAdminWhereUniqueInput
  }

  /**
   * SuperAdmin findUniqueOrThrow
   */
  export type SuperAdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdmin to fetch.
     */
    where: SuperAdminWhereUniqueInput
  }

  /**
   * SuperAdmin findFirst
   */
  export type SuperAdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdmin to fetch.
     */
    where?: SuperAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdmins to fetch.
     */
    orderBy?: SuperAdminOrderByWithRelationInput | SuperAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SuperAdmins.
     */
    cursor?: SuperAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SuperAdmins.
     */
    distinct?: SuperAdminScalarFieldEnum | SuperAdminScalarFieldEnum[]
  }

  /**
   * SuperAdmin findFirstOrThrow
   */
  export type SuperAdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdmin to fetch.
     */
    where?: SuperAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdmins to fetch.
     */
    orderBy?: SuperAdminOrderByWithRelationInput | SuperAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SuperAdmins.
     */
    cursor?: SuperAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SuperAdmins.
     */
    distinct?: SuperAdminScalarFieldEnum | SuperAdminScalarFieldEnum[]
  }

  /**
   * SuperAdmin findMany
   */
  export type SuperAdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdmins to fetch.
     */
    where?: SuperAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdmins to fetch.
     */
    orderBy?: SuperAdminOrderByWithRelationInput | SuperAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SuperAdmins.
     */
    cursor?: SuperAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdmins.
     */
    skip?: number
    distinct?: SuperAdminScalarFieldEnum | SuperAdminScalarFieldEnum[]
  }

  /**
   * SuperAdmin create
   */
  export type SuperAdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * The data needed to create a SuperAdmin.
     */
    data: XOR<SuperAdminCreateInput, SuperAdminUncheckedCreateInput>
  }

  /**
   * SuperAdmin createMany
   */
  export type SuperAdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SuperAdmins.
     */
    data: SuperAdminCreateManyInput | SuperAdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SuperAdmin update
   */
  export type SuperAdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * The data needed to update a SuperAdmin.
     */
    data: XOR<SuperAdminUpdateInput, SuperAdminUncheckedUpdateInput>
    /**
     * Choose, which SuperAdmin to update.
     */
    where: SuperAdminWhereUniqueInput
  }

  /**
   * SuperAdmin updateMany
   */
  export type SuperAdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SuperAdmins.
     */
    data: XOR<SuperAdminUpdateManyMutationInput, SuperAdminUncheckedUpdateManyInput>
    /**
     * Filter which SuperAdmins to update
     */
    where?: SuperAdminWhereInput
    /**
     * Limit how many SuperAdmins to update.
     */
    limit?: number
  }

  /**
   * SuperAdmin upsert
   */
  export type SuperAdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * The filter to search for the SuperAdmin to update in case it exists.
     */
    where: SuperAdminWhereUniqueInput
    /**
     * In case the SuperAdmin found by the `where` argument doesn't exist, create a new SuperAdmin with this data.
     */
    create: XOR<SuperAdminCreateInput, SuperAdminUncheckedCreateInput>
    /**
     * In case the SuperAdmin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SuperAdminUpdateInput, SuperAdminUncheckedUpdateInput>
  }

  /**
   * SuperAdmin delete
   */
  export type SuperAdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * Filter which SuperAdmin to delete.
     */
    where: SuperAdminWhereUniqueInput
  }

  /**
   * SuperAdmin deleteMany
   */
  export type SuperAdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SuperAdmins to delete
     */
    where?: SuperAdminWhereInput
    /**
     * Limit how many SuperAdmins to delete.
     */
    limit?: number
  }

  /**
   * SuperAdmin.schoolsCreated
   */
  export type SuperAdmin$schoolsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    where?: SchoolWhereInput
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    cursor?: SchoolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * SuperAdmin without action
   */
  export type SuperAdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
  }


  /**
   * Model School
   */

  export type AggregateSchool = {
    _count: SchoolCountAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  export type SchoolMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    city: string | null
    stateOrRegion: string | null
    country: string | null
    postalCode: string | null
    phoneNumber: string | null
    schoolEmail: string | null
    website: string | null
    logoUrl: string | null
    currentAcademicYear: string | null
    currentTerm: $Enums.TermPeriod | null
    currency: string | null
    timezone: string | null
    isActive: boolean | null
    createdBySuperAdminId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    city: string | null
    stateOrRegion: string | null
    country: string | null
    postalCode: string | null
    phoneNumber: string | null
    schoolEmail: string | null
    website: string | null
    logoUrl: string | null
    currentAcademicYear: string | null
    currentTerm: $Enums.TermPeriod | null
    currency: string | null
    timezone: string | null
    isActive: boolean | null
    createdBySuperAdminId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolCountAggregateOutputType = {
    id: number
    name: number
    address: number
    city: number
    stateOrRegion: number
    country: number
    postalCode: number
    phoneNumber: number
    schoolEmail: number
    website: number
    logoUrl: number
    currentAcademicYear: number
    currentTerm: number
    currency: number
    timezone: number
    isActive: number
    createdBySuperAdminId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    stateOrRegion?: true
    country?: true
    postalCode?: true
    phoneNumber?: true
    schoolEmail?: true
    website?: true
    logoUrl?: true
    currentAcademicYear?: true
    currentTerm?: true
    currency?: true
    timezone?: true
    isActive?: true
    createdBySuperAdminId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    stateOrRegion?: true
    country?: true
    postalCode?: true
    phoneNumber?: true
    schoolEmail?: true
    website?: true
    logoUrl?: true
    currentAcademicYear?: true
    currentTerm?: true
    currency?: true
    timezone?: true
    isActive?: true
    createdBySuperAdminId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    stateOrRegion?: true
    country?: true
    postalCode?: true
    phoneNumber?: true
    schoolEmail?: true
    website?: true
    logoUrl?: true
    currentAcademicYear?: true
    currentTerm?: true
    currency?: true
    timezone?: true
    isActive?: true
    createdBySuperAdminId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which School to aggregate.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schools
    **/
    _count?: true | SchoolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolMaxAggregateInputType
  }

  export type GetSchoolAggregateType<T extends SchoolAggregateArgs> = {
        [P in keyof T & keyof AggregateSchool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchool[P]>
      : GetScalarType<T[P], AggregateSchool[P]>
  }




  export type SchoolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolWhereInput
    orderBy?: SchoolOrderByWithAggregationInput | SchoolOrderByWithAggregationInput[]
    by: SchoolScalarFieldEnum[] | SchoolScalarFieldEnum
    having?: SchoolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolCountAggregateInputType | true
    _min?: SchoolMinAggregateInputType
    _max?: SchoolMaxAggregateInputType
  }

  export type SchoolGroupByOutputType = {
    id: string
    name: string
    address: string | null
    city: string | null
    stateOrRegion: string | null
    country: string | null
    postalCode: string | null
    phoneNumber: string | null
    schoolEmail: string
    website: string | null
    logoUrl: string | null
    currentAcademicYear: string | null
    currentTerm: $Enums.TermPeriod | null
    currency: string
    timezone: string
    isActive: boolean
    createdBySuperAdminId: string | null
    createdAt: Date
    updatedAt: Date
    _count: SchoolCountAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  type GetSchoolGroupByPayload<T extends SchoolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolGroupByOutputType[P]>
        }
      >
    >


  export type SchoolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    stateOrRegion?: boolean
    country?: boolean
    postalCode?: boolean
    phoneNumber?: boolean
    schoolEmail?: boolean
    website?: boolean
    logoUrl?: boolean
    currentAcademicYear?: boolean
    currentTerm?: boolean
    currency?: boolean
    timezone?: boolean
    isActive?: boolean
    createdBySuperAdminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBySuperAdmin?: boolean | School$createdBySuperAdminArgs<ExtArgs>
    admins?: boolean | School$adminsArgs<ExtArgs>
    teachers?: boolean | School$teachersArgs<ExtArgs>
    students?: boolean | School$studentsArgs<ExtArgs>
    classes?: boolean | School$classesArgs<ExtArgs>
    subjects?: boolean | School$subjectsArgs<ExtArgs>
    feeStructures?: boolean | School$feeStructuresArgs<ExtArgs>
    invoices?: boolean | School$invoicesArgs<ExtArgs>
    timetableSlots?: boolean | School$timetableSlotsArgs<ExtArgs>
    announcements?: boolean | School$announcementsArgs<ExtArgs>
    classAnnouncements?: boolean | School$classAnnouncementsArgs<ExtArgs>
    _count?: boolean | SchoolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["school"]>



  export type SchoolSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    stateOrRegion?: boolean
    country?: boolean
    postalCode?: boolean
    phoneNumber?: boolean
    schoolEmail?: boolean
    website?: boolean
    logoUrl?: boolean
    currentAcademicYear?: boolean
    currentTerm?: boolean
    currency?: boolean
    timezone?: boolean
    isActive?: boolean
    createdBySuperAdminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SchoolOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "city" | "stateOrRegion" | "country" | "postalCode" | "phoneNumber" | "schoolEmail" | "website" | "logoUrl" | "currentAcademicYear" | "currentTerm" | "currency" | "timezone" | "isActive" | "createdBySuperAdminId" | "createdAt" | "updatedAt", ExtArgs["result"]["school"]>
  export type SchoolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBySuperAdmin?: boolean | School$createdBySuperAdminArgs<ExtArgs>
    admins?: boolean | School$adminsArgs<ExtArgs>
    teachers?: boolean | School$teachersArgs<ExtArgs>
    students?: boolean | School$studentsArgs<ExtArgs>
    classes?: boolean | School$classesArgs<ExtArgs>
    subjects?: boolean | School$subjectsArgs<ExtArgs>
    feeStructures?: boolean | School$feeStructuresArgs<ExtArgs>
    invoices?: boolean | School$invoicesArgs<ExtArgs>
    timetableSlots?: boolean | School$timetableSlotsArgs<ExtArgs>
    announcements?: boolean | School$announcementsArgs<ExtArgs>
    classAnnouncements?: boolean | School$classAnnouncementsArgs<ExtArgs>
    _count?: boolean | SchoolCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SchoolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "School"
    objects: {
      createdBySuperAdmin: Prisma.$SuperAdminPayload<ExtArgs> | null
      admins: Prisma.$SchoolAdminPayload<ExtArgs>[]
      teachers: Prisma.$TeacherPayload<ExtArgs>[]
      students: Prisma.$StudentPayload<ExtArgs>[]
      classes: Prisma.$ClassPayload<ExtArgs>[]
      subjects: Prisma.$SubjectPayload<ExtArgs>[]
      feeStructures: Prisma.$FeeStructurePayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      timetableSlots: Prisma.$TimetableSlotPayload<ExtArgs>[]
      announcements: Prisma.$SchoolAnnouncementPayload<ExtArgs>[]
      classAnnouncements: Prisma.$ClassAnnouncementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string | null
      city: string | null
      stateOrRegion: string | null
      country: string | null
      postalCode: string | null
      phoneNumber: string | null
      schoolEmail: string
      website: string | null
      logoUrl: string | null
      currentAcademicYear: string | null
      currentTerm: $Enums.TermPeriod | null
      currency: string
      timezone: string
      isActive: boolean
      createdBySuperAdminId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["school"]>
    composites: {}
  }

  type SchoolGetPayload<S extends boolean | null | undefined | SchoolDefaultArgs> = $Result.GetResult<Prisma.$SchoolPayload, S>

  type SchoolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SchoolFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SchoolCountAggregateInputType | true
    }

  export interface SchoolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['School'], meta: { name: 'School' } }
    /**
     * Find zero or one School that matches the filter.
     * @param {SchoolFindUniqueArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolFindUniqueArgs>(args: SelectSubset<T, SchoolFindUniqueArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one School that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SchoolFindUniqueOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first School that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindFirstArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolFindFirstArgs>(args?: SelectSubset<T, SchoolFindFirstArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first School that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindFirstOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Schools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schools
     * const schools = await prisma.school.findMany()
     * 
     * // Get first 10 Schools
     * const schools = await prisma.school.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolWithIdOnly = await prisma.school.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolFindManyArgs>(args?: SelectSubset<T, SchoolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a School.
     * @param {SchoolCreateArgs} args - Arguments to create a School.
     * @example
     * // Create one School
     * const School = await prisma.school.create({
     *   data: {
     *     // ... data to create a School
     *   }
     * })
     * 
     */
    create<T extends SchoolCreateArgs>(args: SelectSubset<T, SchoolCreateArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Schools.
     * @param {SchoolCreateManyArgs} args - Arguments to create many Schools.
     * @example
     * // Create many Schools
     * const school = await prisma.school.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolCreateManyArgs>(args?: SelectSubset<T, SchoolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a School.
     * @param {SchoolDeleteArgs} args - Arguments to delete one School.
     * @example
     * // Delete one School
     * const School = await prisma.school.delete({
     *   where: {
     *     // ... filter to delete one School
     *   }
     * })
     * 
     */
    delete<T extends SchoolDeleteArgs>(args: SelectSubset<T, SchoolDeleteArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one School.
     * @param {SchoolUpdateArgs} args - Arguments to update one School.
     * @example
     * // Update one School
     * const school = await prisma.school.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolUpdateArgs>(args: SelectSubset<T, SchoolUpdateArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Schools.
     * @param {SchoolDeleteManyArgs} args - Arguments to filter Schools to delete.
     * @example
     * // Delete a few Schools
     * const { count } = await prisma.school.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolDeleteManyArgs>(args?: SelectSubset<T, SchoolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schools
     * const school = await prisma.school.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolUpdateManyArgs>(args: SelectSubset<T, SchoolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one School.
     * @param {SchoolUpsertArgs} args - Arguments to update or create a School.
     * @example
     * // Update or create a School
     * const school = await prisma.school.upsert({
     *   create: {
     *     // ... data to create a School
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the School we want to update
     *   }
     * })
     */
    upsert<T extends SchoolUpsertArgs>(args: SelectSubset<T, SchoolUpsertArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolCountArgs} args - Arguments to filter Schools to count.
     * @example
     * // Count the number of Schools
     * const count = await prisma.school.count({
     *   where: {
     *     // ... the filter for the Schools we want to count
     *   }
     * })
    **/
    count<T extends SchoolCountArgs>(
      args?: Subset<T, SchoolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolAggregateArgs>(args: Subset<T, SchoolAggregateArgs>): Prisma.PrismaPromise<GetSchoolAggregateType<T>>

    /**
     * Group by School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolGroupByArgs['orderBy'] }
        : { orderBy?: SchoolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the School model
   */
  readonly fields: SchoolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for School.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBySuperAdmin<T extends School$createdBySuperAdminArgs<ExtArgs> = {}>(args?: Subset<T, School$createdBySuperAdminArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    admins<T extends School$adminsArgs<ExtArgs> = {}>(args?: Subset<T, School$adminsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolAdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teachers<T extends School$teachersArgs<ExtArgs> = {}>(args?: Subset<T, School$teachersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    students<T extends School$studentsArgs<ExtArgs> = {}>(args?: Subset<T, School$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    classes<T extends School$classesArgs<ExtArgs> = {}>(args?: Subset<T, School$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subjects<T extends School$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, School$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feeStructures<T extends School$feeStructuresArgs<ExtArgs> = {}>(args?: Subset<T, School$feeStructuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends School$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, School$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    timetableSlots<T extends School$timetableSlotsArgs<ExtArgs> = {}>(args?: Subset<T, School$timetableSlotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimetableSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    announcements<T extends School$announcementsArgs<ExtArgs> = {}>(args?: Subset<T, School$announcementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolAnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    classAnnouncements<T extends School$classAnnouncementsArgs<ExtArgs> = {}>(args?: Subset<T, School$classAnnouncementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassAnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the School model
   */
  interface SchoolFieldRefs {
    readonly id: FieldRef<"School", 'String'>
    readonly name: FieldRef<"School", 'String'>
    readonly address: FieldRef<"School", 'String'>
    readonly city: FieldRef<"School", 'String'>
    readonly stateOrRegion: FieldRef<"School", 'String'>
    readonly country: FieldRef<"School", 'String'>
    readonly postalCode: FieldRef<"School", 'String'>
    readonly phoneNumber: FieldRef<"School", 'String'>
    readonly schoolEmail: FieldRef<"School", 'String'>
    readonly website: FieldRef<"School", 'String'>
    readonly logoUrl: FieldRef<"School", 'String'>
    readonly currentAcademicYear: FieldRef<"School", 'String'>
    readonly currentTerm: FieldRef<"School", 'TermPeriod'>
    readonly currency: FieldRef<"School", 'String'>
    readonly timezone: FieldRef<"School", 'String'>
    readonly isActive: FieldRef<"School", 'Boolean'>
    readonly createdBySuperAdminId: FieldRef<"School", 'String'>
    readonly createdAt: FieldRef<"School", 'DateTime'>
    readonly updatedAt: FieldRef<"School", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * School findUnique
   */
  export type SchoolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School findUniqueOrThrow
   */
  export type SchoolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School findFirst
   */
  export type SchoolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schools.
     */
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School findFirstOrThrow
   */
  export type SchoolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schools.
     */
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School findMany
   */
  export type SchoolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which Schools to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School create
   */
  export type SchoolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The data needed to create a School.
     */
    data: XOR<SchoolCreateInput, SchoolUncheckedCreateInput>
  }

  /**
   * School createMany
   */
  export type SchoolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schools.
     */
    data: SchoolCreateManyInput | SchoolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * School update
   */
  export type SchoolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The data needed to update a School.
     */
    data: XOR<SchoolUpdateInput, SchoolUncheckedUpdateInput>
    /**
     * Choose, which School to update.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School updateMany
   */
  export type SchoolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schools.
     */
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyInput>
    /**
     * Filter which Schools to update
     */
    where?: SchoolWhereInput
    /**
     * Limit how many Schools to update.
     */
    limit?: number
  }

  /**
   * School upsert
   */
  export type SchoolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The filter to search for the School to update in case it exists.
     */
    where: SchoolWhereUniqueInput
    /**
     * In case the School found by the `where` argument doesn't exist, create a new School with this data.
     */
    create: XOR<SchoolCreateInput, SchoolUncheckedCreateInput>
    /**
     * In case the School was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolUpdateInput, SchoolUncheckedUpdateInput>
  }

  /**
   * School delete
   */
  export type SchoolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter which School to delete.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School deleteMany
   */
  export type SchoolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schools to delete
     */
    where?: SchoolWhereInput
    /**
     * Limit how many Schools to delete.
     */
    limit?: number
  }

  /**
   * School.createdBySuperAdmin
   */
  export type School$createdBySuperAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    where?: SuperAdminWhereInput
  }

  /**
   * School.admins
   */
  export type School$adminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAdmin
     */
    select?: SchoolAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAdmin
     */
    omit?: SchoolAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAdminInclude<ExtArgs> | null
    where?: SchoolAdminWhereInput
    orderBy?: SchoolAdminOrderByWithRelationInput | SchoolAdminOrderByWithRelationInput[]
    cursor?: SchoolAdminWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchoolAdminScalarFieldEnum | SchoolAdminScalarFieldEnum[]
  }

  /**
   * School.teachers
   */
  export type School$teachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    where?: TeacherWhereInput
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    cursor?: TeacherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * School.students
   */
  export type School$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * School.classes
   */
  export type School$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * School.subjects
   */
  export type School$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    cursor?: SubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * School.feeStructures
   */
  export type School$feeStructuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
    where?: FeeStructureWhereInput
    orderBy?: FeeStructureOrderByWithRelationInput | FeeStructureOrderByWithRelationInput[]
    cursor?: FeeStructureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeeStructureScalarFieldEnum | FeeStructureScalarFieldEnum[]
  }

  /**
   * School.invoices
   */
  export type School$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * School.timetableSlots
   */
  export type School$timetableSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimetableSlot
     */
    select?: TimetableSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimetableSlot
     */
    omit?: TimetableSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableSlotInclude<ExtArgs> | null
    where?: TimetableSlotWhereInput
    orderBy?: TimetableSlotOrderByWithRelationInput | TimetableSlotOrderByWithRelationInput[]
    cursor?: TimetableSlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimetableSlotScalarFieldEnum | TimetableSlotScalarFieldEnum[]
  }

  /**
   * School.announcements
   */
  export type School$announcementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAnnouncement
     */
    select?: SchoolAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAnnouncement
     */
    omit?: SchoolAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAnnouncementInclude<ExtArgs> | null
    where?: SchoolAnnouncementWhereInput
    orderBy?: SchoolAnnouncementOrderByWithRelationInput | SchoolAnnouncementOrderByWithRelationInput[]
    cursor?: SchoolAnnouncementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchoolAnnouncementScalarFieldEnum | SchoolAnnouncementScalarFieldEnum[]
  }

  /**
   * School.classAnnouncements
   */
  export type School$classAnnouncementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassAnnouncement
     */
    select?: ClassAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassAnnouncement
     */
    omit?: ClassAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassAnnouncementInclude<ExtArgs> | null
    where?: ClassAnnouncementWhereInput
    orderBy?: ClassAnnouncementOrderByWithRelationInput | ClassAnnouncementOrderByWithRelationInput[]
    cursor?: ClassAnnouncementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassAnnouncementScalarFieldEnum | ClassAnnouncementScalarFieldEnum[]
  }

  /**
   * School without action
   */
  export type SchoolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
  }


  /**
   * Model SchoolAdmin
   */

  export type AggregateSchoolAdmin = {
    _count: SchoolAdminCountAggregateOutputType | null
    _min: SchoolAdminMinAggregateOutputType | null
    _max: SchoolAdminMaxAggregateOutputType | null
  }

  export type SchoolAdminMinAggregateOutputType = {
    id: string | null
    userId: string | null
    schoolId: string | null
    jobTitle: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolAdminMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    schoolId: string | null
    jobTitle: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolAdminCountAggregateOutputType = {
    id: number
    userId: number
    schoolId: number
    jobTitle: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolAdminMinAggregateInputType = {
    id?: true
    userId?: true
    schoolId?: true
    jobTitle?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolAdminMaxAggregateInputType = {
    id?: true
    userId?: true
    schoolId?: true
    jobTitle?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolAdminCountAggregateInputType = {
    id?: true
    userId?: true
    schoolId?: true
    jobTitle?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolAdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolAdmin to aggregate.
     */
    where?: SchoolAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolAdmins to fetch.
     */
    orderBy?: SchoolAdminOrderByWithRelationInput | SchoolAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SchoolAdmins
    **/
    _count?: true | SchoolAdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolAdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolAdminMaxAggregateInputType
  }

  export type GetSchoolAdminAggregateType<T extends SchoolAdminAggregateArgs> = {
        [P in keyof T & keyof AggregateSchoolAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchoolAdmin[P]>
      : GetScalarType<T[P], AggregateSchoolAdmin[P]>
  }




  export type SchoolAdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolAdminWhereInput
    orderBy?: SchoolAdminOrderByWithAggregationInput | SchoolAdminOrderByWithAggregationInput[]
    by: SchoolAdminScalarFieldEnum[] | SchoolAdminScalarFieldEnum
    having?: SchoolAdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolAdminCountAggregateInputType | true
    _min?: SchoolAdminMinAggregateInputType
    _max?: SchoolAdminMaxAggregateInputType
  }

  export type SchoolAdminGroupByOutputType = {
    id: string
    userId: string
    schoolId: string
    jobTitle: string | null
    createdAt: Date
    updatedAt: Date
    _count: SchoolAdminCountAggregateOutputType | null
    _min: SchoolAdminMinAggregateOutputType | null
    _max: SchoolAdminMaxAggregateOutputType | null
  }

  type GetSchoolAdminGroupByPayload<T extends SchoolAdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolAdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolAdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolAdminGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolAdminGroupByOutputType[P]>
        }
      >
    >


  export type SchoolAdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    schoolId?: boolean
    jobTitle?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    createdSchoolAnnouncements?: boolean | SchoolAdmin$createdSchoolAnnouncementsArgs<ExtArgs>
    _count?: boolean | SchoolAdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolAdmin"]>



  export type SchoolAdminSelectScalar = {
    id?: boolean
    userId?: boolean
    schoolId?: boolean
    jobTitle?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SchoolAdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "schoolId" | "jobTitle" | "createdAt" | "updatedAt", ExtArgs["result"]["schoolAdmin"]>
  export type SchoolAdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    createdSchoolAnnouncements?: boolean | SchoolAdmin$createdSchoolAnnouncementsArgs<ExtArgs>
    _count?: boolean | SchoolAdminCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SchoolAdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SchoolAdmin"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      school: Prisma.$SchoolPayload<ExtArgs>
      createdSchoolAnnouncements: Prisma.$SchoolAnnouncementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      schoolId: string
      jobTitle: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["schoolAdmin"]>
    composites: {}
  }

  type SchoolAdminGetPayload<S extends boolean | null | undefined | SchoolAdminDefaultArgs> = $Result.GetResult<Prisma.$SchoolAdminPayload, S>

  type SchoolAdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SchoolAdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SchoolAdminCountAggregateInputType | true
    }

  export interface SchoolAdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SchoolAdmin'], meta: { name: 'SchoolAdmin' } }
    /**
     * Find zero or one SchoolAdmin that matches the filter.
     * @param {SchoolAdminFindUniqueArgs} args - Arguments to find a SchoolAdmin
     * @example
     * // Get one SchoolAdmin
     * const schoolAdmin = await prisma.schoolAdmin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolAdminFindUniqueArgs>(args: SelectSubset<T, SchoolAdminFindUniqueArgs<ExtArgs>>): Prisma__SchoolAdminClient<$Result.GetResult<Prisma.$SchoolAdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SchoolAdmin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SchoolAdminFindUniqueOrThrowArgs} args - Arguments to find a SchoolAdmin
     * @example
     * // Get one SchoolAdmin
     * const schoolAdmin = await prisma.schoolAdmin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolAdminFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolAdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolAdminClient<$Result.GetResult<Prisma.$SchoolAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SchoolAdmin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAdminFindFirstArgs} args - Arguments to find a SchoolAdmin
     * @example
     * // Get one SchoolAdmin
     * const schoolAdmin = await prisma.schoolAdmin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolAdminFindFirstArgs>(args?: SelectSubset<T, SchoolAdminFindFirstArgs<ExtArgs>>): Prisma__SchoolAdminClient<$Result.GetResult<Prisma.$SchoolAdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SchoolAdmin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAdminFindFirstOrThrowArgs} args - Arguments to find a SchoolAdmin
     * @example
     * // Get one SchoolAdmin
     * const schoolAdmin = await prisma.schoolAdmin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolAdminFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolAdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolAdminClient<$Result.GetResult<Prisma.$SchoolAdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SchoolAdmins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SchoolAdmins
     * const schoolAdmins = await prisma.schoolAdmin.findMany()
     * 
     * // Get first 10 SchoolAdmins
     * const schoolAdmins = await prisma.schoolAdmin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolAdminWithIdOnly = await prisma.schoolAdmin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolAdminFindManyArgs>(args?: SelectSubset<T, SchoolAdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolAdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SchoolAdmin.
     * @param {SchoolAdminCreateArgs} args - Arguments to create a SchoolAdmin.
     * @example
     * // Create one SchoolAdmin
     * const SchoolAdmin = await prisma.schoolAdmin.create({
     *   data: {
     *     // ... data to create a SchoolAdmin
     *   }
     * })
     * 
     */
    create<T extends SchoolAdminCreateArgs>(args: SelectSubset<T, SchoolAdminCreateArgs<ExtArgs>>): Prisma__SchoolAdminClient<$Result.GetResult<Prisma.$SchoolAdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SchoolAdmins.
     * @param {SchoolAdminCreateManyArgs} args - Arguments to create many SchoolAdmins.
     * @example
     * // Create many SchoolAdmins
     * const schoolAdmin = await prisma.schoolAdmin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolAdminCreateManyArgs>(args?: SelectSubset<T, SchoolAdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SchoolAdmin.
     * @param {SchoolAdminDeleteArgs} args - Arguments to delete one SchoolAdmin.
     * @example
     * // Delete one SchoolAdmin
     * const SchoolAdmin = await prisma.schoolAdmin.delete({
     *   where: {
     *     // ... filter to delete one SchoolAdmin
     *   }
     * })
     * 
     */
    delete<T extends SchoolAdminDeleteArgs>(args: SelectSubset<T, SchoolAdminDeleteArgs<ExtArgs>>): Prisma__SchoolAdminClient<$Result.GetResult<Prisma.$SchoolAdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SchoolAdmin.
     * @param {SchoolAdminUpdateArgs} args - Arguments to update one SchoolAdmin.
     * @example
     * // Update one SchoolAdmin
     * const schoolAdmin = await prisma.schoolAdmin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolAdminUpdateArgs>(args: SelectSubset<T, SchoolAdminUpdateArgs<ExtArgs>>): Prisma__SchoolAdminClient<$Result.GetResult<Prisma.$SchoolAdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SchoolAdmins.
     * @param {SchoolAdminDeleteManyArgs} args - Arguments to filter SchoolAdmins to delete.
     * @example
     * // Delete a few SchoolAdmins
     * const { count } = await prisma.schoolAdmin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolAdminDeleteManyArgs>(args?: SelectSubset<T, SchoolAdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SchoolAdmins
     * const schoolAdmin = await prisma.schoolAdmin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolAdminUpdateManyArgs>(args: SelectSubset<T, SchoolAdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SchoolAdmin.
     * @param {SchoolAdminUpsertArgs} args - Arguments to update or create a SchoolAdmin.
     * @example
     * // Update or create a SchoolAdmin
     * const schoolAdmin = await prisma.schoolAdmin.upsert({
     *   create: {
     *     // ... data to create a SchoolAdmin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SchoolAdmin we want to update
     *   }
     * })
     */
    upsert<T extends SchoolAdminUpsertArgs>(args: SelectSubset<T, SchoolAdminUpsertArgs<ExtArgs>>): Prisma__SchoolAdminClient<$Result.GetResult<Prisma.$SchoolAdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SchoolAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAdminCountArgs} args - Arguments to filter SchoolAdmins to count.
     * @example
     * // Count the number of SchoolAdmins
     * const count = await prisma.schoolAdmin.count({
     *   where: {
     *     // ... the filter for the SchoolAdmins we want to count
     *   }
     * })
    **/
    count<T extends SchoolAdminCountArgs>(
      args?: Subset<T, SchoolAdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolAdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SchoolAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolAdminAggregateArgs>(args: Subset<T, SchoolAdminAggregateArgs>): Prisma.PrismaPromise<GetSchoolAdminAggregateType<T>>

    /**
     * Group by SchoolAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolAdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolAdminGroupByArgs['orderBy'] }
        : { orderBy?: SchoolAdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolAdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SchoolAdmin model
   */
  readonly fields: SchoolAdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SchoolAdmin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolAdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdSchoolAnnouncements<T extends SchoolAdmin$createdSchoolAnnouncementsArgs<ExtArgs> = {}>(args?: Subset<T, SchoolAdmin$createdSchoolAnnouncementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolAnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SchoolAdmin model
   */
  interface SchoolAdminFieldRefs {
    readonly id: FieldRef<"SchoolAdmin", 'String'>
    readonly userId: FieldRef<"SchoolAdmin", 'String'>
    readonly schoolId: FieldRef<"SchoolAdmin", 'String'>
    readonly jobTitle: FieldRef<"SchoolAdmin", 'String'>
    readonly createdAt: FieldRef<"SchoolAdmin", 'DateTime'>
    readonly updatedAt: FieldRef<"SchoolAdmin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SchoolAdmin findUnique
   */
  export type SchoolAdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAdmin
     */
    select?: SchoolAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAdmin
     */
    omit?: SchoolAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAdminInclude<ExtArgs> | null
    /**
     * Filter, which SchoolAdmin to fetch.
     */
    where: SchoolAdminWhereUniqueInput
  }

  /**
   * SchoolAdmin findUniqueOrThrow
   */
  export type SchoolAdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAdmin
     */
    select?: SchoolAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAdmin
     */
    omit?: SchoolAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAdminInclude<ExtArgs> | null
    /**
     * Filter, which SchoolAdmin to fetch.
     */
    where: SchoolAdminWhereUniqueInput
  }

  /**
   * SchoolAdmin findFirst
   */
  export type SchoolAdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAdmin
     */
    select?: SchoolAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAdmin
     */
    omit?: SchoolAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAdminInclude<ExtArgs> | null
    /**
     * Filter, which SchoolAdmin to fetch.
     */
    where?: SchoolAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolAdmins to fetch.
     */
    orderBy?: SchoolAdminOrderByWithRelationInput | SchoolAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolAdmins.
     */
    cursor?: SchoolAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolAdmins.
     */
    distinct?: SchoolAdminScalarFieldEnum | SchoolAdminScalarFieldEnum[]
  }

  /**
   * SchoolAdmin findFirstOrThrow
   */
  export type SchoolAdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAdmin
     */
    select?: SchoolAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAdmin
     */
    omit?: SchoolAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAdminInclude<ExtArgs> | null
    /**
     * Filter, which SchoolAdmin to fetch.
     */
    where?: SchoolAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolAdmins to fetch.
     */
    orderBy?: SchoolAdminOrderByWithRelationInput | SchoolAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolAdmins.
     */
    cursor?: SchoolAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolAdmins.
     */
    distinct?: SchoolAdminScalarFieldEnum | SchoolAdminScalarFieldEnum[]
  }

  /**
   * SchoolAdmin findMany
   */
  export type SchoolAdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAdmin
     */
    select?: SchoolAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAdmin
     */
    omit?: SchoolAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAdminInclude<ExtArgs> | null
    /**
     * Filter, which SchoolAdmins to fetch.
     */
    where?: SchoolAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolAdmins to fetch.
     */
    orderBy?: SchoolAdminOrderByWithRelationInput | SchoolAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SchoolAdmins.
     */
    cursor?: SchoolAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolAdmins.
     */
    skip?: number
    distinct?: SchoolAdminScalarFieldEnum | SchoolAdminScalarFieldEnum[]
  }

  /**
   * SchoolAdmin create
   */
  export type SchoolAdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAdmin
     */
    select?: SchoolAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAdmin
     */
    omit?: SchoolAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAdminInclude<ExtArgs> | null
    /**
     * The data needed to create a SchoolAdmin.
     */
    data: XOR<SchoolAdminCreateInput, SchoolAdminUncheckedCreateInput>
  }

  /**
   * SchoolAdmin createMany
   */
  export type SchoolAdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SchoolAdmins.
     */
    data: SchoolAdminCreateManyInput | SchoolAdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SchoolAdmin update
   */
  export type SchoolAdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAdmin
     */
    select?: SchoolAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAdmin
     */
    omit?: SchoolAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAdminInclude<ExtArgs> | null
    /**
     * The data needed to update a SchoolAdmin.
     */
    data: XOR<SchoolAdminUpdateInput, SchoolAdminUncheckedUpdateInput>
    /**
     * Choose, which SchoolAdmin to update.
     */
    where: SchoolAdminWhereUniqueInput
  }

  /**
   * SchoolAdmin updateMany
   */
  export type SchoolAdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SchoolAdmins.
     */
    data: XOR<SchoolAdminUpdateManyMutationInput, SchoolAdminUncheckedUpdateManyInput>
    /**
     * Filter which SchoolAdmins to update
     */
    where?: SchoolAdminWhereInput
    /**
     * Limit how many SchoolAdmins to update.
     */
    limit?: number
  }

  /**
   * SchoolAdmin upsert
   */
  export type SchoolAdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAdmin
     */
    select?: SchoolAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAdmin
     */
    omit?: SchoolAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAdminInclude<ExtArgs> | null
    /**
     * The filter to search for the SchoolAdmin to update in case it exists.
     */
    where: SchoolAdminWhereUniqueInput
    /**
     * In case the SchoolAdmin found by the `where` argument doesn't exist, create a new SchoolAdmin with this data.
     */
    create: XOR<SchoolAdminCreateInput, SchoolAdminUncheckedCreateInput>
    /**
     * In case the SchoolAdmin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolAdminUpdateInput, SchoolAdminUncheckedUpdateInput>
  }

  /**
   * SchoolAdmin delete
   */
  export type SchoolAdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAdmin
     */
    select?: SchoolAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAdmin
     */
    omit?: SchoolAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAdminInclude<ExtArgs> | null
    /**
     * Filter which SchoolAdmin to delete.
     */
    where: SchoolAdminWhereUniqueInput
  }

  /**
   * SchoolAdmin deleteMany
   */
  export type SchoolAdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolAdmins to delete
     */
    where?: SchoolAdminWhereInput
    /**
     * Limit how many SchoolAdmins to delete.
     */
    limit?: number
  }

  /**
   * SchoolAdmin.createdSchoolAnnouncements
   */
  export type SchoolAdmin$createdSchoolAnnouncementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAnnouncement
     */
    select?: SchoolAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAnnouncement
     */
    omit?: SchoolAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAnnouncementInclude<ExtArgs> | null
    where?: SchoolAnnouncementWhereInput
    orderBy?: SchoolAnnouncementOrderByWithRelationInput | SchoolAnnouncementOrderByWithRelationInput[]
    cursor?: SchoolAnnouncementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchoolAnnouncementScalarFieldEnum | SchoolAnnouncementScalarFieldEnum[]
  }

  /**
   * SchoolAdmin without action
   */
  export type SchoolAdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAdmin
     */
    select?: SchoolAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAdmin
     */
    omit?: SchoolAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAdminInclude<ExtArgs> | null
  }


  /**
   * Model Teacher
   */

  export type AggregateTeacher = {
    _count: TeacherCountAggregateOutputType | null
    _min: TeacherMinAggregateOutputType | null
    _max: TeacherMaxAggregateOutputType | null
  }

  export type TeacherMinAggregateOutputType = {
    id: string | null
    userId: string | null
    schoolId: string | null
    teacherIdNumber: string | null
    dateOfJoining: Date | null
    qualifications: string | null
    specialization: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeacherMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    schoolId: string | null
    teacherIdNumber: string | null
    dateOfJoining: Date | null
    qualifications: string | null
    specialization: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeacherCountAggregateOutputType = {
    id: number
    userId: number
    schoolId: number
    teacherIdNumber: number
    dateOfJoining: number
    qualifications: number
    specialization: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeacherMinAggregateInputType = {
    id?: true
    userId?: true
    schoolId?: true
    teacherIdNumber?: true
    dateOfJoining?: true
    qualifications?: true
    specialization?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeacherMaxAggregateInputType = {
    id?: true
    userId?: true
    schoolId?: true
    teacherIdNumber?: true
    dateOfJoining?: true
    qualifications?: true
    specialization?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeacherCountAggregateInputType = {
    id?: true
    userId?: true
    schoolId?: true
    teacherIdNumber?: true
    dateOfJoining?: true
    qualifications?: true
    specialization?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeacherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teacher to aggregate.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teachers
    **/
    _count?: true | TeacherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherMaxAggregateInputType
  }

  export type GetTeacherAggregateType<T extends TeacherAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacher[P]>
      : GetScalarType<T[P], AggregateTeacher[P]>
  }




  export type TeacherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherWhereInput
    orderBy?: TeacherOrderByWithAggregationInput | TeacherOrderByWithAggregationInput[]
    by: TeacherScalarFieldEnum[] | TeacherScalarFieldEnum
    having?: TeacherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherCountAggregateInputType | true
    _min?: TeacherMinAggregateInputType
    _max?: TeacherMaxAggregateInputType
  }

  export type TeacherGroupByOutputType = {
    id: string
    userId: string
    schoolId: string
    teacherIdNumber: string | null
    dateOfJoining: Date | null
    qualifications: string | null
    specialization: string | null
    createdAt: Date
    updatedAt: Date
    _count: TeacherCountAggregateOutputType | null
    _min: TeacherMinAggregateOutputType | null
    _max: TeacherMaxAggregateOutputType | null
  }

  type GetTeacherGroupByPayload<T extends TeacherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeacherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherGroupByOutputType[P]>
        }
      >
    >


  export type TeacherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    schoolId?: boolean
    teacherIdNumber?: boolean
    dateOfJoining?: boolean
    qualifications?: boolean
    specialization?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    classTeacherOf?: boolean | Teacher$classTeacherOfArgs<ExtArgs>
    timetableSlots?: boolean | Teacher$timetableSlotsArgs<ExtArgs>
    gradesGiven?: boolean | Teacher$gradesGivenArgs<ExtArgs>
    assignmentsCreated?: boolean | Teacher$assignmentsCreatedArgs<ExtArgs>
    createdClassAnnouncements?: boolean | Teacher$createdClassAnnouncementsArgs<ExtArgs>
    _count?: boolean | TeacherCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacher"]>



  export type TeacherSelectScalar = {
    id?: boolean
    userId?: boolean
    schoolId?: boolean
    teacherIdNumber?: boolean
    dateOfJoining?: boolean
    qualifications?: boolean
    specialization?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeacherOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "schoolId" | "teacherIdNumber" | "dateOfJoining" | "qualifications" | "specialization" | "createdAt" | "updatedAt", ExtArgs["result"]["teacher"]>
  export type TeacherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    classTeacherOf?: boolean | Teacher$classTeacherOfArgs<ExtArgs>
    timetableSlots?: boolean | Teacher$timetableSlotsArgs<ExtArgs>
    gradesGiven?: boolean | Teacher$gradesGivenArgs<ExtArgs>
    assignmentsCreated?: boolean | Teacher$assignmentsCreatedArgs<ExtArgs>
    createdClassAnnouncements?: boolean | Teacher$createdClassAnnouncementsArgs<ExtArgs>
    _count?: boolean | TeacherCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TeacherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Teacher"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      school: Prisma.$SchoolPayload<ExtArgs>
      classTeacherOf: Prisma.$ClassPayload<ExtArgs>[]
      timetableSlots: Prisma.$TimetableSlotPayload<ExtArgs>[]
      gradesGiven: Prisma.$StudentGradePayload<ExtArgs>[]
      assignmentsCreated: Prisma.$AssignmentPayload<ExtArgs>[]
      createdClassAnnouncements: Prisma.$ClassAnnouncementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      schoolId: string
      teacherIdNumber: string | null
      dateOfJoining: Date | null
      qualifications: string | null
      specialization: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["teacher"]>
    composites: {}
  }

  type TeacherGetPayload<S extends boolean | null | undefined | TeacherDefaultArgs> = $Result.GetResult<Prisma.$TeacherPayload, S>

  type TeacherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeacherFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeacherCountAggregateInputType | true
    }

  export interface TeacherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Teacher'], meta: { name: 'Teacher' } }
    /**
     * Find zero or one Teacher that matches the filter.
     * @param {TeacherFindUniqueArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeacherFindUniqueArgs>(args: SelectSubset<T, TeacherFindUniqueArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Teacher that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeacherFindUniqueOrThrowArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeacherFindUniqueOrThrowArgs>(args: SelectSubset<T, TeacherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teacher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindFirstArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeacherFindFirstArgs>(args?: SelectSubset<T, TeacherFindFirstArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teacher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindFirstOrThrowArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeacherFindFirstOrThrowArgs>(args?: SelectSubset<T, TeacherFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teachers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teachers
     * const teachers = await prisma.teacher.findMany()
     * 
     * // Get first 10 Teachers
     * const teachers = await prisma.teacher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherWithIdOnly = await prisma.teacher.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeacherFindManyArgs>(args?: SelectSubset<T, TeacherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Teacher.
     * @param {TeacherCreateArgs} args - Arguments to create a Teacher.
     * @example
     * // Create one Teacher
     * const Teacher = await prisma.teacher.create({
     *   data: {
     *     // ... data to create a Teacher
     *   }
     * })
     * 
     */
    create<T extends TeacherCreateArgs>(args: SelectSubset<T, TeacherCreateArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teachers.
     * @param {TeacherCreateManyArgs} args - Arguments to create many Teachers.
     * @example
     * // Create many Teachers
     * const teacher = await prisma.teacher.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeacherCreateManyArgs>(args?: SelectSubset<T, TeacherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Teacher.
     * @param {TeacherDeleteArgs} args - Arguments to delete one Teacher.
     * @example
     * // Delete one Teacher
     * const Teacher = await prisma.teacher.delete({
     *   where: {
     *     // ... filter to delete one Teacher
     *   }
     * })
     * 
     */
    delete<T extends TeacherDeleteArgs>(args: SelectSubset<T, TeacherDeleteArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Teacher.
     * @param {TeacherUpdateArgs} args - Arguments to update one Teacher.
     * @example
     * // Update one Teacher
     * const teacher = await prisma.teacher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeacherUpdateArgs>(args: SelectSubset<T, TeacherUpdateArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teachers.
     * @param {TeacherDeleteManyArgs} args - Arguments to filter Teachers to delete.
     * @example
     * // Delete a few Teachers
     * const { count } = await prisma.teacher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeacherDeleteManyArgs>(args?: SelectSubset<T, TeacherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teachers
     * const teacher = await prisma.teacher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeacherUpdateManyArgs>(args: SelectSubset<T, TeacherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Teacher.
     * @param {TeacherUpsertArgs} args - Arguments to update or create a Teacher.
     * @example
     * // Update or create a Teacher
     * const teacher = await prisma.teacher.upsert({
     *   create: {
     *     // ... data to create a Teacher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teacher we want to update
     *   }
     * })
     */
    upsert<T extends TeacherUpsertArgs>(args: SelectSubset<T, TeacherUpsertArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherCountArgs} args - Arguments to filter Teachers to count.
     * @example
     * // Count the number of Teachers
     * const count = await prisma.teacher.count({
     *   where: {
     *     // ... the filter for the Teachers we want to count
     *   }
     * })
    **/
    count<T extends TeacherCountArgs>(
      args?: Subset<T, TeacherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherAggregateArgs>(args: Subset<T, TeacherAggregateArgs>): Prisma.PrismaPromise<GetTeacherAggregateType<T>>

    /**
     * Group by Teacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherGroupByArgs['orderBy'] }
        : { orderBy?: TeacherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Teacher model
   */
  readonly fields: TeacherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Teacher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeacherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    classTeacherOf<T extends Teacher$classTeacherOfArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$classTeacherOfArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    timetableSlots<T extends Teacher$timetableSlotsArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$timetableSlotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimetableSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gradesGiven<T extends Teacher$gradesGivenArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$gradesGivenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentGradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignmentsCreated<T extends Teacher$assignmentsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$assignmentsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdClassAnnouncements<T extends Teacher$createdClassAnnouncementsArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$createdClassAnnouncementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassAnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Teacher model
   */
  interface TeacherFieldRefs {
    readonly id: FieldRef<"Teacher", 'String'>
    readonly userId: FieldRef<"Teacher", 'String'>
    readonly schoolId: FieldRef<"Teacher", 'String'>
    readonly teacherIdNumber: FieldRef<"Teacher", 'String'>
    readonly dateOfJoining: FieldRef<"Teacher", 'DateTime'>
    readonly qualifications: FieldRef<"Teacher", 'String'>
    readonly specialization: FieldRef<"Teacher", 'String'>
    readonly createdAt: FieldRef<"Teacher", 'DateTime'>
    readonly updatedAt: FieldRef<"Teacher", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Teacher findUnique
   */
  export type TeacherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher findUniqueOrThrow
   */
  export type TeacherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher findFirst
   */
  export type TeacherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachers.
     */
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Teacher findFirstOrThrow
   */
  export type TeacherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachers.
     */
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Teacher findMany
   */
  export type TeacherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teachers to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Teacher create
   */
  export type TeacherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The data needed to create a Teacher.
     */
    data: XOR<TeacherCreateInput, TeacherUncheckedCreateInput>
  }

  /**
   * Teacher createMany
   */
  export type TeacherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teachers.
     */
    data: TeacherCreateManyInput | TeacherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Teacher update
   */
  export type TeacherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The data needed to update a Teacher.
     */
    data: XOR<TeacherUpdateInput, TeacherUncheckedUpdateInput>
    /**
     * Choose, which Teacher to update.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher updateMany
   */
  export type TeacherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teachers.
     */
    data: XOR<TeacherUpdateManyMutationInput, TeacherUncheckedUpdateManyInput>
    /**
     * Filter which Teachers to update
     */
    where?: TeacherWhereInput
    /**
     * Limit how many Teachers to update.
     */
    limit?: number
  }

  /**
   * Teacher upsert
   */
  export type TeacherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The filter to search for the Teacher to update in case it exists.
     */
    where: TeacherWhereUniqueInput
    /**
     * In case the Teacher found by the `where` argument doesn't exist, create a new Teacher with this data.
     */
    create: XOR<TeacherCreateInput, TeacherUncheckedCreateInput>
    /**
     * In case the Teacher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherUpdateInput, TeacherUncheckedUpdateInput>
  }

  /**
   * Teacher delete
   */
  export type TeacherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter which Teacher to delete.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher deleteMany
   */
  export type TeacherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teachers to delete
     */
    where?: TeacherWhereInput
    /**
     * Limit how many Teachers to delete.
     */
    limit?: number
  }

  /**
   * Teacher.classTeacherOf
   */
  export type Teacher$classTeacherOfArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Teacher.timetableSlots
   */
  export type Teacher$timetableSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimetableSlot
     */
    select?: TimetableSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimetableSlot
     */
    omit?: TimetableSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableSlotInclude<ExtArgs> | null
    where?: TimetableSlotWhereInput
    orderBy?: TimetableSlotOrderByWithRelationInput | TimetableSlotOrderByWithRelationInput[]
    cursor?: TimetableSlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimetableSlotScalarFieldEnum | TimetableSlotScalarFieldEnum[]
  }

  /**
   * Teacher.gradesGiven
   */
  export type Teacher$gradesGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentGrade
     */
    select?: StudentGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentGrade
     */
    omit?: StudentGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentGradeInclude<ExtArgs> | null
    where?: StudentGradeWhereInput
    orderBy?: StudentGradeOrderByWithRelationInput | StudentGradeOrderByWithRelationInput[]
    cursor?: StudentGradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentGradeScalarFieldEnum | StudentGradeScalarFieldEnum[]
  }

  /**
   * Teacher.assignmentsCreated
   */
  export type Teacher$assignmentsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    cursor?: AssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Teacher.createdClassAnnouncements
   */
  export type Teacher$createdClassAnnouncementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassAnnouncement
     */
    select?: ClassAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassAnnouncement
     */
    omit?: ClassAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassAnnouncementInclude<ExtArgs> | null
    where?: ClassAnnouncementWhereInput
    orderBy?: ClassAnnouncementOrderByWithRelationInput | ClassAnnouncementOrderByWithRelationInput[]
    cursor?: ClassAnnouncementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassAnnouncementScalarFieldEnum | ClassAnnouncementScalarFieldEnum[]
  }

  /**
   * Teacher without action
   */
  export type TeacherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
  }


  /**
   * Model Student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    schoolId: string | null
    studentIdNumber: string | null
    firstName: string | null
    lastName: string | null
    middleName: string | null
    dateOfBirth: Date | null
    gender: $Enums.Gender | null
    enrollmentDate: Date | null
    profilePictureUrl: string | null
    address: string | null
    city: string | null
    stateOrRegion: string | null
    country: string | null
    postalCode: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    bloodGroup: string | null
    allergies: string | null
    medicalNotes: string | null
    isActive: boolean | null
    currentClassId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    schoolId: string | null
    studentIdNumber: string | null
    firstName: string | null
    lastName: string | null
    middleName: string | null
    dateOfBirth: Date | null
    gender: $Enums.Gender | null
    enrollmentDate: Date | null
    profilePictureUrl: string | null
    address: string | null
    city: string | null
    stateOrRegion: string | null
    country: string | null
    postalCode: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    bloodGroup: string | null
    allergies: string | null
    medicalNotes: string | null
    isActive: boolean | null
    currentClassId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    userId: number
    schoolId: number
    studentIdNumber: number
    firstName: number
    lastName: number
    middleName: number
    dateOfBirth: number
    gender: number
    enrollmentDate: number
    profilePictureUrl: number
    address: number
    city: number
    stateOrRegion: number
    country: number
    postalCode: number
    emergencyContactName: number
    emergencyContactPhone: number
    bloodGroup: number
    allergies: number
    medicalNotes: number
    isActive: number
    currentClassId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentMinAggregateInputType = {
    id?: true
    userId?: true
    schoolId?: true
    studentIdNumber?: true
    firstName?: true
    lastName?: true
    middleName?: true
    dateOfBirth?: true
    gender?: true
    enrollmentDate?: true
    profilePictureUrl?: true
    address?: true
    city?: true
    stateOrRegion?: true
    country?: true
    postalCode?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    bloodGroup?: true
    allergies?: true
    medicalNotes?: true
    isActive?: true
    currentClassId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    userId?: true
    schoolId?: true
    studentIdNumber?: true
    firstName?: true
    lastName?: true
    middleName?: true
    dateOfBirth?: true
    gender?: true
    enrollmentDate?: true
    profilePictureUrl?: true
    address?: true
    city?: true
    stateOrRegion?: true
    country?: true
    postalCode?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    bloodGroup?: true
    allergies?: true
    medicalNotes?: true
    isActive?: true
    currentClassId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    userId?: true
    schoolId?: true
    studentIdNumber?: true
    firstName?: true
    lastName?: true
    middleName?: true
    dateOfBirth?: true
    gender?: true
    enrollmentDate?: true
    profilePictureUrl?: true
    address?: true
    city?: true
    stateOrRegion?: true
    country?: true
    postalCode?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    bloodGroup?: true
    allergies?: true
    medicalNotes?: true
    isActive?: true
    currentClassId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithAggregationInput | StudentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    id: string
    userId: string | null
    schoolId: string
    studentIdNumber: string
    firstName: string
    lastName: string
    middleName: string | null
    dateOfBirth: Date
    gender: $Enums.Gender
    enrollmentDate: Date
    profilePictureUrl: string | null
    address: string | null
    city: string | null
    stateOrRegion: string | null
    country: string | null
    postalCode: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    bloodGroup: string | null
    allergies: string | null
    medicalNotes: string | null
    isActive: boolean
    currentClassId: string | null
    createdAt: Date
    updatedAt: Date
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    schoolId?: boolean
    studentIdNumber?: boolean
    firstName?: boolean
    lastName?: boolean
    middleName?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    enrollmentDate?: boolean
    profilePictureUrl?: boolean
    address?: boolean
    city?: boolean
    stateOrRegion?: boolean
    country?: boolean
    postalCode?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    bloodGroup?: boolean
    allergies?: boolean
    medicalNotes?: boolean
    isActive?: boolean
    currentClassId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Student$userArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    currentClass?: boolean | Student$currentClassArgs<ExtArgs>
    parents?: boolean | Student$parentsArgs<ExtArgs>
    enrollments?: boolean | Student$enrollmentsArgs<ExtArgs>
    attendances?: boolean | Student$attendancesArgs<ExtArgs>
    grades?: boolean | Student$gradesArgs<ExtArgs>
    invoiceLineItems?: boolean | Student$invoiceLineItemsArgs<ExtArgs>
    invoices?: boolean | Student$invoicesArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>



  export type StudentSelectScalar = {
    id?: boolean
    userId?: boolean
    schoolId?: boolean
    studentIdNumber?: boolean
    firstName?: boolean
    lastName?: boolean
    middleName?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    enrollmentDate?: boolean
    profilePictureUrl?: boolean
    address?: boolean
    city?: boolean
    stateOrRegion?: boolean
    country?: boolean
    postalCode?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    bloodGroup?: boolean
    allergies?: boolean
    medicalNotes?: boolean
    isActive?: boolean
    currentClassId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "schoolId" | "studentIdNumber" | "firstName" | "lastName" | "middleName" | "dateOfBirth" | "gender" | "enrollmentDate" | "profilePictureUrl" | "address" | "city" | "stateOrRegion" | "country" | "postalCode" | "emergencyContactName" | "emergencyContactPhone" | "bloodGroup" | "allergies" | "medicalNotes" | "isActive" | "currentClassId" | "createdAt" | "updatedAt", ExtArgs["result"]["student"]>
  export type StudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Student$userArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    currentClass?: boolean | Student$currentClassArgs<ExtArgs>
    parents?: boolean | Student$parentsArgs<ExtArgs>
    enrollments?: boolean | Student$enrollmentsArgs<ExtArgs>
    attendances?: boolean | Student$attendancesArgs<ExtArgs>
    grades?: boolean | Student$gradesArgs<ExtArgs>
    invoiceLineItems?: boolean | Student$invoiceLineItemsArgs<ExtArgs>
    invoices?: boolean | Student$invoicesArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $StudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Student"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      school: Prisma.$SchoolPayload<ExtArgs>
      currentClass: Prisma.$ClassPayload<ExtArgs> | null
      parents: Prisma.$StudentParentLinkPayload<ExtArgs>[]
      enrollments: Prisma.$StudentClassEnrollmentPayload<ExtArgs>[]
      attendances: Prisma.$StudentAttendancePayload<ExtArgs>[]
      grades: Prisma.$StudentGradePayload<ExtArgs>[]
      invoiceLineItems: Prisma.$InvoiceLineItemPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      schoolId: string
      studentIdNumber: string
      firstName: string
      lastName: string
      middleName: string | null
      dateOfBirth: Date
      gender: $Enums.Gender
      enrollmentDate: Date
      profilePictureUrl: string | null
      address: string | null
      city: string | null
      stateOrRegion: string | null
      country: string | null
      postalCode: string | null
      emergencyContactName: string | null
      emergencyContactPhone: string | null
      bloodGroup: string | null
      allergies: string | null
      medicalNotes: string | null
      isActive: boolean
      currentClassId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["student"]>
    composites: {}
  }

  type StudentGetPayload<S extends boolean | null | undefined | StudentDefaultArgs> = $Result.GetResult<Prisma.$StudentPayload, S>

  type StudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Student'], meta: { name: 'Student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentFindUniqueArgs>(args: SelectSubset<T, StudentFindUniqueArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentFindFirstArgs>(args?: SelectSubset<T, StudentFindFirstArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentFindManyArgs>(args?: SelectSubset<T, StudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
     */
    create<T extends StudentCreateArgs>(args: SelectSubset<T, StudentCreateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Students.
     * @param {StudentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentCreateManyArgs>(args?: SelectSubset<T, StudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
     */
    delete<T extends StudentDeleteArgs>(args: SelectSubset<T, StudentDeleteArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentUpdateArgs>(args: SelectSubset<T, StudentUpdateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentDeleteManyArgs>(args?: SelectSubset<T, StudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentUpdateManyArgs>(args: SelectSubset<T, StudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends StudentUpsertArgs>(args: SelectSubset<T, StudentUpsertArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Student model
   */
  readonly fields: StudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Student$userArgs<ExtArgs> = {}>(args?: Subset<T, Student$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    currentClass<T extends Student$currentClassArgs<ExtArgs> = {}>(args?: Subset<T, Student$currentClassArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    parents<T extends Student$parentsArgs<ExtArgs> = {}>(args?: Subset<T, Student$parentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentParentLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enrollments<T extends Student$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Student$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentClassEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendances<T extends Student$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, Student$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    grades<T extends Student$gradesArgs<ExtArgs> = {}>(args?: Subset<T, Student$gradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentGradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoiceLineItems<T extends Student$invoiceLineItemsArgs<ExtArgs> = {}>(args?: Subset<T, Student$invoiceLineItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLineItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends Student$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Student$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Student model
   */
  interface StudentFieldRefs {
    readonly id: FieldRef<"Student", 'String'>
    readonly userId: FieldRef<"Student", 'String'>
    readonly schoolId: FieldRef<"Student", 'String'>
    readonly studentIdNumber: FieldRef<"Student", 'String'>
    readonly firstName: FieldRef<"Student", 'String'>
    readonly lastName: FieldRef<"Student", 'String'>
    readonly middleName: FieldRef<"Student", 'String'>
    readonly dateOfBirth: FieldRef<"Student", 'DateTime'>
    readonly gender: FieldRef<"Student", 'Gender'>
    readonly enrollmentDate: FieldRef<"Student", 'DateTime'>
    readonly profilePictureUrl: FieldRef<"Student", 'String'>
    readonly address: FieldRef<"Student", 'String'>
    readonly city: FieldRef<"Student", 'String'>
    readonly stateOrRegion: FieldRef<"Student", 'String'>
    readonly country: FieldRef<"Student", 'String'>
    readonly postalCode: FieldRef<"Student", 'String'>
    readonly emergencyContactName: FieldRef<"Student", 'String'>
    readonly emergencyContactPhone: FieldRef<"Student", 'String'>
    readonly bloodGroup: FieldRef<"Student", 'String'>
    readonly allergies: FieldRef<"Student", 'String'>
    readonly medicalNotes: FieldRef<"Student", 'String'>
    readonly isActive: FieldRef<"Student", 'Boolean'>
    readonly currentClassId: FieldRef<"Student", 'String'>
    readonly createdAt: FieldRef<"Student", 'DateTime'>
    readonly updatedAt: FieldRef<"Student", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findMany
   */
  export type StudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student create
   */
  export type StudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }

  /**
   * Student createMany
   */
  export type StudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Student update
   */
  export type StudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
  }

  /**
   * Student upsert
   */
  export type StudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }

  /**
   * Student delete
   */
  export type StudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to delete.
     */
    limit?: number
  }

  /**
   * Student.user
   */
  export type Student$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Student.currentClass
   */
  export type Student$currentClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
  }

  /**
   * Student.parents
   */
  export type Student$parentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParentLink
     */
    select?: StudentParentLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParentLink
     */
    omit?: StudentParentLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentLinkInclude<ExtArgs> | null
    where?: StudentParentLinkWhereInput
    orderBy?: StudentParentLinkOrderByWithRelationInput | StudentParentLinkOrderByWithRelationInput[]
    cursor?: StudentParentLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentParentLinkScalarFieldEnum | StudentParentLinkScalarFieldEnum[]
  }

  /**
   * Student.enrollments
   */
  export type Student$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentClassEnrollment
     */
    select?: StudentClassEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentClassEnrollment
     */
    omit?: StudentClassEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentClassEnrollmentInclude<ExtArgs> | null
    where?: StudentClassEnrollmentWhereInput
    orderBy?: StudentClassEnrollmentOrderByWithRelationInput | StudentClassEnrollmentOrderByWithRelationInput[]
    cursor?: StudentClassEnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentClassEnrollmentScalarFieldEnum | StudentClassEnrollmentScalarFieldEnum[]
  }

  /**
   * Student.attendances
   */
  export type Student$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    where?: StudentAttendanceWhereInput
    orderBy?: StudentAttendanceOrderByWithRelationInput | StudentAttendanceOrderByWithRelationInput[]
    cursor?: StudentAttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentAttendanceScalarFieldEnum | StudentAttendanceScalarFieldEnum[]
  }

  /**
   * Student.grades
   */
  export type Student$gradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentGrade
     */
    select?: StudentGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentGrade
     */
    omit?: StudentGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentGradeInclude<ExtArgs> | null
    where?: StudentGradeWhereInput
    orderBy?: StudentGradeOrderByWithRelationInput | StudentGradeOrderByWithRelationInput[]
    cursor?: StudentGradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentGradeScalarFieldEnum | StudentGradeScalarFieldEnum[]
  }

  /**
   * Student.invoiceLineItems
   */
  export type Student$invoiceLineItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLineItem
     */
    omit?: InvoiceLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineItemInclude<ExtArgs> | null
    where?: InvoiceLineItemWhereInput
    orderBy?: InvoiceLineItemOrderByWithRelationInput | InvoiceLineItemOrderByWithRelationInput[]
    cursor?: InvoiceLineItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceLineItemScalarFieldEnum | InvoiceLineItemScalarFieldEnum[]
  }

  /**
   * Student.invoices
   */
  export type Student$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Student without action
   */
  export type StudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
  }


  /**
   * Model Parent
   */

  export type AggregateParent = {
    _count: ParentCountAggregateOutputType | null
    _min: ParentMinAggregateOutputType | null
    _max: ParentMaxAggregateOutputType | null
  }

  export type ParentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    occupation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    occupation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParentCountAggregateOutputType = {
    id: number
    userId: number
    occupation: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ParentMinAggregateInputType = {
    id?: true
    userId?: true
    occupation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParentMaxAggregateInputType = {
    id?: true
    userId?: true
    occupation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParentCountAggregateInputType = {
    id?: true
    userId?: true
    occupation?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ParentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parent to aggregate.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Parents
    **/
    _count?: true | ParentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParentMaxAggregateInputType
  }

  export type GetParentAggregateType<T extends ParentAggregateArgs> = {
        [P in keyof T & keyof AggregateParent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParent[P]>
      : GetScalarType<T[P], AggregateParent[P]>
  }




  export type ParentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParentWhereInput
    orderBy?: ParentOrderByWithAggregationInput | ParentOrderByWithAggregationInput[]
    by: ParentScalarFieldEnum[] | ParentScalarFieldEnum
    having?: ParentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParentCountAggregateInputType | true
    _min?: ParentMinAggregateInputType
    _max?: ParentMaxAggregateInputType
  }

  export type ParentGroupByOutputType = {
    id: string
    userId: string
    occupation: string | null
    createdAt: Date
    updatedAt: Date
    _count: ParentCountAggregateOutputType | null
    _min: ParentMinAggregateOutputType | null
    _max: ParentMaxAggregateOutputType | null
  }

  type GetParentGroupByPayload<T extends ParentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParentGroupByOutputType[P]>
            : GetScalarType<T[P], ParentGroupByOutputType[P]>
        }
      >
    >


  export type ParentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    occupation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    children?: boolean | Parent$childrenArgs<ExtArgs>
    invoices?: boolean | Parent$invoicesArgs<ExtArgs>
    _count?: boolean | ParentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parent"]>



  export type ParentSelectScalar = {
    id?: boolean
    userId?: boolean
    occupation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ParentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "occupation" | "createdAt" | "updatedAt", ExtArgs["result"]["parent"]>
  export type ParentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    children?: boolean | Parent$childrenArgs<ExtArgs>
    invoices?: boolean | Parent$invoicesArgs<ExtArgs>
    _count?: boolean | ParentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ParentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Parent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      children: Prisma.$StudentParentLinkPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      occupation: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["parent"]>
    composites: {}
  }

  type ParentGetPayload<S extends boolean | null | undefined | ParentDefaultArgs> = $Result.GetResult<Prisma.$ParentPayload, S>

  type ParentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParentCountAggregateInputType | true
    }

  export interface ParentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Parent'], meta: { name: 'Parent' } }
    /**
     * Find zero or one Parent that matches the filter.
     * @param {ParentFindUniqueArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParentFindUniqueArgs>(args: SelectSubset<T, ParentFindUniqueArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Parent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParentFindUniqueOrThrowArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParentFindUniqueOrThrowArgs>(args: SelectSubset<T, ParentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentFindFirstArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParentFindFirstArgs>(args?: SelectSubset<T, ParentFindFirstArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentFindFirstOrThrowArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParentFindFirstOrThrowArgs>(args?: SelectSubset<T, ParentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Parents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parents
     * const parents = await prisma.parent.findMany()
     * 
     * // Get first 10 Parents
     * const parents = await prisma.parent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parentWithIdOnly = await prisma.parent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParentFindManyArgs>(args?: SelectSubset<T, ParentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Parent.
     * @param {ParentCreateArgs} args - Arguments to create a Parent.
     * @example
     * // Create one Parent
     * const Parent = await prisma.parent.create({
     *   data: {
     *     // ... data to create a Parent
     *   }
     * })
     * 
     */
    create<T extends ParentCreateArgs>(args: SelectSubset<T, ParentCreateArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Parents.
     * @param {ParentCreateManyArgs} args - Arguments to create many Parents.
     * @example
     * // Create many Parents
     * const parent = await prisma.parent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParentCreateManyArgs>(args?: SelectSubset<T, ParentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Parent.
     * @param {ParentDeleteArgs} args - Arguments to delete one Parent.
     * @example
     * // Delete one Parent
     * const Parent = await prisma.parent.delete({
     *   where: {
     *     // ... filter to delete one Parent
     *   }
     * })
     * 
     */
    delete<T extends ParentDeleteArgs>(args: SelectSubset<T, ParentDeleteArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Parent.
     * @param {ParentUpdateArgs} args - Arguments to update one Parent.
     * @example
     * // Update one Parent
     * const parent = await prisma.parent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParentUpdateArgs>(args: SelectSubset<T, ParentUpdateArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Parents.
     * @param {ParentDeleteManyArgs} args - Arguments to filter Parents to delete.
     * @example
     * // Delete a few Parents
     * const { count } = await prisma.parent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParentDeleteManyArgs>(args?: SelectSubset<T, ParentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parents
     * const parent = await prisma.parent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParentUpdateManyArgs>(args: SelectSubset<T, ParentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Parent.
     * @param {ParentUpsertArgs} args - Arguments to update or create a Parent.
     * @example
     * // Update or create a Parent
     * const parent = await prisma.parent.upsert({
     *   create: {
     *     // ... data to create a Parent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parent we want to update
     *   }
     * })
     */
    upsert<T extends ParentUpsertArgs>(args: SelectSubset<T, ParentUpsertArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentCountArgs} args - Arguments to filter Parents to count.
     * @example
     * // Count the number of Parents
     * const count = await prisma.parent.count({
     *   where: {
     *     // ... the filter for the Parents we want to count
     *   }
     * })
    **/
    count<T extends ParentCountArgs>(
      args?: Subset<T, ParentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParentAggregateArgs>(args: Subset<T, ParentAggregateArgs>): Prisma.PrismaPromise<GetParentAggregateType<T>>

    /**
     * Group by Parent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParentGroupByArgs['orderBy'] }
        : { orderBy?: ParentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Parent model
   */
  readonly fields: ParentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Parent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    children<T extends Parent$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Parent$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentParentLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends Parent$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Parent$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Parent model
   */
  interface ParentFieldRefs {
    readonly id: FieldRef<"Parent", 'String'>
    readonly userId: FieldRef<"Parent", 'String'>
    readonly occupation: FieldRef<"Parent", 'String'>
    readonly createdAt: FieldRef<"Parent", 'DateTime'>
    readonly updatedAt: FieldRef<"Parent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Parent findUnique
   */
  export type ParentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent findUniqueOrThrow
   */
  export type ParentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent findFirst
   */
  export type ParentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parents.
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parents.
     */
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Parent findFirstOrThrow
   */
  export type ParentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parents.
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parents.
     */
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Parent findMany
   */
  export type ParentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parents to fetch.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Parents.
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Parent create
   */
  export type ParentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * The data needed to create a Parent.
     */
    data: XOR<ParentCreateInput, ParentUncheckedCreateInput>
  }

  /**
   * Parent createMany
   */
  export type ParentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Parents.
     */
    data: ParentCreateManyInput | ParentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Parent update
   */
  export type ParentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * The data needed to update a Parent.
     */
    data: XOR<ParentUpdateInput, ParentUncheckedUpdateInput>
    /**
     * Choose, which Parent to update.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent updateMany
   */
  export type ParentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Parents.
     */
    data: XOR<ParentUpdateManyMutationInput, ParentUncheckedUpdateManyInput>
    /**
     * Filter which Parents to update
     */
    where?: ParentWhereInput
    /**
     * Limit how many Parents to update.
     */
    limit?: number
  }

  /**
   * Parent upsert
   */
  export type ParentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * The filter to search for the Parent to update in case it exists.
     */
    where: ParentWhereUniqueInput
    /**
     * In case the Parent found by the `where` argument doesn't exist, create a new Parent with this data.
     */
    create: XOR<ParentCreateInput, ParentUncheckedCreateInput>
    /**
     * In case the Parent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParentUpdateInput, ParentUncheckedUpdateInput>
  }

  /**
   * Parent delete
   */
  export type ParentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter which Parent to delete.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent deleteMany
   */
  export type ParentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parents to delete
     */
    where?: ParentWhereInput
    /**
     * Limit how many Parents to delete.
     */
    limit?: number
  }

  /**
   * Parent.children
   */
  export type Parent$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParentLink
     */
    select?: StudentParentLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParentLink
     */
    omit?: StudentParentLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentLinkInclude<ExtArgs> | null
    where?: StudentParentLinkWhereInput
    orderBy?: StudentParentLinkOrderByWithRelationInput | StudentParentLinkOrderByWithRelationInput[]
    cursor?: StudentParentLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentParentLinkScalarFieldEnum | StudentParentLinkScalarFieldEnum[]
  }

  /**
   * Parent.invoices
   */
  export type Parent$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Parent without action
   */
  export type ParentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
  }


  /**
   * Model StudentParentLink
   */

  export type AggregateStudentParentLink = {
    _count: StudentParentLinkCountAggregateOutputType | null
    _min: StudentParentLinkMinAggregateOutputType | null
    _max: StudentParentLinkMaxAggregateOutputType | null
  }

  export type StudentParentLinkMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    parentId: string | null
    relationshipToStudent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentParentLinkMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    parentId: string | null
    relationshipToStudent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentParentLinkCountAggregateOutputType = {
    id: number
    studentId: number
    parentId: number
    relationshipToStudent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentParentLinkMinAggregateInputType = {
    id?: true
    studentId?: true
    parentId?: true
    relationshipToStudent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentParentLinkMaxAggregateInputType = {
    id?: true
    studentId?: true
    parentId?: true
    relationshipToStudent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentParentLinkCountAggregateInputType = {
    id?: true
    studentId?: true
    parentId?: true
    relationshipToStudent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentParentLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentParentLink to aggregate.
     */
    where?: StudentParentLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentParentLinks to fetch.
     */
    orderBy?: StudentParentLinkOrderByWithRelationInput | StudentParentLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentParentLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentParentLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentParentLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentParentLinks
    **/
    _count?: true | StudentParentLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentParentLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentParentLinkMaxAggregateInputType
  }

  export type GetStudentParentLinkAggregateType<T extends StudentParentLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentParentLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentParentLink[P]>
      : GetScalarType<T[P], AggregateStudentParentLink[P]>
  }




  export type StudentParentLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentParentLinkWhereInput
    orderBy?: StudentParentLinkOrderByWithAggregationInput | StudentParentLinkOrderByWithAggregationInput[]
    by: StudentParentLinkScalarFieldEnum[] | StudentParentLinkScalarFieldEnum
    having?: StudentParentLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentParentLinkCountAggregateInputType | true
    _min?: StudentParentLinkMinAggregateInputType
    _max?: StudentParentLinkMaxAggregateInputType
  }

  export type StudentParentLinkGroupByOutputType = {
    id: string
    studentId: string
    parentId: string
    relationshipToStudent: string
    createdAt: Date
    updatedAt: Date
    _count: StudentParentLinkCountAggregateOutputType | null
    _min: StudentParentLinkMinAggregateOutputType | null
    _max: StudentParentLinkMaxAggregateOutputType | null
  }

  type GetStudentParentLinkGroupByPayload<T extends StudentParentLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentParentLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentParentLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentParentLinkGroupByOutputType[P]>
            : GetScalarType<T[P], StudentParentLinkGroupByOutputType[P]>
        }
      >
    >


  export type StudentParentLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    parentId?: boolean
    relationshipToStudent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    parent?: boolean | ParentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentParentLink"]>



  export type StudentParentLinkSelectScalar = {
    id?: boolean
    studentId?: boolean
    parentId?: boolean
    relationshipToStudent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentParentLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "parentId" | "relationshipToStudent" | "createdAt" | "updatedAt", ExtArgs["result"]["studentParentLink"]>
  export type StudentParentLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    parent?: boolean | ParentDefaultArgs<ExtArgs>
  }

  export type $StudentParentLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentParentLink"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      parent: Prisma.$ParentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      parentId: string
      relationshipToStudent: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studentParentLink"]>
    composites: {}
  }

  type StudentParentLinkGetPayload<S extends boolean | null | undefined | StudentParentLinkDefaultArgs> = $Result.GetResult<Prisma.$StudentParentLinkPayload, S>

  type StudentParentLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentParentLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentParentLinkCountAggregateInputType | true
    }

  export interface StudentParentLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentParentLink'], meta: { name: 'StudentParentLink' } }
    /**
     * Find zero or one StudentParentLink that matches the filter.
     * @param {StudentParentLinkFindUniqueArgs} args - Arguments to find a StudentParentLink
     * @example
     * // Get one StudentParentLink
     * const studentParentLink = await prisma.studentParentLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentParentLinkFindUniqueArgs>(args: SelectSubset<T, StudentParentLinkFindUniqueArgs<ExtArgs>>): Prisma__StudentParentLinkClient<$Result.GetResult<Prisma.$StudentParentLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentParentLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentParentLinkFindUniqueOrThrowArgs} args - Arguments to find a StudentParentLink
     * @example
     * // Get one StudentParentLink
     * const studentParentLink = await prisma.studentParentLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentParentLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentParentLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentParentLinkClient<$Result.GetResult<Prisma.$StudentParentLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentParentLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentLinkFindFirstArgs} args - Arguments to find a StudentParentLink
     * @example
     * // Get one StudentParentLink
     * const studentParentLink = await prisma.studentParentLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentParentLinkFindFirstArgs>(args?: SelectSubset<T, StudentParentLinkFindFirstArgs<ExtArgs>>): Prisma__StudentParentLinkClient<$Result.GetResult<Prisma.$StudentParentLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentParentLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentLinkFindFirstOrThrowArgs} args - Arguments to find a StudentParentLink
     * @example
     * // Get one StudentParentLink
     * const studentParentLink = await prisma.studentParentLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentParentLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentParentLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentParentLinkClient<$Result.GetResult<Prisma.$StudentParentLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentParentLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentParentLinks
     * const studentParentLinks = await prisma.studentParentLink.findMany()
     * 
     * // Get first 10 StudentParentLinks
     * const studentParentLinks = await prisma.studentParentLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentParentLinkWithIdOnly = await prisma.studentParentLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentParentLinkFindManyArgs>(args?: SelectSubset<T, StudentParentLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentParentLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentParentLink.
     * @param {StudentParentLinkCreateArgs} args - Arguments to create a StudentParentLink.
     * @example
     * // Create one StudentParentLink
     * const StudentParentLink = await prisma.studentParentLink.create({
     *   data: {
     *     // ... data to create a StudentParentLink
     *   }
     * })
     * 
     */
    create<T extends StudentParentLinkCreateArgs>(args: SelectSubset<T, StudentParentLinkCreateArgs<ExtArgs>>): Prisma__StudentParentLinkClient<$Result.GetResult<Prisma.$StudentParentLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentParentLinks.
     * @param {StudentParentLinkCreateManyArgs} args - Arguments to create many StudentParentLinks.
     * @example
     * // Create many StudentParentLinks
     * const studentParentLink = await prisma.studentParentLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentParentLinkCreateManyArgs>(args?: SelectSubset<T, StudentParentLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StudentParentLink.
     * @param {StudentParentLinkDeleteArgs} args - Arguments to delete one StudentParentLink.
     * @example
     * // Delete one StudentParentLink
     * const StudentParentLink = await prisma.studentParentLink.delete({
     *   where: {
     *     // ... filter to delete one StudentParentLink
     *   }
     * })
     * 
     */
    delete<T extends StudentParentLinkDeleteArgs>(args: SelectSubset<T, StudentParentLinkDeleteArgs<ExtArgs>>): Prisma__StudentParentLinkClient<$Result.GetResult<Prisma.$StudentParentLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentParentLink.
     * @param {StudentParentLinkUpdateArgs} args - Arguments to update one StudentParentLink.
     * @example
     * // Update one StudentParentLink
     * const studentParentLink = await prisma.studentParentLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentParentLinkUpdateArgs>(args: SelectSubset<T, StudentParentLinkUpdateArgs<ExtArgs>>): Prisma__StudentParentLinkClient<$Result.GetResult<Prisma.$StudentParentLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentParentLinks.
     * @param {StudentParentLinkDeleteManyArgs} args - Arguments to filter StudentParentLinks to delete.
     * @example
     * // Delete a few StudentParentLinks
     * const { count } = await prisma.studentParentLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentParentLinkDeleteManyArgs>(args?: SelectSubset<T, StudentParentLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentParentLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentParentLinks
     * const studentParentLink = await prisma.studentParentLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentParentLinkUpdateManyArgs>(args: SelectSubset<T, StudentParentLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentParentLink.
     * @param {StudentParentLinkUpsertArgs} args - Arguments to update or create a StudentParentLink.
     * @example
     * // Update or create a StudentParentLink
     * const studentParentLink = await prisma.studentParentLink.upsert({
     *   create: {
     *     // ... data to create a StudentParentLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentParentLink we want to update
     *   }
     * })
     */
    upsert<T extends StudentParentLinkUpsertArgs>(args: SelectSubset<T, StudentParentLinkUpsertArgs<ExtArgs>>): Prisma__StudentParentLinkClient<$Result.GetResult<Prisma.$StudentParentLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentParentLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentLinkCountArgs} args - Arguments to filter StudentParentLinks to count.
     * @example
     * // Count the number of StudentParentLinks
     * const count = await prisma.studentParentLink.count({
     *   where: {
     *     // ... the filter for the StudentParentLinks we want to count
     *   }
     * })
    **/
    count<T extends StudentParentLinkCountArgs>(
      args?: Subset<T, StudentParentLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentParentLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentParentLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentParentLinkAggregateArgs>(args: Subset<T, StudentParentLinkAggregateArgs>): Prisma.PrismaPromise<GetStudentParentLinkAggregateType<T>>

    /**
     * Group by StudentParentLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentParentLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentParentLinkGroupByArgs['orderBy'] }
        : { orderBy?: StudentParentLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentParentLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentParentLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentParentLink model
   */
  readonly fields: StudentParentLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentParentLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentParentLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends ParentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParentDefaultArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentParentLink model
   */
  interface StudentParentLinkFieldRefs {
    readonly id: FieldRef<"StudentParentLink", 'String'>
    readonly studentId: FieldRef<"StudentParentLink", 'String'>
    readonly parentId: FieldRef<"StudentParentLink", 'String'>
    readonly relationshipToStudent: FieldRef<"StudentParentLink", 'String'>
    readonly createdAt: FieldRef<"StudentParentLink", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentParentLink", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentParentLink findUnique
   */
  export type StudentParentLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParentLink
     */
    select?: StudentParentLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParentLink
     */
    omit?: StudentParentLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentLinkInclude<ExtArgs> | null
    /**
     * Filter, which StudentParentLink to fetch.
     */
    where: StudentParentLinkWhereUniqueInput
  }

  /**
   * StudentParentLink findUniqueOrThrow
   */
  export type StudentParentLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParentLink
     */
    select?: StudentParentLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParentLink
     */
    omit?: StudentParentLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentLinkInclude<ExtArgs> | null
    /**
     * Filter, which StudentParentLink to fetch.
     */
    where: StudentParentLinkWhereUniqueInput
  }

  /**
   * StudentParentLink findFirst
   */
  export type StudentParentLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParentLink
     */
    select?: StudentParentLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParentLink
     */
    omit?: StudentParentLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentLinkInclude<ExtArgs> | null
    /**
     * Filter, which StudentParentLink to fetch.
     */
    where?: StudentParentLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentParentLinks to fetch.
     */
    orderBy?: StudentParentLinkOrderByWithRelationInput | StudentParentLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentParentLinks.
     */
    cursor?: StudentParentLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentParentLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentParentLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentParentLinks.
     */
    distinct?: StudentParentLinkScalarFieldEnum | StudentParentLinkScalarFieldEnum[]
  }

  /**
   * StudentParentLink findFirstOrThrow
   */
  export type StudentParentLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParentLink
     */
    select?: StudentParentLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParentLink
     */
    omit?: StudentParentLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentLinkInclude<ExtArgs> | null
    /**
     * Filter, which StudentParentLink to fetch.
     */
    where?: StudentParentLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentParentLinks to fetch.
     */
    orderBy?: StudentParentLinkOrderByWithRelationInput | StudentParentLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentParentLinks.
     */
    cursor?: StudentParentLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentParentLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentParentLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentParentLinks.
     */
    distinct?: StudentParentLinkScalarFieldEnum | StudentParentLinkScalarFieldEnum[]
  }

  /**
   * StudentParentLink findMany
   */
  export type StudentParentLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParentLink
     */
    select?: StudentParentLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParentLink
     */
    omit?: StudentParentLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentLinkInclude<ExtArgs> | null
    /**
     * Filter, which StudentParentLinks to fetch.
     */
    where?: StudentParentLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentParentLinks to fetch.
     */
    orderBy?: StudentParentLinkOrderByWithRelationInput | StudentParentLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentParentLinks.
     */
    cursor?: StudentParentLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentParentLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentParentLinks.
     */
    skip?: number
    distinct?: StudentParentLinkScalarFieldEnum | StudentParentLinkScalarFieldEnum[]
  }

  /**
   * StudentParentLink create
   */
  export type StudentParentLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParentLink
     */
    select?: StudentParentLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParentLink
     */
    omit?: StudentParentLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentParentLink.
     */
    data: XOR<StudentParentLinkCreateInput, StudentParentLinkUncheckedCreateInput>
  }

  /**
   * StudentParentLink createMany
   */
  export type StudentParentLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentParentLinks.
     */
    data: StudentParentLinkCreateManyInput | StudentParentLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentParentLink update
   */
  export type StudentParentLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParentLink
     */
    select?: StudentParentLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParentLink
     */
    omit?: StudentParentLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentParentLink.
     */
    data: XOR<StudentParentLinkUpdateInput, StudentParentLinkUncheckedUpdateInput>
    /**
     * Choose, which StudentParentLink to update.
     */
    where: StudentParentLinkWhereUniqueInput
  }

  /**
   * StudentParentLink updateMany
   */
  export type StudentParentLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentParentLinks.
     */
    data: XOR<StudentParentLinkUpdateManyMutationInput, StudentParentLinkUncheckedUpdateManyInput>
    /**
     * Filter which StudentParentLinks to update
     */
    where?: StudentParentLinkWhereInput
    /**
     * Limit how many StudentParentLinks to update.
     */
    limit?: number
  }

  /**
   * StudentParentLink upsert
   */
  export type StudentParentLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParentLink
     */
    select?: StudentParentLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParentLink
     */
    omit?: StudentParentLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentParentLink to update in case it exists.
     */
    where: StudentParentLinkWhereUniqueInput
    /**
     * In case the StudentParentLink found by the `where` argument doesn't exist, create a new StudentParentLink with this data.
     */
    create: XOR<StudentParentLinkCreateInput, StudentParentLinkUncheckedCreateInput>
    /**
     * In case the StudentParentLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentParentLinkUpdateInput, StudentParentLinkUncheckedUpdateInput>
  }

  /**
   * StudentParentLink delete
   */
  export type StudentParentLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParentLink
     */
    select?: StudentParentLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParentLink
     */
    omit?: StudentParentLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentLinkInclude<ExtArgs> | null
    /**
     * Filter which StudentParentLink to delete.
     */
    where: StudentParentLinkWhereUniqueInput
  }

  /**
   * StudentParentLink deleteMany
   */
  export type StudentParentLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentParentLinks to delete
     */
    where?: StudentParentLinkWhereInput
    /**
     * Limit how many StudentParentLinks to delete.
     */
    limit?: number
  }

  /**
   * StudentParentLink without action
   */
  export type StudentParentLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParentLink
     */
    select?: StudentParentLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParentLink
     */
    omit?: StudentParentLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentLinkInclude<ExtArgs> | null
  }


  /**
   * Model Class
   */

  export type AggregateClass = {
    _count: ClassCountAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  export type ClassMinAggregateOutputType = {
    id: string | null
    schoolId: string | null
    name: string | null
    section: string | null
    academicYear: string | null
    homeroomTeacherId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassMaxAggregateOutputType = {
    id: string | null
    schoolId: string | null
    name: string | null
    section: string | null
    academicYear: string | null
    homeroomTeacherId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassCountAggregateOutputType = {
    id: number
    schoolId: number
    name: number
    section: number
    academicYear: number
    homeroomTeacherId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClassMinAggregateInputType = {
    id?: true
    schoolId?: true
    name?: true
    section?: true
    academicYear?: true
    homeroomTeacherId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassMaxAggregateInputType = {
    id?: true
    schoolId?: true
    name?: true
    section?: true
    academicYear?: true
    homeroomTeacherId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassCountAggregateInputType = {
    id?: true
    schoolId?: true
    name?: true
    section?: true
    academicYear?: true
    homeroomTeacherId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Class to aggregate.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Classes
    **/
    _count?: true | ClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassMaxAggregateInputType
  }

  export type GetClassAggregateType<T extends ClassAggregateArgs> = {
        [P in keyof T & keyof AggregateClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClass[P]>
      : GetScalarType<T[P], AggregateClass[P]>
  }




  export type ClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithAggregationInput | ClassOrderByWithAggregationInput[]
    by: ClassScalarFieldEnum[] | ClassScalarFieldEnum
    having?: ClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassCountAggregateInputType | true
    _min?: ClassMinAggregateInputType
    _max?: ClassMaxAggregateInputType
  }

  export type ClassGroupByOutputType = {
    id: string
    schoolId: string
    name: string
    section: string | null
    academicYear: string
    homeroomTeacherId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ClassCountAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  type GetClassGroupByPayload<T extends ClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassGroupByOutputType[P]>
            : GetScalarType<T[P], ClassGroupByOutputType[P]>
        }
      >
    >


  export type ClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    name?: boolean
    section?: boolean
    academicYear?: boolean
    homeroomTeacherId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    homeroomTeacher?: boolean | Class$homeroomTeacherArgs<ExtArgs>
    studentsEnrolled?: boolean | Class$studentsEnrolledArgs<ExtArgs>
    currentStudents?: boolean | Class$currentStudentsArgs<ExtArgs>
    timetableSlots?: boolean | Class$timetableSlotsArgs<ExtArgs>
    assignments?: boolean | Class$assignmentsArgs<ExtArgs>
    announcements?: boolean | Class$announcementsArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>



  export type ClassSelectScalar = {
    id?: boolean
    schoolId?: boolean
    name?: boolean
    section?: boolean
    academicYear?: boolean
    homeroomTeacherId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClassOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "schoolId" | "name" | "section" | "academicYear" | "homeroomTeacherId" | "createdAt" | "updatedAt", ExtArgs["result"]["class"]>
  export type ClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    homeroomTeacher?: boolean | Class$homeroomTeacherArgs<ExtArgs>
    studentsEnrolled?: boolean | Class$studentsEnrolledArgs<ExtArgs>
    currentStudents?: boolean | Class$currentStudentsArgs<ExtArgs>
    timetableSlots?: boolean | Class$timetableSlotsArgs<ExtArgs>
    assignments?: boolean | Class$assignmentsArgs<ExtArgs>
    announcements?: boolean | Class$announcementsArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Class"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      homeroomTeacher: Prisma.$TeacherPayload<ExtArgs> | null
      studentsEnrolled: Prisma.$StudentClassEnrollmentPayload<ExtArgs>[]
      currentStudents: Prisma.$StudentPayload<ExtArgs>[]
      timetableSlots: Prisma.$TimetableSlotPayload<ExtArgs>[]
      assignments: Prisma.$AssignmentPayload<ExtArgs>[]
      announcements: Prisma.$ClassAnnouncementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      schoolId: string
      name: string
      section: string | null
      academicYear: string
      homeroomTeacherId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["class"]>
    composites: {}
  }

  type ClassGetPayload<S extends boolean | null | undefined | ClassDefaultArgs> = $Result.GetResult<Prisma.$ClassPayload, S>

  type ClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassCountAggregateInputType | true
    }

  export interface ClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Class'], meta: { name: 'Class' } }
    /**
     * Find zero or one Class that matches the filter.
     * @param {ClassFindUniqueArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassFindUniqueArgs>(args: SelectSubset<T, ClassFindUniqueArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Class that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassFindUniqueOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassFindFirstArgs>(args?: SelectSubset<T, ClassFindFirstArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classes
     * const classes = await prisma.class.findMany()
     * 
     * // Get first 10 Classes
     * const classes = await prisma.class.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classWithIdOnly = await prisma.class.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassFindManyArgs>(args?: SelectSubset<T, ClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Class.
     * @param {ClassCreateArgs} args - Arguments to create a Class.
     * @example
     * // Create one Class
     * const Class = await prisma.class.create({
     *   data: {
     *     // ... data to create a Class
     *   }
     * })
     * 
     */
    create<T extends ClassCreateArgs>(args: SelectSubset<T, ClassCreateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Classes.
     * @param {ClassCreateManyArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassCreateManyArgs>(args?: SelectSubset<T, ClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Class.
     * @param {ClassDeleteArgs} args - Arguments to delete one Class.
     * @example
     * // Delete one Class
     * const Class = await prisma.class.delete({
     *   where: {
     *     // ... filter to delete one Class
     *   }
     * })
     * 
     */
    delete<T extends ClassDeleteArgs>(args: SelectSubset<T, ClassDeleteArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Class.
     * @param {ClassUpdateArgs} args - Arguments to update one Class.
     * @example
     * // Update one Class
     * const class = await prisma.class.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassUpdateArgs>(args: SelectSubset<T, ClassUpdateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Classes.
     * @param {ClassDeleteManyArgs} args - Arguments to filter Classes to delete.
     * @example
     * // Delete a few Classes
     * const { count } = await prisma.class.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassDeleteManyArgs>(args?: SelectSubset<T, ClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassUpdateManyArgs>(args: SelectSubset<T, ClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Class.
     * @param {ClassUpsertArgs} args - Arguments to update or create a Class.
     * @example
     * // Update or create a Class
     * const class = await prisma.class.upsert({
     *   create: {
     *     // ... data to create a Class
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Class we want to update
     *   }
     * })
     */
    upsert<T extends ClassUpsertArgs>(args: SelectSubset<T, ClassUpsertArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassCountArgs} args - Arguments to filter Classes to count.
     * @example
     * // Count the number of Classes
     * const count = await prisma.class.count({
     *   where: {
     *     // ... the filter for the Classes we want to count
     *   }
     * })
    **/
    count<T extends ClassCountArgs>(
      args?: Subset<T, ClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassAggregateArgs>(args: Subset<T, ClassAggregateArgs>): Prisma.PrismaPromise<GetClassAggregateType<T>>

    /**
     * Group by Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassGroupByArgs['orderBy'] }
        : { orderBy?: ClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Class model
   */
  readonly fields: ClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Class.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    homeroomTeacher<T extends Class$homeroomTeacherArgs<ExtArgs> = {}>(args?: Subset<T, Class$homeroomTeacherArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    studentsEnrolled<T extends Class$studentsEnrolledArgs<ExtArgs> = {}>(args?: Subset<T, Class$studentsEnrolledArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentClassEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    currentStudents<T extends Class$currentStudentsArgs<ExtArgs> = {}>(args?: Subset<T, Class$currentStudentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    timetableSlots<T extends Class$timetableSlotsArgs<ExtArgs> = {}>(args?: Subset<T, Class$timetableSlotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimetableSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignments<T extends Class$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Class$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    announcements<T extends Class$announcementsArgs<ExtArgs> = {}>(args?: Subset<T, Class$announcementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassAnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Class model
   */
  interface ClassFieldRefs {
    readonly id: FieldRef<"Class", 'String'>
    readonly schoolId: FieldRef<"Class", 'String'>
    readonly name: FieldRef<"Class", 'String'>
    readonly section: FieldRef<"Class", 'String'>
    readonly academicYear: FieldRef<"Class", 'String'>
    readonly homeroomTeacherId: FieldRef<"Class", 'String'>
    readonly createdAt: FieldRef<"Class", 'DateTime'>
    readonly updatedAt: FieldRef<"Class", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Class findUnique
   */
  export type ClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findUniqueOrThrow
   */
  export type ClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findFirst
   */
  export type ClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findFirstOrThrow
   */
  export type ClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findMany
   */
  export type ClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class create
   */
  export type ClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to create a Class.
     */
    data: XOR<ClassCreateInput, ClassUncheckedCreateInput>
  }

  /**
   * Class createMany
   */
  export type ClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Class update
   */
  export type ClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to update a Class.
     */
    data: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
    /**
     * Choose, which Class to update.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class updateMany
   */
  export type ClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
  }

  /**
   * Class upsert
   */
  export type ClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The filter to search for the Class to update in case it exists.
     */
    where: ClassWhereUniqueInput
    /**
     * In case the Class found by the `where` argument doesn't exist, create a new Class with this data.
     */
    create: XOR<ClassCreateInput, ClassUncheckedCreateInput>
    /**
     * In case the Class was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
  }

  /**
   * Class delete
   */
  export type ClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter which Class to delete.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class deleteMany
   */
  export type ClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classes to delete
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to delete.
     */
    limit?: number
  }

  /**
   * Class.homeroomTeacher
   */
  export type Class$homeroomTeacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    where?: TeacherWhereInput
  }

  /**
   * Class.studentsEnrolled
   */
  export type Class$studentsEnrolledArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentClassEnrollment
     */
    select?: StudentClassEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentClassEnrollment
     */
    omit?: StudentClassEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentClassEnrollmentInclude<ExtArgs> | null
    where?: StudentClassEnrollmentWhereInput
    orderBy?: StudentClassEnrollmentOrderByWithRelationInput | StudentClassEnrollmentOrderByWithRelationInput[]
    cursor?: StudentClassEnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentClassEnrollmentScalarFieldEnum | StudentClassEnrollmentScalarFieldEnum[]
  }

  /**
   * Class.currentStudents
   */
  export type Class$currentStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Class.timetableSlots
   */
  export type Class$timetableSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimetableSlot
     */
    select?: TimetableSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimetableSlot
     */
    omit?: TimetableSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableSlotInclude<ExtArgs> | null
    where?: TimetableSlotWhereInput
    orderBy?: TimetableSlotOrderByWithRelationInput | TimetableSlotOrderByWithRelationInput[]
    cursor?: TimetableSlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimetableSlotScalarFieldEnum | TimetableSlotScalarFieldEnum[]
  }

  /**
   * Class.assignments
   */
  export type Class$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    cursor?: AssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Class.announcements
   */
  export type Class$announcementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassAnnouncement
     */
    select?: ClassAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassAnnouncement
     */
    omit?: ClassAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassAnnouncementInclude<ExtArgs> | null
    where?: ClassAnnouncementWhereInput
    orderBy?: ClassAnnouncementOrderByWithRelationInput | ClassAnnouncementOrderByWithRelationInput[]
    cursor?: ClassAnnouncementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassAnnouncementScalarFieldEnum | ClassAnnouncementScalarFieldEnum[]
  }

  /**
   * Class without action
   */
  export type ClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
  }


  /**
   * Model StudentClassEnrollment
   */

  export type AggregateStudentClassEnrollment = {
    _count: StudentClassEnrollmentCountAggregateOutputType | null
    _min: StudentClassEnrollmentMinAggregateOutputType | null
    _max: StudentClassEnrollmentMaxAggregateOutputType | null
  }

  export type StudentClassEnrollmentMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    classId: string | null
    academicYear: string | null
    enrollmentDate: Date | null
    isCurrent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentClassEnrollmentMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    classId: string | null
    academicYear: string | null
    enrollmentDate: Date | null
    isCurrent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentClassEnrollmentCountAggregateOutputType = {
    id: number
    studentId: number
    classId: number
    academicYear: number
    enrollmentDate: number
    isCurrent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentClassEnrollmentMinAggregateInputType = {
    id?: true
    studentId?: true
    classId?: true
    academicYear?: true
    enrollmentDate?: true
    isCurrent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentClassEnrollmentMaxAggregateInputType = {
    id?: true
    studentId?: true
    classId?: true
    academicYear?: true
    enrollmentDate?: true
    isCurrent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentClassEnrollmentCountAggregateInputType = {
    id?: true
    studentId?: true
    classId?: true
    academicYear?: true
    enrollmentDate?: true
    isCurrent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentClassEnrollmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentClassEnrollment to aggregate.
     */
    where?: StudentClassEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentClassEnrollments to fetch.
     */
    orderBy?: StudentClassEnrollmentOrderByWithRelationInput | StudentClassEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentClassEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentClassEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentClassEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentClassEnrollments
    **/
    _count?: true | StudentClassEnrollmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentClassEnrollmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentClassEnrollmentMaxAggregateInputType
  }

  export type GetStudentClassEnrollmentAggregateType<T extends StudentClassEnrollmentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentClassEnrollment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentClassEnrollment[P]>
      : GetScalarType<T[P], AggregateStudentClassEnrollment[P]>
  }




  export type StudentClassEnrollmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentClassEnrollmentWhereInput
    orderBy?: StudentClassEnrollmentOrderByWithAggregationInput | StudentClassEnrollmentOrderByWithAggregationInput[]
    by: StudentClassEnrollmentScalarFieldEnum[] | StudentClassEnrollmentScalarFieldEnum
    having?: StudentClassEnrollmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentClassEnrollmentCountAggregateInputType | true
    _min?: StudentClassEnrollmentMinAggregateInputType
    _max?: StudentClassEnrollmentMaxAggregateInputType
  }

  export type StudentClassEnrollmentGroupByOutputType = {
    id: string
    studentId: string
    classId: string
    academicYear: string
    enrollmentDate: Date
    isCurrent: boolean
    createdAt: Date
    updatedAt: Date
    _count: StudentClassEnrollmentCountAggregateOutputType | null
    _min: StudentClassEnrollmentMinAggregateOutputType | null
    _max: StudentClassEnrollmentMaxAggregateOutputType | null
  }

  type GetStudentClassEnrollmentGroupByPayload<T extends StudentClassEnrollmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentClassEnrollmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentClassEnrollmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentClassEnrollmentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentClassEnrollmentGroupByOutputType[P]>
        }
      >
    >


  export type StudentClassEnrollmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    classId?: boolean
    academicYear?: boolean
    enrollmentDate?: boolean
    isCurrent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentClassEnrollment"]>



  export type StudentClassEnrollmentSelectScalar = {
    id?: boolean
    studentId?: boolean
    classId?: boolean
    academicYear?: boolean
    enrollmentDate?: boolean
    isCurrent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentClassEnrollmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "classId" | "academicYear" | "enrollmentDate" | "isCurrent" | "createdAt" | "updatedAt", ExtArgs["result"]["studentClassEnrollment"]>
  export type StudentClassEnrollmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }

  export type $StudentClassEnrollmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentClassEnrollment"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      classId: string
      academicYear: string
      enrollmentDate: Date
      isCurrent: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studentClassEnrollment"]>
    composites: {}
  }

  type StudentClassEnrollmentGetPayload<S extends boolean | null | undefined | StudentClassEnrollmentDefaultArgs> = $Result.GetResult<Prisma.$StudentClassEnrollmentPayload, S>

  type StudentClassEnrollmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentClassEnrollmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentClassEnrollmentCountAggregateInputType | true
    }

  export interface StudentClassEnrollmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentClassEnrollment'], meta: { name: 'StudentClassEnrollment' } }
    /**
     * Find zero or one StudentClassEnrollment that matches the filter.
     * @param {StudentClassEnrollmentFindUniqueArgs} args - Arguments to find a StudentClassEnrollment
     * @example
     * // Get one StudentClassEnrollment
     * const studentClassEnrollment = await prisma.studentClassEnrollment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentClassEnrollmentFindUniqueArgs>(args: SelectSubset<T, StudentClassEnrollmentFindUniqueArgs<ExtArgs>>): Prisma__StudentClassEnrollmentClient<$Result.GetResult<Prisma.$StudentClassEnrollmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentClassEnrollment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentClassEnrollmentFindUniqueOrThrowArgs} args - Arguments to find a StudentClassEnrollment
     * @example
     * // Get one StudentClassEnrollment
     * const studentClassEnrollment = await prisma.studentClassEnrollment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentClassEnrollmentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentClassEnrollmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentClassEnrollmentClient<$Result.GetResult<Prisma.$StudentClassEnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentClassEnrollment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentClassEnrollmentFindFirstArgs} args - Arguments to find a StudentClassEnrollment
     * @example
     * // Get one StudentClassEnrollment
     * const studentClassEnrollment = await prisma.studentClassEnrollment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentClassEnrollmentFindFirstArgs>(args?: SelectSubset<T, StudentClassEnrollmentFindFirstArgs<ExtArgs>>): Prisma__StudentClassEnrollmentClient<$Result.GetResult<Prisma.$StudentClassEnrollmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentClassEnrollment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentClassEnrollmentFindFirstOrThrowArgs} args - Arguments to find a StudentClassEnrollment
     * @example
     * // Get one StudentClassEnrollment
     * const studentClassEnrollment = await prisma.studentClassEnrollment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentClassEnrollmentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentClassEnrollmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentClassEnrollmentClient<$Result.GetResult<Prisma.$StudentClassEnrollmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentClassEnrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentClassEnrollmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentClassEnrollments
     * const studentClassEnrollments = await prisma.studentClassEnrollment.findMany()
     * 
     * // Get first 10 StudentClassEnrollments
     * const studentClassEnrollments = await prisma.studentClassEnrollment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentClassEnrollmentWithIdOnly = await prisma.studentClassEnrollment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentClassEnrollmentFindManyArgs>(args?: SelectSubset<T, StudentClassEnrollmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentClassEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentClassEnrollment.
     * @param {StudentClassEnrollmentCreateArgs} args - Arguments to create a StudentClassEnrollment.
     * @example
     * // Create one StudentClassEnrollment
     * const StudentClassEnrollment = await prisma.studentClassEnrollment.create({
     *   data: {
     *     // ... data to create a StudentClassEnrollment
     *   }
     * })
     * 
     */
    create<T extends StudentClassEnrollmentCreateArgs>(args: SelectSubset<T, StudentClassEnrollmentCreateArgs<ExtArgs>>): Prisma__StudentClassEnrollmentClient<$Result.GetResult<Prisma.$StudentClassEnrollmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentClassEnrollments.
     * @param {StudentClassEnrollmentCreateManyArgs} args - Arguments to create many StudentClassEnrollments.
     * @example
     * // Create many StudentClassEnrollments
     * const studentClassEnrollment = await prisma.studentClassEnrollment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentClassEnrollmentCreateManyArgs>(args?: SelectSubset<T, StudentClassEnrollmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StudentClassEnrollment.
     * @param {StudentClassEnrollmentDeleteArgs} args - Arguments to delete one StudentClassEnrollment.
     * @example
     * // Delete one StudentClassEnrollment
     * const StudentClassEnrollment = await prisma.studentClassEnrollment.delete({
     *   where: {
     *     // ... filter to delete one StudentClassEnrollment
     *   }
     * })
     * 
     */
    delete<T extends StudentClassEnrollmentDeleteArgs>(args: SelectSubset<T, StudentClassEnrollmentDeleteArgs<ExtArgs>>): Prisma__StudentClassEnrollmentClient<$Result.GetResult<Prisma.$StudentClassEnrollmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentClassEnrollment.
     * @param {StudentClassEnrollmentUpdateArgs} args - Arguments to update one StudentClassEnrollment.
     * @example
     * // Update one StudentClassEnrollment
     * const studentClassEnrollment = await prisma.studentClassEnrollment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentClassEnrollmentUpdateArgs>(args: SelectSubset<T, StudentClassEnrollmentUpdateArgs<ExtArgs>>): Prisma__StudentClassEnrollmentClient<$Result.GetResult<Prisma.$StudentClassEnrollmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentClassEnrollments.
     * @param {StudentClassEnrollmentDeleteManyArgs} args - Arguments to filter StudentClassEnrollments to delete.
     * @example
     * // Delete a few StudentClassEnrollments
     * const { count } = await prisma.studentClassEnrollment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentClassEnrollmentDeleteManyArgs>(args?: SelectSubset<T, StudentClassEnrollmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentClassEnrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentClassEnrollmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentClassEnrollments
     * const studentClassEnrollment = await prisma.studentClassEnrollment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentClassEnrollmentUpdateManyArgs>(args: SelectSubset<T, StudentClassEnrollmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentClassEnrollment.
     * @param {StudentClassEnrollmentUpsertArgs} args - Arguments to update or create a StudentClassEnrollment.
     * @example
     * // Update or create a StudentClassEnrollment
     * const studentClassEnrollment = await prisma.studentClassEnrollment.upsert({
     *   create: {
     *     // ... data to create a StudentClassEnrollment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentClassEnrollment we want to update
     *   }
     * })
     */
    upsert<T extends StudentClassEnrollmentUpsertArgs>(args: SelectSubset<T, StudentClassEnrollmentUpsertArgs<ExtArgs>>): Prisma__StudentClassEnrollmentClient<$Result.GetResult<Prisma.$StudentClassEnrollmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentClassEnrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentClassEnrollmentCountArgs} args - Arguments to filter StudentClassEnrollments to count.
     * @example
     * // Count the number of StudentClassEnrollments
     * const count = await prisma.studentClassEnrollment.count({
     *   where: {
     *     // ... the filter for the StudentClassEnrollments we want to count
     *   }
     * })
    **/
    count<T extends StudentClassEnrollmentCountArgs>(
      args?: Subset<T, StudentClassEnrollmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentClassEnrollmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentClassEnrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentClassEnrollmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentClassEnrollmentAggregateArgs>(args: Subset<T, StudentClassEnrollmentAggregateArgs>): Prisma.PrismaPromise<GetStudentClassEnrollmentAggregateType<T>>

    /**
     * Group by StudentClassEnrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentClassEnrollmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentClassEnrollmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentClassEnrollmentGroupByArgs['orderBy'] }
        : { orderBy?: StudentClassEnrollmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentClassEnrollmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentClassEnrollmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentClassEnrollment model
   */
  readonly fields: StudentClassEnrollmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentClassEnrollment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClassEnrollmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentClassEnrollment model
   */
  interface StudentClassEnrollmentFieldRefs {
    readonly id: FieldRef<"StudentClassEnrollment", 'String'>
    readonly studentId: FieldRef<"StudentClassEnrollment", 'String'>
    readonly classId: FieldRef<"StudentClassEnrollment", 'String'>
    readonly academicYear: FieldRef<"StudentClassEnrollment", 'String'>
    readonly enrollmentDate: FieldRef<"StudentClassEnrollment", 'DateTime'>
    readonly isCurrent: FieldRef<"StudentClassEnrollment", 'Boolean'>
    readonly createdAt: FieldRef<"StudentClassEnrollment", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentClassEnrollment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentClassEnrollment findUnique
   */
  export type StudentClassEnrollmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentClassEnrollment
     */
    select?: StudentClassEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentClassEnrollment
     */
    omit?: StudentClassEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentClassEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which StudentClassEnrollment to fetch.
     */
    where: StudentClassEnrollmentWhereUniqueInput
  }

  /**
   * StudentClassEnrollment findUniqueOrThrow
   */
  export type StudentClassEnrollmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentClassEnrollment
     */
    select?: StudentClassEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentClassEnrollment
     */
    omit?: StudentClassEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentClassEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which StudentClassEnrollment to fetch.
     */
    where: StudentClassEnrollmentWhereUniqueInput
  }

  /**
   * StudentClassEnrollment findFirst
   */
  export type StudentClassEnrollmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentClassEnrollment
     */
    select?: StudentClassEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentClassEnrollment
     */
    omit?: StudentClassEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentClassEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which StudentClassEnrollment to fetch.
     */
    where?: StudentClassEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentClassEnrollments to fetch.
     */
    orderBy?: StudentClassEnrollmentOrderByWithRelationInput | StudentClassEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentClassEnrollments.
     */
    cursor?: StudentClassEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentClassEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentClassEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentClassEnrollments.
     */
    distinct?: StudentClassEnrollmentScalarFieldEnum | StudentClassEnrollmentScalarFieldEnum[]
  }

  /**
   * StudentClassEnrollment findFirstOrThrow
   */
  export type StudentClassEnrollmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentClassEnrollment
     */
    select?: StudentClassEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentClassEnrollment
     */
    omit?: StudentClassEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentClassEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which StudentClassEnrollment to fetch.
     */
    where?: StudentClassEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentClassEnrollments to fetch.
     */
    orderBy?: StudentClassEnrollmentOrderByWithRelationInput | StudentClassEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentClassEnrollments.
     */
    cursor?: StudentClassEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentClassEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentClassEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentClassEnrollments.
     */
    distinct?: StudentClassEnrollmentScalarFieldEnum | StudentClassEnrollmentScalarFieldEnum[]
  }

  /**
   * StudentClassEnrollment findMany
   */
  export type StudentClassEnrollmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentClassEnrollment
     */
    select?: StudentClassEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentClassEnrollment
     */
    omit?: StudentClassEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentClassEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which StudentClassEnrollments to fetch.
     */
    where?: StudentClassEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentClassEnrollments to fetch.
     */
    orderBy?: StudentClassEnrollmentOrderByWithRelationInput | StudentClassEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentClassEnrollments.
     */
    cursor?: StudentClassEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentClassEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentClassEnrollments.
     */
    skip?: number
    distinct?: StudentClassEnrollmentScalarFieldEnum | StudentClassEnrollmentScalarFieldEnum[]
  }

  /**
   * StudentClassEnrollment create
   */
  export type StudentClassEnrollmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentClassEnrollment
     */
    select?: StudentClassEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentClassEnrollment
     */
    omit?: StudentClassEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentClassEnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentClassEnrollment.
     */
    data: XOR<StudentClassEnrollmentCreateInput, StudentClassEnrollmentUncheckedCreateInput>
  }

  /**
   * StudentClassEnrollment createMany
   */
  export type StudentClassEnrollmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentClassEnrollments.
     */
    data: StudentClassEnrollmentCreateManyInput | StudentClassEnrollmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentClassEnrollment update
   */
  export type StudentClassEnrollmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentClassEnrollment
     */
    select?: StudentClassEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentClassEnrollment
     */
    omit?: StudentClassEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentClassEnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentClassEnrollment.
     */
    data: XOR<StudentClassEnrollmentUpdateInput, StudentClassEnrollmentUncheckedUpdateInput>
    /**
     * Choose, which StudentClassEnrollment to update.
     */
    where: StudentClassEnrollmentWhereUniqueInput
  }

  /**
   * StudentClassEnrollment updateMany
   */
  export type StudentClassEnrollmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentClassEnrollments.
     */
    data: XOR<StudentClassEnrollmentUpdateManyMutationInput, StudentClassEnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which StudentClassEnrollments to update
     */
    where?: StudentClassEnrollmentWhereInput
    /**
     * Limit how many StudentClassEnrollments to update.
     */
    limit?: number
  }

  /**
   * StudentClassEnrollment upsert
   */
  export type StudentClassEnrollmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentClassEnrollment
     */
    select?: StudentClassEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentClassEnrollment
     */
    omit?: StudentClassEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentClassEnrollmentInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentClassEnrollment to update in case it exists.
     */
    where: StudentClassEnrollmentWhereUniqueInput
    /**
     * In case the StudentClassEnrollment found by the `where` argument doesn't exist, create a new StudentClassEnrollment with this data.
     */
    create: XOR<StudentClassEnrollmentCreateInput, StudentClassEnrollmentUncheckedCreateInput>
    /**
     * In case the StudentClassEnrollment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentClassEnrollmentUpdateInput, StudentClassEnrollmentUncheckedUpdateInput>
  }

  /**
   * StudentClassEnrollment delete
   */
  export type StudentClassEnrollmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentClassEnrollment
     */
    select?: StudentClassEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentClassEnrollment
     */
    omit?: StudentClassEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentClassEnrollmentInclude<ExtArgs> | null
    /**
     * Filter which StudentClassEnrollment to delete.
     */
    where: StudentClassEnrollmentWhereUniqueInput
  }

  /**
   * StudentClassEnrollment deleteMany
   */
  export type StudentClassEnrollmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentClassEnrollments to delete
     */
    where?: StudentClassEnrollmentWhereInput
    /**
     * Limit how many StudentClassEnrollments to delete.
     */
    limit?: number
  }

  /**
   * StudentClassEnrollment without action
   */
  export type StudentClassEnrollmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentClassEnrollment
     */
    select?: StudentClassEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentClassEnrollment
     */
    omit?: StudentClassEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentClassEnrollmentInclude<ExtArgs> | null
  }


  /**
   * Model Subject
   */

  export type AggregateSubject = {
    _count: SubjectCountAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  export type SubjectMinAggregateOutputType = {
    id: string | null
    schoolId: string | null
    name: string | null
    code: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubjectMaxAggregateOutputType = {
    id: string | null
    schoolId: string | null
    name: string | null
    code: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubjectCountAggregateOutputType = {
    id: number
    schoolId: number
    name: number
    code: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubjectMinAggregateInputType = {
    id?: true
    schoolId?: true
    name?: true
    code?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubjectMaxAggregateInputType = {
    id?: true
    schoolId?: true
    name?: true
    code?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubjectCountAggregateInputType = {
    id?: true
    schoolId?: true
    name?: true
    code?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subject to aggregate.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subjects
    **/
    _count?: true | SubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectMaxAggregateInputType
  }

  export type GetSubjectAggregateType<T extends SubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubject[P]>
      : GetScalarType<T[P], AggregateSubject[P]>
  }




  export type SubjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithAggregationInput | SubjectOrderByWithAggregationInput[]
    by: SubjectScalarFieldEnum[] | SubjectScalarFieldEnum
    having?: SubjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectCountAggregateInputType | true
    _min?: SubjectMinAggregateInputType
    _max?: SubjectMaxAggregateInputType
  }

  export type SubjectGroupByOutputType = {
    id: string
    schoolId: string
    name: string
    code: string | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: SubjectCountAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  type GetSubjectGroupByPayload<T extends SubjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectGroupByOutputType[P]>
        }
      >
    >


  export type SubjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    timetableSlots?: boolean | Subject$timetableSlotsArgs<ExtArgs>
    assignments?: boolean | Subject$assignmentsArgs<ExtArgs>
    grades?: boolean | Subject$gradesArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>



  export type SubjectSelectScalar = {
    id?: boolean
    schoolId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "schoolId" | "name" | "code" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["subject"]>
  export type SubjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    timetableSlots?: boolean | Subject$timetableSlotsArgs<ExtArgs>
    assignments?: boolean | Subject$assignmentsArgs<ExtArgs>
    grades?: boolean | Subject$gradesArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SubjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subject"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      timetableSlots: Prisma.$TimetableSlotPayload<ExtArgs>[]
      assignments: Prisma.$AssignmentPayload<ExtArgs>[]
      grades: Prisma.$StudentGradePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      schoolId: string
      name: string
      code: string | null
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subject"]>
    composites: {}
  }

  type SubjectGetPayload<S extends boolean | null | undefined | SubjectDefaultArgs> = $Result.GetResult<Prisma.$SubjectPayload, S>

  type SubjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubjectCountAggregateInputType | true
    }

  export interface SubjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subject'], meta: { name: 'Subject' } }
    /**
     * Find zero or one Subject that matches the filter.
     * @param {SubjectFindUniqueArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubjectFindUniqueArgs>(args: SelectSubset<T, SubjectFindUniqueArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubjectFindUniqueOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubjectFindUniqueOrThrowArgs>(args: SelectSubset<T, SubjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubjectFindFirstArgs>(args?: SelectSubset<T, SubjectFindFirstArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubjectFindFirstOrThrowArgs>(args?: SelectSubset<T, SubjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subjects
     * const subjects = await prisma.subject.findMany()
     * 
     * // Get first 10 Subjects
     * const subjects = await prisma.subject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subjectWithIdOnly = await prisma.subject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubjectFindManyArgs>(args?: SelectSubset<T, SubjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subject.
     * @param {SubjectCreateArgs} args - Arguments to create a Subject.
     * @example
     * // Create one Subject
     * const Subject = await prisma.subject.create({
     *   data: {
     *     // ... data to create a Subject
     *   }
     * })
     * 
     */
    create<T extends SubjectCreateArgs>(args: SelectSubset<T, SubjectCreateArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subjects.
     * @param {SubjectCreateManyArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subject = await prisma.subject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubjectCreateManyArgs>(args?: SelectSubset<T, SubjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subject.
     * @param {SubjectDeleteArgs} args - Arguments to delete one Subject.
     * @example
     * // Delete one Subject
     * const Subject = await prisma.subject.delete({
     *   where: {
     *     // ... filter to delete one Subject
     *   }
     * })
     * 
     */
    delete<T extends SubjectDeleteArgs>(args: SelectSubset<T, SubjectDeleteArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subject.
     * @param {SubjectUpdateArgs} args - Arguments to update one Subject.
     * @example
     * // Update one Subject
     * const subject = await prisma.subject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubjectUpdateArgs>(args: SelectSubset<T, SubjectUpdateArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subjects.
     * @param {SubjectDeleteManyArgs} args - Arguments to filter Subjects to delete.
     * @example
     * // Delete a few Subjects
     * const { count } = await prisma.subject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubjectDeleteManyArgs>(args?: SelectSubset<T, SubjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subjects
     * const subject = await prisma.subject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubjectUpdateManyArgs>(args: SelectSubset<T, SubjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subject.
     * @param {SubjectUpsertArgs} args - Arguments to update or create a Subject.
     * @example
     * // Update or create a Subject
     * const subject = await prisma.subject.upsert({
     *   create: {
     *     // ... data to create a Subject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subject we want to update
     *   }
     * })
     */
    upsert<T extends SubjectUpsertArgs>(args: SelectSubset<T, SubjectUpsertArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectCountArgs} args - Arguments to filter Subjects to count.
     * @example
     * // Count the number of Subjects
     * const count = await prisma.subject.count({
     *   where: {
     *     // ... the filter for the Subjects we want to count
     *   }
     * })
    **/
    count<T extends SubjectCountArgs>(
      args?: Subset<T, SubjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectAggregateArgs>(args: Subset<T, SubjectAggregateArgs>): Prisma.PrismaPromise<GetSubjectAggregateType<T>>

    /**
     * Group by Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubjectGroupByArgs['orderBy'] }
        : { orderBy?: SubjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subject model
   */
  readonly fields: SubjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    timetableSlots<T extends Subject$timetableSlotsArgs<ExtArgs> = {}>(args?: Subset<T, Subject$timetableSlotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimetableSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignments<T extends Subject$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Subject$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    grades<T extends Subject$gradesArgs<ExtArgs> = {}>(args?: Subset<T, Subject$gradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentGradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subject model
   */
  interface SubjectFieldRefs {
    readonly id: FieldRef<"Subject", 'String'>
    readonly schoolId: FieldRef<"Subject", 'String'>
    readonly name: FieldRef<"Subject", 'String'>
    readonly code: FieldRef<"Subject", 'String'>
    readonly description: FieldRef<"Subject", 'String'>
    readonly createdAt: FieldRef<"Subject", 'DateTime'>
    readonly updatedAt: FieldRef<"Subject", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subject findUnique
   */
  export type SubjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject findUniqueOrThrow
   */
  export type SubjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject findFirst
   */
  export type SubjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject findFirstOrThrow
   */
  export type SubjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject findMany
   */
  export type SubjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subjects to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject create
   */
  export type SubjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Subject.
     */
    data: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
  }

  /**
   * Subject createMany
   */
  export type SubjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subjects.
     */
    data: SubjectCreateManyInput | SubjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subject update
   */
  export type SubjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Subject.
     */
    data: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
    /**
     * Choose, which Subject to update.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject updateMany
   */
  export type SubjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subjects.
     */
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyInput>
    /**
     * Filter which Subjects to update
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to update.
     */
    limit?: number
  }

  /**
   * Subject upsert
   */
  export type SubjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Subject to update in case it exists.
     */
    where: SubjectWhereUniqueInput
    /**
     * In case the Subject found by the `where` argument doesn't exist, create a new Subject with this data.
     */
    create: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
    /**
     * In case the Subject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
  }

  /**
   * Subject delete
   */
  export type SubjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter which Subject to delete.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject deleteMany
   */
  export type SubjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subjects to delete
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to delete.
     */
    limit?: number
  }

  /**
   * Subject.timetableSlots
   */
  export type Subject$timetableSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimetableSlot
     */
    select?: TimetableSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimetableSlot
     */
    omit?: TimetableSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableSlotInclude<ExtArgs> | null
    where?: TimetableSlotWhereInput
    orderBy?: TimetableSlotOrderByWithRelationInput | TimetableSlotOrderByWithRelationInput[]
    cursor?: TimetableSlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimetableSlotScalarFieldEnum | TimetableSlotScalarFieldEnum[]
  }

  /**
   * Subject.assignments
   */
  export type Subject$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    cursor?: AssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Subject.grades
   */
  export type Subject$gradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentGrade
     */
    select?: StudentGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentGrade
     */
    omit?: StudentGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentGradeInclude<ExtArgs> | null
    where?: StudentGradeWhereInput
    orderBy?: StudentGradeOrderByWithRelationInput | StudentGradeOrderByWithRelationInput[]
    cursor?: StudentGradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentGradeScalarFieldEnum | StudentGradeScalarFieldEnum[]
  }

  /**
   * Subject without action
   */
  export type SubjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
  }


  /**
   * Model TimetableSlot
   */

  export type AggregateTimetableSlot = {
    _count: TimetableSlotCountAggregateOutputType | null
    _min: TimetableSlotMinAggregateOutputType | null
    _max: TimetableSlotMaxAggregateOutputType | null
  }

  export type TimetableSlotMinAggregateOutputType = {
    id: string | null
    schoolId: string | null
    classId: string | null
    subjectId: string | null
    teacherId: string | null
    dayOfWeek: $Enums.DayOfWeek | null
    startTime: string | null
    endTime: string | null
    room: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TimetableSlotMaxAggregateOutputType = {
    id: string | null
    schoolId: string | null
    classId: string | null
    subjectId: string | null
    teacherId: string | null
    dayOfWeek: $Enums.DayOfWeek | null
    startTime: string | null
    endTime: string | null
    room: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TimetableSlotCountAggregateOutputType = {
    id: number
    schoolId: number
    classId: number
    subjectId: number
    teacherId: number
    dayOfWeek: number
    startTime: number
    endTime: number
    room: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TimetableSlotMinAggregateInputType = {
    id?: true
    schoolId?: true
    classId?: true
    subjectId?: true
    teacherId?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    room?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TimetableSlotMaxAggregateInputType = {
    id?: true
    schoolId?: true
    classId?: true
    subjectId?: true
    teacherId?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    room?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TimetableSlotCountAggregateInputType = {
    id?: true
    schoolId?: true
    classId?: true
    subjectId?: true
    teacherId?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    room?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TimetableSlotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimetableSlot to aggregate.
     */
    where?: TimetableSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimetableSlots to fetch.
     */
    orderBy?: TimetableSlotOrderByWithRelationInput | TimetableSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimetableSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimetableSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimetableSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TimetableSlots
    **/
    _count?: true | TimetableSlotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimetableSlotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimetableSlotMaxAggregateInputType
  }

  export type GetTimetableSlotAggregateType<T extends TimetableSlotAggregateArgs> = {
        [P in keyof T & keyof AggregateTimetableSlot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimetableSlot[P]>
      : GetScalarType<T[P], AggregateTimetableSlot[P]>
  }




  export type TimetableSlotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimetableSlotWhereInput
    orderBy?: TimetableSlotOrderByWithAggregationInput | TimetableSlotOrderByWithAggregationInput[]
    by: TimetableSlotScalarFieldEnum[] | TimetableSlotScalarFieldEnum
    having?: TimetableSlotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimetableSlotCountAggregateInputType | true
    _min?: TimetableSlotMinAggregateInputType
    _max?: TimetableSlotMaxAggregateInputType
  }

  export type TimetableSlotGroupByOutputType = {
    id: string
    schoolId: string
    classId: string
    subjectId: string
    teacherId: string
    dayOfWeek: $Enums.DayOfWeek
    startTime: string
    endTime: string
    room: string | null
    createdAt: Date
    updatedAt: Date
    _count: TimetableSlotCountAggregateOutputType | null
    _min: TimetableSlotMinAggregateOutputType | null
    _max: TimetableSlotMaxAggregateOutputType | null
  }

  type GetTimetableSlotGroupByPayload<T extends TimetableSlotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimetableSlotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimetableSlotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimetableSlotGroupByOutputType[P]>
            : GetScalarType<T[P], TimetableSlotGroupByOutputType[P]>
        }
      >
    >


  export type TimetableSlotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    classId?: boolean
    subjectId?: boolean
    teacherId?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    room?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    attendances?: boolean | TimetableSlot$attendancesArgs<ExtArgs>
    _count?: boolean | TimetableSlotCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timetableSlot"]>



  export type TimetableSlotSelectScalar = {
    id?: boolean
    schoolId?: boolean
    classId?: boolean
    subjectId?: boolean
    teacherId?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    room?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TimetableSlotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "schoolId" | "classId" | "subjectId" | "teacherId" | "dayOfWeek" | "startTime" | "endTime" | "room" | "createdAt" | "updatedAt", ExtArgs["result"]["timetableSlot"]>
  export type TimetableSlotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    attendances?: boolean | TimetableSlot$attendancesArgs<ExtArgs>
    _count?: boolean | TimetableSlotCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TimetableSlotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TimetableSlot"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs>
      subject: Prisma.$SubjectPayload<ExtArgs>
      teacher: Prisma.$TeacherPayload<ExtArgs>
      attendances: Prisma.$StudentAttendancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      schoolId: string
      classId: string
      subjectId: string
      teacherId: string
      dayOfWeek: $Enums.DayOfWeek
      startTime: string
      endTime: string
      room: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["timetableSlot"]>
    composites: {}
  }

  type TimetableSlotGetPayload<S extends boolean | null | undefined | TimetableSlotDefaultArgs> = $Result.GetResult<Prisma.$TimetableSlotPayload, S>

  type TimetableSlotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TimetableSlotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TimetableSlotCountAggregateInputType | true
    }

  export interface TimetableSlotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TimetableSlot'], meta: { name: 'TimetableSlot' } }
    /**
     * Find zero or one TimetableSlot that matches the filter.
     * @param {TimetableSlotFindUniqueArgs} args - Arguments to find a TimetableSlot
     * @example
     * // Get one TimetableSlot
     * const timetableSlot = await prisma.timetableSlot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimetableSlotFindUniqueArgs>(args: SelectSubset<T, TimetableSlotFindUniqueArgs<ExtArgs>>): Prisma__TimetableSlotClient<$Result.GetResult<Prisma.$TimetableSlotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TimetableSlot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TimetableSlotFindUniqueOrThrowArgs} args - Arguments to find a TimetableSlot
     * @example
     * // Get one TimetableSlot
     * const timetableSlot = await prisma.timetableSlot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimetableSlotFindUniqueOrThrowArgs>(args: SelectSubset<T, TimetableSlotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimetableSlotClient<$Result.GetResult<Prisma.$TimetableSlotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimetableSlot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimetableSlotFindFirstArgs} args - Arguments to find a TimetableSlot
     * @example
     * // Get one TimetableSlot
     * const timetableSlot = await prisma.timetableSlot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimetableSlotFindFirstArgs>(args?: SelectSubset<T, TimetableSlotFindFirstArgs<ExtArgs>>): Prisma__TimetableSlotClient<$Result.GetResult<Prisma.$TimetableSlotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimetableSlot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimetableSlotFindFirstOrThrowArgs} args - Arguments to find a TimetableSlot
     * @example
     * // Get one TimetableSlot
     * const timetableSlot = await prisma.timetableSlot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimetableSlotFindFirstOrThrowArgs>(args?: SelectSubset<T, TimetableSlotFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimetableSlotClient<$Result.GetResult<Prisma.$TimetableSlotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TimetableSlots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimetableSlotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TimetableSlots
     * const timetableSlots = await prisma.timetableSlot.findMany()
     * 
     * // Get first 10 TimetableSlots
     * const timetableSlots = await prisma.timetableSlot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timetableSlotWithIdOnly = await prisma.timetableSlot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TimetableSlotFindManyArgs>(args?: SelectSubset<T, TimetableSlotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimetableSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TimetableSlot.
     * @param {TimetableSlotCreateArgs} args - Arguments to create a TimetableSlot.
     * @example
     * // Create one TimetableSlot
     * const TimetableSlot = await prisma.timetableSlot.create({
     *   data: {
     *     // ... data to create a TimetableSlot
     *   }
     * })
     * 
     */
    create<T extends TimetableSlotCreateArgs>(args: SelectSubset<T, TimetableSlotCreateArgs<ExtArgs>>): Prisma__TimetableSlotClient<$Result.GetResult<Prisma.$TimetableSlotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TimetableSlots.
     * @param {TimetableSlotCreateManyArgs} args - Arguments to create many TimetableSlots.
     * @example
     * // Create many TimetableSlots
     * const timetableSlot = await prisma.timetableSlot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimetableSlotCreateManyArgs>(args?: SelectSubset<T, TimetableSlotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TimetableSlot.
     * @param {TimetableSlotDeleteArgs} args - Arguments to delete one TimetableSlot.
     * @example
     * // Delete one TimetableSlot
     * const TimetableSlot = await prisma.timetableSlot.delete({
     *   where: {
     *     // ... filter to delete one TimetableSlot
     *   }
     * })
     * 
     */
    delete<T extends TimetableSlotDeleteArgs>(args: SelectSubset<T, TimetableSlotDeleteArgs<ExtArgs>>): Prisma__TimetableSlotClient<$Result.GetResult<Prisma.$TimetableSlotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TimetableSlot.
     * @param {TimetableSlotUpdateArgs} args - Arguments to update one TimetableSlot.
     * @example
     * // Update one TimetableSlot
     * const timetableSlot = await prisma.timetableSlot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimetableSlotUpdateArgs>(args: SelectSubset<T, TimetableSlotUpdateArgs<ExtArgs>>): Prisma__TimetableSlotClient<$Result.GetResult<Prisma.$TimetableSlotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TimetableSlots.
     * @param {TimetableSlotDeleteManyArgs} args - Arguments to filter TimetableSlots to delete.
     * @example
     * // Delete a few TimetableSlots
     * const { count } = await prisma.timetableSlot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimetableSlotDeleteManyArgs>(args?: SelectSubset<T, TimetableSlotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimetableSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimetableSlotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TimetableSlots
     * const timetableSlot = await prisma.timetableSlot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimetableSlotUpdateManyArgs>(args: SelectSubset<T, TimetableSlotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TimetableSlot.
     * @param {TimetableSlotUpsertArgs} args - Arguments to update or create a TimetableSlot.
     * @example
     * // Update or create a TimetableSlot
     * const timetableSlot = await prisma.timetableSlot.upsert({
     *   create: {
     *     // ... data to create a TimetableSlot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TimetableSlot we want to update
     *   }
     * })
     */
    upsert<T extends TimetableSlotUpsertArgs>(args: SelectSubset<T, TimetableSlotUpsertArgs<ExtArgs>>): Prisma__TimetableSlotClient<$Result.GetResult<Prisma.$TimetableSlotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TimetableSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimetableSlotCountArgs} args - Arguments to filter TimetableSlots to count.
     * @example
     * // Count the number of TimetableSlots
     * const count = await prisma.timetableSlot.count({
     *   where: {
     *     // ... the filter for the TimetableSlots we want to count
     *   }
     * })
    **/
    count<T extends TimetableSlotCountArgs>(
      args?: Subset<T, TimetableSlotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimetableSlotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TimetableSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimetableSlotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimetableSlotAggregateArgs>(args: Subset<T, TimetableSlotAggregateArgs>): Prisma.PrismaPromise<GetTimetableSlotAggregateType<T>>

    /**
     * Group by TimetableSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimetableSlotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimetableSlotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimetableSlotGroupByArgs['orderBy'] }
        : { orderBy?: TimetableSlotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimetableSlotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimetableSlotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TimetableSlot model
   */
  readonly fields: TimetableSlotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TimetableSlot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimetableSlotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    teacher<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attendances<T extends TimetableSlot$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, TimetableSlot$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TimetableSlot model
   */
  interface TimetableSlotFieldRefs {
    readonly id: FieldRef<"TimetableSlot", 'String'>
    readonly schoolId: FieldRef<"TimetableSlot", 'String'>
    readonly classId: FieldRef<"TimetableSlot", 'String'>
    readonly subjectId: FieldRef<"TimetableSlot", 'String'>
    readonly teacherId: FieldRef<"TimetableSlot", 'String'>
    readonly dayOfWeek: FieldRef<"TimetableSlot", 'DayOfWeek'>
    readonly startTime: FieldRef<"TimetableSlot", 'String'>
    readonly endTime: FieldRef<"TimetableSlot", 'String'>
    readonly room: FieldRef<"TimetableSlot", 'String'>
    readonly createdAt: FieldRef<"TimetableSlot", 'DateTime'>
    readonly updatedAt: FieldRef<"TimetableSlot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TimetableSlot findUnique
   */
  export type TimetableSlotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimetableSlot
     */
    select?: TimetableSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimetableSlot
     */
    omit?: TimetableSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableSlotInclude<ExtArgs> | null
    /**
     * Filter, which TimetableSlot to fetch.
     */
    where: TimetableSlotWhereUniqueInput
  }

  /**
   * TimetableSlot findUniqueOrThrow
   */
  export type TimetableSlotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimetableSlot
     */
    select?: TimetableSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimetableSlot
     */
    omit?: TimetableSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableSlotInclude<ExtArgs> | null
    /**
     * Filter, which TimetableSlot to fetch.
     */
    where: TimetableSlotWhereUniqueInput
  }

  /**
   * TimetableSlot findFirst
   */
  export type TimetableSlotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimetableSlot
     */
    select?: TimetableSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimetableSlot
     */
    omit?: TimetableSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableSlotInclude<ExtArgs> | null
    /**
     * Filter, which TimetableSlot to fetch.
     */
    where?: TimetableSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimetableSlots to fetch.
     */
    orderBy?: TimetableSlotOrderByWithRelationInput | TimetableSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimetableSlots.
     */
    cursor?: TimetableSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimetableSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimetableSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimetableSlots.
     */
    distinct?: TimetableSlotScalarFieldEnum | TimetableSlotScalarFieldEnum[]
  }

  /**
   * TimetableSlot findFirstOrThrow
   */
  export type TimetableSlotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimetableSlot
     */
    select?: TimetableSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimetableSlot
     */
    omit?: TimetableSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableSlotInclude<ExtArgs> | null
    /**
     * Filter, which TimetableSlot to fetch.
     */
    where?: TimetableSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimetableSlots to fetch.
     */
    orderBy?: TimetableSlotOrderByWithRelationInput | TimetableSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimetableSlots.
     */
    cursor?: TimetableSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimetableSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimetableSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimetableSlots.
     */
    distinct?: TimetableSlotScalarFieldEnum | TimetableSlotScalarFieldEnum[]
  }

  /**
   * TimetableSlot findMany
   */
  export type TimetableSlotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimetableSlot
     */
    select?: TimetableSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimetableSlot
     */
    omit?: TimetableSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableSlotInclude<ExtArgs> | null
    /**
     * Filter, which TimetableSlots to fetch.
     */
    where?: TimetableSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimetableSlots to fetch.
     */
    orderBy?: TimetableSlotOrderByWithRelationInput | TimetableSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TimetableSlots.
     */
    cursor?: TimetableSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimetableSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimetableSlots.
     */
    skip?: number
    distinct?: TimetableSlotScalarFieldEnum | TimetableSlotScalarFieldEnum[]
  }

  /**
   * TimetableSlot create
   */
  export type TimetableSlotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimetableSlot
     */
    select?: TimetableSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimetableSlot
     */
    omit?: TimetableSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableSlotInclude<ExtArgs> | null
    /**
     * The data needed to create a TimetableSlot.
     */
    data: XOR<TimetableSlotCreateInput, TimetableSlotUncheckedCreateInput>
  }

  /**
   * TimetableSlot createMany
   */
  export type TimetableSlotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TimetableSlots.
     */
    data: TimetableSlotCreateManyInput | TimetableSlotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TimetableSlot update
   */
  export type TimetableSlotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimetableSlot
     */
    select?: TimetableSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimetableSlot
     */
    omit?: TimetableSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableSlotInclude<ExtArgs> | null
    /**
     * The data needed to update a TimetableSlot.
     */
    data: XOR<TimetableSlotUpdateInput, TimetableSlotUncheckedUpdateInput>
    /**
     * Choose, which TimetableSlot to update.
     */
    where: TimetableSlotWhereUniqueInput
  }

  /**
   * TimetableSlot updateMany
   */
  export type TimetableSlotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TimetableSlots.
     */
    data: XOR<TimetableSlotUpdateManyMutationInput, TimetableSlotUncheckedUpdateManyInput>
    /**
     * Filter which TimetableSlots to update
     */
    where?: TimetableSlotWhereInput
    /**
     * Limit how many TimetableSlots to update.
     */
    limit?: number
  }

  /**
   * TimetableSlot upsert
   */
  export type TimetableSlotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimetableSlot
     */
    select?: TimetableSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimetableSlot
     */
    omit?: TimetableSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableSlotInclude<ExtArgs> | null
    /**
     * The filter to search for the TimetableSlot to update in case it exists.
     */
    where: TimetableSlotWhereUniqueInput
    /**
     * In case the TimetableSlot found by the `where` argument doesn't exist, create a new TimetableSlot with this data.
     */
    create: XOR<TimetableSlotCreateInput, TimetableSlotUncheckedCreateInput>
    /**
     * In case the TimetableSlot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimetableSlotUpdateInput, TimetableSlotUncheckedUpdateInput>
  }

  /**
   * TimetableSlot delete
   */
  export type TimetableSlotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimetableSlot
     */
    select?: TimetableSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimetableSlot
     */
    omit?: TimetableSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableSlotInclude<ExtArgs> | null
    /**
     * Filter which TimetableSlot to delete.
     */
    where: TimetableSlotWhereUniqueInput
  }

  /**
   * TimetableSlot deleteMany
   */
  export type TimetableSlotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimetableSlots to delete
     */
    where?: TimetableSlotWhereInput
    /**
     * Limit how many TimetableSlots to delete.
     */
    limit?: number
  }

  /**
   * TimetableSlot.attendances
   */
  export type TimetableSlot$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    where?: StudentAttendanceWhereInput
    orderBy?: StudentAttendanceOrderByWithRelationInput | StudentAttendanceOrderByWithRelationInput[]
    cursor?: StudentAttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentAttendanceScalarFieldEnum | StudentAttendanceScalarFieldEnum[]
  }

  /**
   * TimetableSlot without action
   */
  export type TimetableSlotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimetableSlot
     */
    select?: TimetableSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimetableSlot
     */
    omit?: TimetableSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableSlotInclude<ExtArgs> | null
  }


  /**
   * Model StudentAttendance
   */

  export type AggregateStudentAttendance = {
    _count: StudentAttendanceCountAggregateOutputType | null
    _min: StudentAttendanceMinAggregateOutputType | null
    _max: StudentAttendanceMaxAggregateOutputType | null
  }

  export type StudentAttendanceMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    date: Date | null
    status: $Enums.AttendanceStatus | null
    remarks: string | null
    academicYear: string | null
    term: $Enums.TermPeriod | null
    classId: string | null
    subjectId: string | null
    timetableSlotId: string | null
    recordedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentAttendanceMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    date: Date | null
    status: $Enums.AttendanceStatus | null
    remarks: string | null
    academicYear: string | null
    term: $Enums.TermPeriod | null
    classId: string | null
    subjectId: string | null
    timetableSlotId: string | null
    recordedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentAttendanceCountAggregateOutputType = {
    id: number
    studentId: number
    date: number
    status: number
    remarks: number
    academicYear: number
    term: number
    classId: number
    subjectId: number
    timetableSlotId: number
    recordedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentAttendanceMinAggregateInputType = {
    id?: true
    studentId?: true
    date?: true
    status?: true
    remarks?: true
    academicYear?: true
    term?: true
    classId?: true
    subjectId?: true
    timetableSlotId?: true
    recordedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentAttendanceMaxAggregateInputType = {
    id?: true
    studentId?: true
    date?: true
    status?: true
    remarks?: true
    academicYear?: true
    term?: true
    classId?: true
    subjectId?: true
    timetableSlotId?: true
    recordedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentAttendanceCountAggregateInputType = {
    id?: true
    studentId?: true
    date?: true
    status?: true
    remarks?: true
    academicYear?: true
    term?: true
    classId?: true
    subjectId?: true
    timetableSlotId?: true
    recordedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentAttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentAttendance to aggregate.
     */
    where?: StudentAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAttendances to fetch.
     */
    orderBy?: StudentAttendanceOrderByWithRelationInput | StudentAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentAttendances
    **/
    _count?: true | StudentAttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentAttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentAttendanceMaxAggregateInputType
  }

  export type GetStudentAttendanceAggregateType<T extends StudentAttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentAttendance[P]>
      : GetScalarType<T[P], AggregateStudentAttendance[P]>
  }




  export type StudentAttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentAttendanceWhereInput
    orderBy?: StudentAttendanceOrderByWithAggregationInput | StudentAttendanceOrderByWithAggregationInput[]
    by: StudentAttendanceScalarFieldEnum[] | StudentAttendanceScalarFieldEnum
    having?: StudentAttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentAttendanceCountAggregateInputType | true
    _min?: StudentAttendanceMinAggregateInputType
    _max?: StudentAttendanceMaxAggregateInputType
  }

  export type StudentAttendanceGroupByOutputType = {
    id: string
    studentId: string
    date: Date
    status: $Enums.AttendanceStatus
    remarks: string | null
    academicYear: string
    term: $Enums.TermPeriod
    classId: string | null
    subjectId: string | null
    timetableSlotId: string | null
    recordedById: string | null
    createdAt: Date
    updatedAt: Date
    _count: StudentAttendanceCountAggregateOutputType | null
    _min: StudentAttendanceMinAggregateOutputType | null
    _max: StudentAttendanceMaxAggregateOutputType | null
  }

  type GetStudentAttendanceGroupByPayload<T extends StudentAttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentAttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentAttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentAttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], StudentAttendanceGroupByOutputType[P]>
        }
      >
    >


  export type StudentAttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    date?: boolean
    status?: boolean
    remarks?: boolean
    academicYear?: boolean
    term?: boolean
    classId?: boolean
    subjectId?: boolean
    timetableSlotId?: boolean
    recordedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    timetableSlot?: boolean | StudentAttendance$timetableSlotArgs<ExtArgs>
    recordedBy?: boolean | StudentAttendance$recordedByArgs<ExtArgs>
  }, ExtArgs["result"]["studentAttendance"]>



  export type StudentAttendanceSelectScalar = {
    id?: boolean
    studentId?: boolean
    date?: boolean
    status?: boolean
    remarks?: boolean
    academicYear?: boolean
    term?: boolean
    classId?: boolean
    subjectId?: boolean
    timetableSlotId?: boolean
    recordedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentAttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "date" | "status" | "remarks" | "academicYear" | "term" | "classId" | "subjectId" | "timetableSlotId" | "recordedById" | "createdAt" | "updatedAt", ExtArgs["result"]["studentAttendance"]>
  export type StudentAttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    timetableSlot?: boolean | StudentAttendance$timetableSlotArgs<ExtArgs>
    recordedBy?: boolean | StudentAttendance$recordedByArgs<ExtArgs>
  }

  export type $StudentAttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentAttendance"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      timetableSlot: Prisma.$TimetableSlotPayload<ExtArgs> | null
      recordedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      date: Date
      status: $Enums.AttendanceStatus
      remarks: string | null
      academicYear: string
      term: $Enums.TermPeriod
      classId: string | null
      subjectId: string | null
      timetableSlotId: string | null
      recordedById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studentAttendance"]>
    composites: {}
  }

  type StudentAttendanceGetPayload<S extends boolean | null | undefined | StudentAttendanceDefaultArgs> = $Result.GetResult<Prisma.$StudentAttendancePayload, S>

  type StudentAttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentAttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentAttendanceCountAggregateInputType | true
    }

  export interface StudentAttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentAttendance'], meta: { name: 'StudentAttendance' } }
    /**
     * Find zero or one StudentAttendance that matches the filter.
     * @param {StudentAttendanceFindUniqueArgs} args - Arguments to find a StudentAttendance
     * @example
     * // Get one StudentAttendance
     * const studentAttendance = await prisma.studentAttendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentAttendanceFindUniqueArgs>(args: SelectSubset<T, StudentAttendanceFindUniqueArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentAttendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentAttendanceFindUniqueOrThrowArgs} args - Arguments to find a StudentAttendance
     * @example
     * // Get one StudentAttendance
     * const studentAttendance = await prisma.studentAttendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentAttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentAttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentAttendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAttendanceFindFirstArgs} args - Arguments to find a StudentAttendance
     * @example
     * // Get one StudentAttendance
     * const studentAttendance = await prisma.studentAttendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentAttendanceFindFirstArgs>(args?: SelectSubset<T, StudentAttendanceFindFirstArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentAttendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAttendanceFindFirstOrThrowArgs} args - Arguments to find a StudentAttendance
     * @example
     * // Get one StudentAttendance
     * const studentAttendance = await prisma.studentAttendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentAttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentAttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentAttendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentAttendances
     * const studentAttendances = await prisma.studentAttendance.findMany()
     * 
     * // Get first 10 StudentAttendances
     * const studentAttendances = await prisma.studentAttendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentAttendanceWithIdOnly = await prisma.studentAttendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentAttendanceFindManyArgs>(args?: SelectSubset<T, StudentAttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentAttendance.
     * @param {StudentAttendanceCreateArgs} args - Arguments to create a StudentAttendance.
     * @example
     * // Create one StudentAttendance
     * const StudentAttendance = await prisma.studentAttendance.create({
     *   data: {
     *     // ... data to create a StudentAttendance
     *   }
     * })
     * 
     */
    create<T extends StudentAttendanceCreateArgs>(args: SelectSubset<T, StudentAttendanceCreateArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentAttendances.
     * @param {StudentAttendanceCreateManyArgs} args - Arguments to create many StudentAttendances.
     * @example
     * // Create many StudentAttendances
     * const studentAttendance = await prisma.studentAttendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentAttendanceCreateManyArgs>(args?: SelectSubset<T, StudentAttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StudentAttendance.
     * @param {StudentAttendanceDeleteArgs} args - Arguments to delete one StudentAttendance.
     * @example
     * // Delete one StudentAttendance
     * const StudentAttendance = await prisma.studentAttendance.delete({
     *   where: {
     *     // ... filter to delete one StudentAttendance
     *   }
     * })
     * 
     */
    delete<T extends StudentAttendanceDeleteArgs>(args: SelectSubset<T, StudentAttendanceDeleteArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentAttendance.
     * @param {StudentAttendanceUpdateArgs} args - Arguments to update one StudentAttendance.
     * @example
     * // Update one StudentAttendance
     * const studentAttendance = await prisma.studentAttendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentAttendanceUpdateArgs>(args: SelectSubset<T, StudentAttendanceUpdateArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentAttendances.
     * @param {StudentAttendanceDeleteManyArgs} args - Arguments to filter StudentAttendances to delete.
     * @example
     * // Delete a few StudentAttendances
     * const { count } = await prisma.studentAttendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentAttendanceDeleteManyArgs>(args?: SelectSubset<T, StudentAttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentAttendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentAttendances
     * const studentAttendance = await prisma.studentAttendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentAttendanceUpdateManyArgs>(args: SelectSubset<T, StudentAttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentAttendance.
     * @param {StudentAttendanceUpsertArgs} args - Arguments to update or create a StudentAttendance.
     * @example
     * // Update or create a StudentAttendance
     * const studentAttendance = await prisma.studentAttendance.upsert({
     *   create: {
     *     // ... data to create a StudentAttendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentAttendance we want to update
     *   }
     * })
     */
    upsert<T extends StudentAttendanceUpsertArgs>(args: SelectSubset<T, StudentAttendanceUpsertArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentAttendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAttendanceCountArgs} args - Arguments to filter StudentAttendances to count.
     * @example
     * // Count the number of StudentAttendances
     * const count = await prisma.studentAttendance.count({
     *   where: {
     *     // ... the filter for the StudentAttendances we want to count
     *   }
     * })
    **/
    count<T extends StudentAttendanceCountArgs>(
      args?: Subset<T, StudentAttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentAttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentAttendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAttendanceAggregateArgs>(args: Subset<T, StudentAttendanceAggregateArgs>): Prisma.PrismaPromise<GetStudentAttendanceAggregateType<T>>

    /**
     * Group by StudentAttendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentAttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentAttendanceGroupByArgs['orderBy'] }
        : { orderBy?: StudentAttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentAttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentAttendance model
   */
  readonly fields: StudentAttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentAttendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentAttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    timetableSlot<T extends StudentAttendance$timetableSlotArgs<ExtArgs> = {}>(args?: Subset<T, StudentAttendance$timetableSlotArgs<ExtArgs>>): Prisma__TimetableSlotClient<$Result.GetResult<Prisma.$TimetableSlotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    recordedBy<T extends StudentAttendance$recordedByArgs<ExtArgs> = {}>(args?: Subset<T, StudentAttendance$recordedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentAttendance model
   */
  interface StudentAttendanceFieldRefs {
    readonly id: FieldRef<"StudentAttendance", 'String'>
    readonly studentId: FieldRef<"StudentAttendance", 'String'>
    readonly date: FieldRef<"StudentAttendance", 'DateTime'>
    readonly status: FieldRef<"StudentAttendance", 'AttendanceStatus'>
    readonly remarks: FieldRef<"StudentAttendance", 'String'>
    readonly academicYear: FieldRef<"StudentAttendance", 'String'>
    readonly term: FieldRef<"StudentAttendance", 'TermPeriod'>
    readonly classId: FieldRef<"StudentAttendance", 'String'>
    readonly subjectId: FieldRef<"StudentAttendance", 'String'>
    readonly timetableSlotId: FieldRef<"StudentAttendance", 'String'>
    readonly recordedById: FieldRef<"StudentAttendance", 'String'>
    readonly createdAt: FieldRef<"StudentAttendance", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentAttendance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentAttendance findUnique
   */
  export type StudentAttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which StudentAttendance to fetch.
     */
    where: StudentAttendanceWhereUniqueInput
  }

  /**
   * StudentAttendance findUniqueOrThrow
   */
  export type StudentAttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which StudentAttendance to fetch.
     */
    where: StudentAttendanceWhereUniqueInput
  }

  /**
   * StudentAttendance findFirst
   */
  export type StudentAttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which StudentAttendance to fetch.
     */
    where?: StudentAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAttendances to fetch.
     */
    orderBy?: StudentAttendanceOrderByWithRelationInput | StudentAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentAttendances.
     */
    cursor?: StudentAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentAttendances.
     */
    distinct?: StudentAttendanceScalarFieldEnum | StudentAttendanceScalarFieldEnum[]
  }

  /**
   * StudentAttendance findFirstOrThrow
   */
  export type StudentAttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which StudentAttendance to fetch.
     */
    where?: StudentAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAttendances to fetch.
     */
    orderBy?: StudentAttendanceOrderByWithRelationInput | StudentAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentAttendances.
     */
    cursor?: StudentAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentAttendances.
     */
    distinct?: StudentAttendanceScalarFieldEnum | StudentAttendanceScalarFieldEnum[]
  }

  /**
   * StudentAttendance findMany
   */
  export type StudentAttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which StudentAttendances to fetch.
     */
    where?: StudentAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAttendances to fetch.
     */
    orderBy?: StudentAttendanceOrderByWithRelationInput | StudentAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentAttendances.
     */
    cursor?: StudentAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAttendances.
     */
    skip?: number
    distinct?: StudentAttendanceScalarFieldEnum | StudentAttendanceScalarFieldEnum[]
  }

  /**
   * StudentAttendance create
   */
  export type StudentAttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentAttendance.
     */
    data: XOR<StudentAttendanceCreateInput, StudentAttendanceUncheckedCreateInput>
  }

  /**
   * StudentAttendance createMany
   */
  export type StudentAttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentAttendances.
     */
    data: StudentAttendanceCreateManyInput | StudentAttendanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentAttendance update
   */
  export type StudentAttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentAttendance.
     */
    data: XOR<StudentAttendanceUpdateInput, StudentAttendanceUncheckedUpdateInput>
    /**
     * Choose, which StudentAttendance to update.
     */
    where: StudentAttendanceWhereUniqueInput
  }

  /**
   * StudentAttendance updateMany
   */
  export type StudentAttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentAttendances.
     */
    data: XOR<StudentAttendanceUpdateManyMutationInput, StudentAttendanceUncheckedUpdateManyInput>
    /**
     * Filter which StudentAttendances to update
     */
    where?: StudentAttendanceWhereInput
    /**
     * Limit how many StudentAttendances to update.
     */
    limit?: number
  }

  /**
   * StudentAttendance upsert
   */
  export type StudentAttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentAttendance to update in case it exists.
     */
    where: StudentAttendanceWhereUniqueInput
    /**
     * In case the StudentAttendance found by the `where` argument doesn't exist, create a new StudentAttendance with this data.
     */
    create: XOR<StudentAttendanceCreateInput, StudentAttendanceUncheckedCreateInput>
    /**
     * In case the StudentAttendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentAttendanceUpdateInput, StudentAttendanceUncheckedUpdateInput>
  }

  /**
   * StudentAttendance delete
   */
  export type StudentAttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * Filter which StudentAttendance to delete.
     */
    where: StudentAttendanceWhereUniqueInput
  }

  /**
   * StudentAttendance deleteMany
   */
  export type StudentAttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentAttendances to delete
     */
    where?: StudentAttendanceWhereInput
    /**
     * Limit how many StudentAttendances to delete.
     */
    limit?: number
  }

  /**
   * StudentAttendance.timetableSlot
   */
  export type StudentAttendance$timetableSlotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimetableSlot
     */
    select?: TimetableSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimetableSlot
     */
    omit?: TimetableSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableSlotInclude<ExtArgs> | null
    where?: TimetableSlotWhereInput
  }

  /**
   * StudentAttendance.recordedBy
   */
  export type StudentAttendance$recordedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * StudentAttendance without action
   */
  export type StudentAttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
  }


  /**
   * Model Assignment
   */

  export type AggregateAssignment = {
    _count: AssignmentCountAggregateOutputType | null
    _avg: AssignmentAvgAggregateOutputType | null
    _sum: AssignmentSumAggregateOutputType | null
    _min: AssignmentMinAggregateOutputType | null
    _max: AssignmentMaxAggregateOutputType | null
  }

  export type AssignmentAvgAggregateOutputType = {
    maxPoints: number | null
  }

  export type AssignmentSumAggregateOutputType = {
    maxPoints: number | null
  }

  export type AssignmentMinAggregateOutputType = {
    id: string | null
    schoolId: string | null
    classId: string | null
    subjectId: string | null
    teacherId: string | null
    title: string | null
    description: string | null
    maxPoints: number | null
    dueDate: Date | null
    academicYear: string | null
    term: $Enums.TermPeriod | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssignmentMaxAggregateOutputType = {
    id: string | null
    schoolId: string | null
    classId: string | null
    subjectId: string | null
    teacherId: string | null
    title: string | null
    description: string | null
    maxPoints: number | null
    dueDate: Date | null
    academicYear: string | null
    term: $Enums.TermPeriod | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssignmentCountAggregateOutputType = {
    id: number
    schoolId: number
    classId: number
    subjectId: number
    teacherId: number
    title: number
    description: number
    maxPoints: number
    dueDate: number
    academicYear: number
    term: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AssignmentAvgAggregateInputType = {
    maxPoints?: true
  }

  export type AssignmentSumAggregateInputType = {
    maxPoints?: true
  }

  export type AssignmentMinAggregateInputType = {
    id?: true
    schoolId?: true
    classId?: true
    subjectId?: true
    teacherId?: true
    title?: true
    description?: true
    maxPoints?: true
    dueDate?: true
    academicYear?: true
    term?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssignmentMaxAggregateInputType = {
    id?: true
    schoolId?: true
    classId?: true
    subjectId?: true
    teacherId?: true
    title?: true
    description?: true
    maxPoints?: true
    dueDate?: true
    academicYear?: true
    term?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssignmentCountAggregateInputType = {
    id?: true
    schoolId?: true
    classId?: true
    subjectId?: true
    teacherId?: true
    title?: true
    description?: true
    maxPoints?: true
    dueDate?: true
    academicYear?: true
    term?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assignment to aggregate.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assignments
    **/
    _count?: true | AssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssignmentMaxAggregateInputType
  }

  export type GetAssignmentAggregateType<T extends AssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssignment[P]>
      : GetScalarType<T[P], AggregateAssignment[P]>
  }




  export type AssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithAggregationInput | AssignmentOrderByWithAggregationInput[]
    by: AssignmentScalarFieldEnum[] | AssignmentScalarFieldEnum
    having?: AssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssignmentCountAggregateInputType | true
    _avg?: AssignmentAvgAggregateInputType
    _sum?: AssignmentSumAggregateInputType
    _min?: AssignmentMinAggregateInputType
    _max?: AssignmentMaxAggregateInputType
  }

  export type AssignmentGroupByOutputType = {
    id: string
    schoolId: string
    classId: string
    subjectId: string
    teacherId: string
    title: string
    description: string | null
    maxPoints: number | null
    dueDate: Date | null
    academicYear: string
    term: $Enums.TermPeriod
    createdAt: Date
    updatedAt: Date
    _count: AssignmentCountAggregateOutputType | null
    _avg: AssignmentAvgAggregateOutputType | null
    _sum: AssignmentSumAggregateOutputType | null
    _min: AssignmentMinAggregateOutputType | null
    _max: AssignmentMaxAggregateOutputType | null
  }

  type GetAssignmentGroupByPayload<T extends AssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], AssignmentGroupByOutputType[P]>
        }
      >
    >


  export type AssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    classId?: boolean
    subjectId?: boolean
    teacherId?: boolean
    title?: boolean
    description?: boolean
    maxPoints?: boolean
    dueDate?: boolean
    academicYear?: boolean
    term?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    grades?: boolean | Assignment$gradesArgs<ExtArgs>
    _count?: boolean | AssignmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignment"]>



  export type AssignmentSelectScalar = {
    id?: boolean
    schoolId?: boolean
    classId?: boolean
    subjectId?: boolean
    teacherId?: boolean
    title?: boolean
    description?: boolean
    maxPoints?: boolean
    dueDate?: boolean
    academicYear?: boolean
    term?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "schoolId" | "classId" | "subjectId" | "teacherId" | "title" | "description" | "maxPoints" | "dueDate" | "academicYear" | "term" | "createdAt" | "updatedAt", ExtArgs["result"]["assignment"]>
  export type AssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    grades?: boolean | Assignment$gradesArgs<ExtArgs>
    _count?: boolean | AssignmentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Assignment"
    objects: {
      class: Prisma.$ClassPayload<ExtArgs>
      subject: Prisma.$SubjectPayload<ExtArgs>
      teacher: Prisma.$TeacherPayload<ExtArgs>
      grades: Prisma.$StudentGradePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      schoolId: string
      classId: string
      subjectId: string
      teacherId: string
      title: string
      description: string | null
      maxPoints: number | null
      dueDate: Date | null
      academicYear: string
      term: $Enums.TermPeriod
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["assignment"]>
    composites: {}
  }

  type AssignmentGetPayload<S extends boolean | null | undefined | AssignmentDefaultArgs> = $Result.GetResult<Prisma.$AssignmentPayload, S>

  type AssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssignmentCountAggregateInputType | true
    }

  export interface AssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Assignment'], meta: { name: 'Assignment' } }
    /**
     * Find zero or one Assignment that matches the filter.
     * @param {AssignmentFindUniqueArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssignmentFindUniqueArgs>(args: SelectSubset<T, AssignmentFindUniqueArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Assignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssignmentFindUniqueOrThrowArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindFirstArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssignmentFindFirstArgs>(args?: SelectSubset<T, AssignmentFindFirstArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindFirstOrThrowArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assignments
     * const assignments = await prisma.assignment.findMany()
     * 
     * // Get first 10 Assignments
     * const assignments = await prisma.assignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assignmentWithIdOnly = await prisma.assignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssignmentFindManyArgs>(args?: SelectSubset<T, AssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Assignment.
     * @param {AssignmentCreateArgs} args - Arguments to create a Assignment.
     * @example
     * // Create one Assignment
     * const Assignment = await prisma.assignment.create({
     *   data: {
     *     // ... data to create a Assignment
     *   }
     * })
     * 
     */
    create<T extends AssignmentCreateArgs>(args: SelectSubset<T, AssignmentCreateArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Assignments.
     * @param {AssignmentCreateManyArgs} args - Arguments to create many Assignments.
     * @example
     * // Create many Assignments
     * const assignment = await prisma.assignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssignmentCreateManyArgs>(args?: SelectSubset<T, AssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Assignment.
     * @param {AssignmentDeleteArgs} args - Arguments to delete one Assignment.
     * @example
     * // Delete one Assignment
     * const Assignment = await prisma.assignment.delete({
     *   where: {
     *     // ... filter to delete one Assignment
     *   }
     * })
     * 
     */
    delete<T extends AssignmentDeleteArgs>(args: SelectSubset<T, AssignmentDeleteArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Assignment.
     * @param {AssignmentUpdateArgs} args - Arguments to update one Assignment.
     * @example
     * // Update one Assignment
     * const assignment = await prisma.assignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssignmentUpdateArgs>(args: SelectSubset<T, AssignmentUpdateArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Assignments.
     * @param {AssignmentDeleteManyArgs} args - Arguments to filter Assignments to delete.
     * @example
     * // Delete a few Assignments
     * const { count } = await prisma.assignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssignmentDeleteManyArgs>(args?: SelectSubset<T, AssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assignments
     * const assignment = await prisma.assignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssignmentUpdateManyArgs>(args: SelectSubset<T, AssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Assignment.
     * @param {AssignmentUpsertArgs} args - Arguments to update or create a Assignment.
     * @example
     * // Update or create a Assignment
     * const assignment = await prisma.assignment.upsert({
     *   create: {
     *     // ... data to create a Assignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Assignment we want to update
     *   }
     * })
     */
    upsert<T extends AssignmentUpsertArgs>(args: SelectSubset<T, AssignmentUpsertArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentCountArgs} args - Arguments to filter Assignments to count.
     * @example
     * // Count the number of Assignments
     * const count = await prisma.assignment.count({
     *   where: {
     *     // ... the filter for the Assignments we want to count
     *   }
     * })
    **/
    count<T extends AssignmentCountArgs>(
      args?: Subset<T, AssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Assignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssignmentAggregateArgs>(args: Subset<T, AssignmentAggregateArgs>): Prisma.PrismaPromise<GetAssignmentAggregateType<T>>

    /**
     * Group by Assignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssignmentGroupByArgs['orderBy'] }
        : { orderBy?: AssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Assignment model
   */
  readonly fields: AssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Assignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    teacher<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    grades<T extends Assignment$gradesArgs<ExtArgs> = {}>(args?: Subset<T, Assignment$gradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentGradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Assignment model
   */
  interface AssignmentFieldRefs {
    readonly id: FieldRef<"Assignment", 'String'>
    readonly schoolId: FieldRef<"Assignment", 'String'>
    readonly classId: FieldRef<"Assignment", 'String'>
    readonly subjectId: FieldRef<"Assignment", 'String'>
    readonly teacherId: FieldRef<"Assignment", 'String'>
    readonly title: FieldRef<"Assignment", 'String'>
    readonly description: FieldRef<"Assignment", 'String'>
    readonly maxPoints: FieldRef<"Assignment", 'Float'>
    readonly dueDate: FieldRef<"Assignment", 'DateTime'>
    readonly academicYear: FieldRef<"Assignment", 'String'>
    readonly term: FieldRef<"Assignment", 'TermPeriod'>
    readonly createdAt: FieldRef<"Assignment", 'DateTime'>
    readonly updatedAt: FieldRef<"Assignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Assignment findUnique
   */
  export type AssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment findUniqueOrThrow
   */
  export type AssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment findFirst
   */
  export type AssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assignments.
     */
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment findFirstOrThrow
   */
  export type AssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assignments.
     */
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment findMany
   */
  export type AssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignments to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment create
   */
  export type AssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Assignment.
     */
    data: XOR<AssignmentCreateInput, AssignmentUncheckedCreateInput>
  }

  /**
   * Assignment createMany
   */
  export type AssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assignments.
     */
    data: AssignmentCreateManyInput | AssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Assignment update
   */
  export type AssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Assignment.
     */
    data: XOR<AssignmentUpdateInput, AssignmentUncheckedUpdateInput>
    /**
     * Choose, which Assignment to update.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment updateMany
   */
  export type AssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assignments.
     */
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyInput>
    /**
     * Filter which Assignments to update
     */
    where?: AssignmentWhereInput
    /**
     * Limit how many Assignments to update.
     */
    limit?: number
  }

  /**
   * Assignment upsert
   */
  export type AssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Assignment to update in case it exists.
     */
    where: AssignmentWhereUniqueInput
    /**
     * In case the Assignment found by the `where` argument doesn't exist, create a new Assignment with this data.
     */
    create: XOR<AssignmentCreateInput, AssignmentUncheckedCreateInput>
    /**
     * In case the Assignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssignmentUpdateInput, AssignmentUncheckedUpdateInput>
  }

  /**
   * Assignment delete
   */
  export type AssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter which Assignment to delete.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment deleteMany
   */
  export type AssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assignments to delete
     */
    where?: AssignmentWhereInput
    /**
     * Limit how many Assignments to delete.
     */
    limit?: number
  }

  /**
   * Assignment.grades
   */
  export type Assignment$gradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentGrade
     */
    select?: StudentGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentGrade
     */
    omit?: StudentGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentGradeInclude<ExtArgs> | null
    where?: StudentGradeWhereInput
    orderBy?: StudentGradeOrderByWithRelationInput | StudentGradeOrderByWithRelationInput[]
    cursor?: StudentGradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentGradeScalarFieldEnum | StudentGradeScalarFieldEnum[]
  }

  /**
   * Assignment without action
   */
  export type AssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
  }


  /**
   * Model StudentGrade
   */

  export type AggregateStudentGrade = {
    _count: StudentGradeCountAggregateOutputType | null
    _avg: StudentGradeAvgAggregateOutputType | null
    _sum: StudentGradeSumAggregateOutputType | null
    _min: StudentGradeMinAggregateOutputType | null
    _max: StudentGradeMaxAggregateOutputType | null
  }

  export type StudentGradeAvgAggregateOutputType = {
    numericValue: number | null
  }

  export type StudentGradeSumAggregateOutputType = {
    numericValue: number | null
  }

  export type StudentGradeMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    subjectId: string | null
    assignmentId: string | null
    teacherId: string | null
    grade: string | null
    numericValue: number | null
    comments: string | null
    academicYear: string | null
    term: $Enums.TermPeriod | null
    dateRecorded: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentGradeMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    subjectId: string | null
    assignmentId: string | null
    teacherId: string | null
    grade: string | null
    numericValue: number | null
    comments: string | null
    academicYear: string | null
    term: $Enums.TermPeriod | null
    dateRecorded: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentGradeCountAggregateOutputType = {
    id: number
    studentId: number
    subjectId: number
    assignmentId: number
    teacherId: number
    grade: number
    numericValue: number
    comments: number
    academicYear: number
    term: number
    dateRecorded: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentGradeAvgAggregateInputType = {
    numericValue?: true
  }

  export type StudentGradeSumAggregateInputType = {
    numericValue?: true
  }

  export type StudentGradeMinAggregateInputType = {
    id?: true
    studentId?: true
    subjectId?: true
    assignmentId?: true
    teacherId?: true
    grade?: true
    numericValue?: true
    comments?: true
    academicYear?: true
    term?: true
    dateRecorded?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentGradeMaxAggregateInputType = {
    id?: true
    studentId?: true
    subjectId?: true
    assignmentId?: true
    teacherId?: true
    grade?: true
    numericValue?: true
    comments?: true
    academicYear?: true
    term?: true
    dateRecorded?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentGradeCountAggregateInputType = {
    id?: true
    studentId?: true
    subjectId?: true
    assignmentId?: true
    teacherId?: true
    grade?: true
    numericValue?: true
    comments?: true
    academicYear?: true
    term?: true
    dateRecorded?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentGradeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentGrade to aggregate.
     */
    where?: StudentGradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentGrades to fetch.
     */
    orderBy?: StudentGradeOrderByWithRelationInput | StudentGradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentGradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentGrades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentGrades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentGrades
    **/
    _count?: true | StudentGradeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentGradeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentGradeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentGradeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentGradeMaxAggregateInputType
  }

  export type GetStudentGradeAggregateType<T extends StudentGradeAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentGrade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentGrade[P]>
      : GetScalarType<T[P], AggregateStudentGrade[P]>
  }




  export type StudentGradeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentGradeWhereInput
    orderBy?: StudentGradeOrderByWithAggregationInput | StudentGradeOrderByWithAggregationInput[]
    by: StudentGradeScalarFieldEnum[] | StudentGradeScalarFieldEnum
    having?: StudentGradeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentGradeCountAggregateInputType | true
    _avg?: StudentGradeAvgAggregateInputType
    _sum?: StudentGradeSumAggregateInputType
    _min?: StudentGradeMinAggregateInputType
    _max?: StudentGradeMaxAggregateInputType
  }

  export type StudentGradeGroupByOutputType = {
    id: string
    studentId: string
    subjectId: string
    assignmentId: string | null
    teacherId: string | null
    grade: string
    numericValue: number | null
    comments: string | null
    academicYear: string
    term: $Enums.TermPeriod
    dateRecorded: Date
    createdAt: Date
    updatedAt: Date
    _count: StudentGradeCountAggregateOutputType | null
    _avg: StudentGradeAvgAggregateOutputType | null
    _sum: StudentGradeSumAggregateOutputType | null
    _min: StudentGradeMinAggregateOutputType | null
    _max: StudentGradeMaxAggregateOutputType | null
  }

  type GetStudentGradeGroupByPayload<T extends StudentGradeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGradeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGradeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGradeGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGradeGroupByOutputType[P]>
        }
      >
    >


  export type StudentGradeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    subjectId?: boolean
    assignmentId?: boolean
    teacherId?: boolean
    grade?: boolean
    numericValue?: boolean
    comments?: boolean
    academicYear?: boolean
    term?: boolean
    dateRecorded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    assignment?: boolean | StudentGrade$assignmentArgs<ExtArgs>
    teacher?: boolean | StudentGrade$teacherArgs<ExtArgs>
  }, ExtArgs["result"]["studentGrade"]>



  export type StudentGradeSelectScalar = {
    id?: boolean
    studentId?: boolean
    subjectId?: boolean
    assignmentId?: boolean
    teacherId?: boolean
    grade?: boolean
    numericValue?: boolean
    comments?: boolean
    academicYear?: boolean
    term?: boolean
    dateRecorded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentGradeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "subjectId" | "assignmentId" | "teacherId" | "grade" | "numericValue" | "comments" | "academicYear" | "term" | "dateRecorded" | "createdAt" | "updatedAt", ExtArgs["result"]["studentGrade"]>
  export type StudentGradeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    assignment?: boolean | StudentGrade$assignmentArgs<ExtArgs>
    teacher?: boolean | StudentGrade$teacherArgs<ExtArgs>
  }

  export type $StudentGradePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentGrade"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      subject: Prisma.$SubjectPayload<ExtArgs>
      assignment: Prisma.$AssignmentPayload<ExtArgs> | null
      teacher: Prisma.$TeacherPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      subjectId: string
      assignmentId: string | null
      teacherId: string | null
      grade: string
      numericValue: number | null
      comments: string | null
      academicYear: string
      term: $Enums.TermPeriod
      dateRecorded: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studentGrade"]>
    composites: {}
  }

  type StudentGradeGetPayload<S extends boolean | null | undefined | StudentGradeDefaultArgs> = $Result.GetResult<Prisma.$StudentGradePayload, S>

  type StudentGradeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentGradeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentGradeCountAggregateInputType | true
    }

  export interface StudentGradeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentGrade'], meta: { name: 'StudentGrade' } }
    /**
     * Find zero or one StudentGrade that matches the filter.
     * @param {StudentGradeFindUniqueArgs} args - Arguments to find a StudentGrade
     * @example
     * // Get one StudentGrade
     * const studentGrade = await prisma.studentGrade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentGradeFindUniqueArgs>(args: SelectSubset<T, StudentGradeFindUniqueArgs<ExtArgs>>): Prisma__StudentGradeClient<$Result.GetResult<Prisma.$StudentGradePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentGrade that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentGradeFindUniqueOrThrowArgs} args - Arguments to find a StudentGrade
     * @example
     * // Get one StudentGrade
     * const studentGrade = await prisma.studentGrade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentGradeFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentGradeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentGradeClient<$Result.GetResult<Prisma.$StudentGradePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentGrade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGradeFindFirstArgs} args - Arguments to find a StudentGrade
     * @example
     * // Get one StudentGrade
     * const studentGrade = await prisma.studentGrade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentGradeFindFirstArgs>(args?: SelectSubset<T, StudentGradeFindFirstArgs<ExtArgs>>): Prisma__StudentGradeClient<$Result.GetResult<Prisma.$StudentGradePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentGrade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGradeFindFirstOrThrowArgs} args - Arguments to find a StudentGrade
     * @example
     * // Get one StudentGrade
     * const studentGrade = await prisma.studentGrade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentGradeFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentGradeFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentGradeClient<$Result.GetResult<Prisma.$StudentGradePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentGrades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGradeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentGrades
     * const studentGrades = await prisma.studentGrade.findMany()
     * 
     * // Get first 10 StudentGrades
     * const studentGrades = await prisma.studentGrade.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentGradeWithIdOnly = await prisma.studentGrade.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentGradeFindManyArgs>(args?: SelectSubset<T, StudentGradeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentGradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentGrade.
     * @param {StudentGradeCreateArgs} args - Arguments to create a StudentGrade.
     * @example
     * // Create one StudentGrade
     * const StudentGrade = await prisma.studentGrade.create({
     *   data: {
     *     // ... data to create a StudentGrade
     *   }
     * })
     * 
     */
    create<T extends StudentGradeCreateArgs>(args: SelectSubset<T, StudentGradeCreateArgs<ExtArgs>>): Prisma__StudentGradeClient<$Result.GetResult<Prisma.$StudentGradePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentGrades.
     * @param {StudentGradeCreateManyArgs} args - Arguments to create many StudentGrades.
     * @example
     * // Create many StudentGrades
     * const studentGrade = await prisma.studentGrade.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentGradeCreateManyArgs>(args?: SelectSubset<T, StudentGradeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StudentGrade.
     * @param {StudentGradeDeleteArgs} args - Arguments to delete one StudentGrade.
     * @example
     * // Delete one StudentGrade
     * const StudentGrade = await prisma.studentGrade.delete({
     *   where: {
     *     // ... filter to delete one StudentGrade
     *   }
     * })
     * 
     */
    delete<T extends StudentGradeDeleteArgs>(args: SelectSubset<T, StudentGradeDeleteArgs<ExtArgs>>): Prisma__StudentGradeClient<$Result.GetResult<Prisma.$StudentGradePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentGrade.
     * @param {StudentGradeUpdateArgs} args - Arguments to update one StudentGrade.
     * @example
     * // Update one StudentGrade
     * const studentGrade = await prisma.studentGrade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentGradeUpdateArgs>(args: SelectSubset<T, StudentGradeUpdateArgs<ExtArgs>>): Prisma__StudentGradeClient<$Result.GetResult<Prisma.$StudentGradePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentGrades.
     * @param {StudentGradeDeleteManyArgs} args - Arguments to filter StudentGrades to delete.
     * @example
     * // Delete a few StudentGrades
     * const { count } = await prisma.studentGrade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentGradeDeleteManyArgs>(args?: SelectSubset<T, StudentGradeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentGrades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGradeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentGrades
     * const studentGrade = await prisma.studentGrade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentGradeUpdateManyArgs>(args: SelectSubset<T, StudentGradeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentGrade.
     * @param {StudentGradeUpsertArgs} args - Arguments to update or create a StudentGrade.
     * @example
     * // Update or create a StudentGrade
     * const studentGrade = await prisma.studentGrade.upsert({
     *   create: {
     *     // ... data to create a StudentGrade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentGrade we want to update
     *   }
     * })
     */
    upsert<T extends StudentGradeUpsertArgs>(args: SelectSubset<T, StudentGradeUpsertArgs<ExtArgs>>): Prisma__StudentGradeClient<$Result.GetResult<Prisma.$StudentGradePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentGrades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGradeCountArgs} args - Arguments to filter StudentGrades to count.
     * @example
     * // Count the number of StudentGrades
     * const count = await prisma.studentGrade.count({
     *   where: {
     *     // ... the filter for the StudentGrades we want to count
     *   }
     * })
    **/
    count<T extends StudentGradeCountArgs>(
      args?: Subset<T, StudentGradeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentGradeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentGrade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGradeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentGradeAggregateArgs>(args: Subset<T, StudentGradeAggregateArgs>): Prisma.PrismaPromise<GetStudentGradeAggregateType<T>>

    /**
     * Group by StudentGrade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGradeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGradeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGradeGroupByArgs['orderBy'] }
        : { orderBy?: StudentGradeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGradeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGradeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentGrade model
   */
  readonly fields: StudentGradeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentGrade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentGradeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignment<T extends StudentGrade$assignmentArgs<ExtArgs> = {}>(args?: Subset<T, StudentGrade$assignmentArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    teacher<T extends StudentGrade$teacherArgs<ExtArgs> = {}>(args?: Subset<T, StudentGrade$teacherArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentGrade model
   */
  interface StudentGradeFieldRefs {
    readonly id: FieldRef<"StudentGrade", 'String'>
    readonly studentId: FieldRef<"StudentGrade", 'String'>
    readonly subjectId: FieldRef<"StudentGrade", 'String'>
    readonly assignmentId: FieldRef<"StudentGrade", 'String'>
    readonly teacherId: FieldRef<"StudentGrade", 'String'>
    readonly grade: FieldRef<"StudentGrade", 'String'>
    readonly numericValue: FieldRef<"StudentGrade", 'Float'>
    readonly comments: FieldRef<"StudentGrade", 'String'>
    readonly academicYear: FieldRef<"StudentGrade", 'String'>
    readonly term: FieldRef<"StudentGrade", 'TermPeriod'>
    readonly dateRecorded: FieldRef<"StudentGrade", 'DateTime'>
    readonly createdAt: FieldRef<"StudentGrade", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentGrade", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentGrade findUnique
   */
  export type StudentGradeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentGrade
     */
    select?: StudentGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentGrade
     */
    omit?: StudentGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentGradeInclude<ExtArgs> | null
    /**
     * Filter, which StudentGrade to fetch.
     */
    where: StudentGradeWhereUniqueInput
  }

  /**
   * StudentGrade findUniqueOrThrow
   */
  export type StudentGradeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentGrade
     */
    select?: StudentGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentGrade
     */
    omit?: StudentGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentGradeInclude<ExtArgs> | null
    /**
     * Filter, which StudentGrade to fetch.
     */
    where: StudentGradeWhereUniqueInput
  }

  /**
   * StudentGrade findFirst
   */
  export type StudentGradeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentGrade
     */
    select?: StudentGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentGrade
     */
    omit?: StudentGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentGradeInclude<ExtArgs> | null
    /**
     * Filter, which StudentGrade to fetch.
     */
    where?: StudentGradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentGrades to fetch.
     */
    orderBy?: StudentGradeOrderByWithRelationInput | StudentGradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentGrades.
     */
    cursor?: StudentGradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentGrades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentGrades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentGrades.
     */
    distinct?: StudentGradeScalarFieldEnum | StudentGradeScalarFieldEnum[]
  }

  /**
   * StudentGrade findFirstOrThrow
   */
  export type StudentGradeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentGrade
     */
    select?: StudentGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentGrade
     */
    omit?: StudentGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentGradeInclude<ExtArgs> | null
    /**
     * Filter, which StudentGrade to fetch.
     */
    where?: StudentGradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentGrades to fetch.
     */
    orderBy?: StudentGradeOrderByWithRelationInput | StudentGradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentGrades.
     */
    cursor?: StudentGradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentGrades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentGrades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentGrades.
     */
    distinct?: StudentGradeScalarFieldEnum | StudentGradeScalarFieldEnum[]
  }

  /**
   * StudentGrade findMany
   */
  export type StudentGradeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentGrade
     */
    select?: StudentGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentGrade
     */
    omit?: StudentGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentGradeInclude<ExtArgs> | null
    /**
     * Filter, which StudentGrades to fetch.
     */
    where?: StudentGradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentGrades to fetch.
     */
    orderBy?: StudentGradeOrderByWithRelationInput | StudentGradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentGrades.
     */
    cursor?: StudentGradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentGrades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentGrades.
     */
    skip?: number
    distinct?: StudentGradeScalarFieldEnum | StudentGradeScalarFieldEnum[]
  }

  /**
   * StudentGrade create
   */
  export type StudentGradeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentGrade
     */
    select?: StudentGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentGrade
     */
    omit?: StudentGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentGradeInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentGrade.
     */
    data: XOR<StudentGradeCreateInput, StudentGradeUncheckedCreateInput>
  }

  /**
   * StudentGrade createMany
   */
  export type StudentGradeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentGrades.
     */
    data: StudentGradeCreateManyInput | StudentGradeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentGrade update
   */
  export type StudentGradeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentGrade
     */
    select?: StudentGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentGrade
     */
    omit?: StudentGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentGradeInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentGrade.
     */
    data: XOR<StudentGradeUpdateInput, StudentGradeUncheckedUpdateInput>
    /**
     * Choose, which StudentGrade to update.
     */
    where: StudentGradeWhereUniqueInput
  }

  /**
   * StudentGrade updateMany
   */
  export type StudentGradeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentGrades.
     */
    data: XOR<StudentGradeUpdateManyMutationInput, StudentGradeUncheckedUpdateManyInput>
    /**
     * Filter which StudentGrades to update
     */
    where?: StudentGradeWhereInput
    /**
     * Limit how many StudentGrades to update.
     */
    limit?: number
  }

  /**
   * StudentGrade upsert
   */
  export type StudentGradeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentGrade
     */
    select?: StudentGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentGrade
     */
    omit?: StudentGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentGradeInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentGrade to update in case it exists.
     */
    where: StudentGradeWhereUniqueInput
    /**
     * In case the StudentGrade found by the `where` argument doesn't exist, create a new StudentGrade with this data.
     */
    create: XOR<StudentGradeCreateInput, StudentGradeUncheckedCreateInput>
    /**
     * In case the StudentGrade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentGradeUpdateInput, StudentGradeUncheckedUpdateInput>
  }

  /**
   * StudentGrade delete
   */
  export type StudentGradeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentGrade
     */
    select?: StudentGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentGrade
     */
    omit?: StudentGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentGradeInclude<ExtArgs> | null
    /**
     * Filter which StudentGrade to delete.
     */
    where: StudentGradeWhereUniqueInput
  }

  /**
   * StudentGrade deleteMany
   */
  export type StudentGradeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentGrades to delete
     */
    where?: StudentGradeWhereInput
    /**
     * Limit how many StudentGrades to delete.
     */
    limit?: number
  }

  /**
   * StudentGrade.assignment
   */
  export type StudentGrade$assignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    where?: AssignmentWhereInput
  }

  /**
   * StudentGrade.teacher
   */
  export type StudentGrade$teacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    where?: TeacherWhereInput
  }

  /**
   * StudentGrade without action
   */
  export type StudentGradeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentGrade
     */
    select?: StudentGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentGrade
     */
    omit?: StudentGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentGradeInclude<ExtArgs> | null
  }


  /**
   * Model FeeStructure
   */

  export type AggregateFeeStructure = {
    _count: FeeStructureCountAggregateOutputType | null
    _avg: FeeStructureAvgAggregateOutputType | null
    _sum: FeeStructureSumAggregateOutputType | null
    _min: FeeStructureMinAggregateOutputType | null
    _max: FeeStructureMaxAggregateOutputType | null
  }

  export type FeeStructureAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type FeeStructureSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type FeeStructureMinAggregateOutputType = {
    id: string | null
    schoolId: string | null
    name: string | null
    description: string | null
    amount: Decimal | null
    academicYear: string | null
    term: $Enums.TermPeriod | null
    frequency: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeeStructureMaxAggregateOutputType = {
    id: string | null
    schoolId: string | null
    name: string | null
    description: string | null
    amount: Decimal | null
    academicYear: string | null
    term: $Enums.TermPeriod | null
    frequency: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeeStructureCountAggregateOutputType = {
    id: number
    schoolId: number
    name: number
    description: number
    amount: number
    academicYear: number
    term: number
    frequency: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeeStructureAvgAggregateInputType = {
    amount?: true
  }

  export type FeeStructureSumAggregateInputType = {
    amount?: true
  }

  export type FeeStructureMinAggregateInputType = {
    id?: true
    schoolId?: true
    name?: true
    description?: true
    amount?: true
    academicYear?: true
    term?: true
    frequency?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeeStructureMaxAggregateInputType = {
    id?: true
    schoolId?: true
    name?: true
    description?: true
    amount?: true
    academicYear?: true
    term?: true
    frequency?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeeStructureCountAggregateInputType = {
    id?: true
    schoolId?: true
    name?: true
    description?: true
    amount?: true
    academicYear?: true
    term?: true
    frequency?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeeStructureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeeStructure to aggregate.
     */
    where?: FeeStructureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeStructures to fetch.
     */
    orderBy?: FeeStructureOrderByWithRelationInput | FeeStructureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeeStructureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeStructures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeStructures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeeStructures
    **/
    _count?: true | FeeStructureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeeStructureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeeStructureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeeStructureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeeStructureMaxAggregateInputType
  }

  export type GetFeeStructureAggregateType<T extends FeeStructureAggregateArgs> = {
        [P in keyof T & keyof AggregateFeeStructure]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeeStructure[P]>
      : GetScalarType<T[P], AggregateFeeStructure[P]>
  }




  export type FeeStructureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeStructureWhereInput
    orderBy?: FeeStructureOrderByWithAggregationInput | FeeStructureOrderByWithAggregationInput[]
    by: FeeStructureScalarFieldEnum[] | FeeStructureScalarFieldEnum
    having?: FeeStructureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeeStructureCountAggregateInputType | true
    _avg?: FeeStructureAvgAggregateInputType
    _sum?: FeeStructureSumAggregateInputType
    _min?: FeeStructureMinAggregateInputType
    _max?: FeeStructureMaxAggregateInputType
  }

  export type FeeStructureGroupByOutputType = {
    id: string
    schoolId: string
    name: string
    description: string | null
    amount: Decimal
    academicYear: string
    term: $Enums.TermPeriod | null
    frequency: string
    createdAt: Date
    updatedAt: Date
    _count: FeeStructureCountAggregateOutputType | null
    _avg: FeeStructureAvgAggregateOutputType | null
    _sum: FeeStructureSumAggregateOutputType | null
    _min: FeeStructureMinAggregateOutputType | null
    _max: FeeStructureMaxAggregateOutputType | null
  }

  type GetFeeStructureGroupByPayload<T extends FeeStructureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeeStructureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeeStructureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeeStructureGroupByOutputType[P]>
            : GetScalarType<T[P], FeeStructureGroupByOutputType[P]>
        }
      >
    >


  export type FeeStructureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    name?: boolean
    description?: boolean
    amount?: boolean
    academicYear?: boolean
    term?: boolean
    frequency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    invoiceLineItems?: boolean | FeeStructure$invoiceLineItemsArgs<ExtArgs>
    _count?: boolean | FeeStructureCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feeStructure"]>



  export type FeeStructureSelectScalar = {
    id?: boolean
    schoolId?: boolean
    name?: boolean
    description?: boolean
    amount?: boolean
    academicYear?: boolean
    term?: boolean
    frequency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeeStructureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "schoolId" | "name" | "description" | "amount" | "academicYear" | "term" | "frequency" | "createdAt" | "updatedAt", ExtArgs["result"]["feeStructure"]>
  export type FeeStructureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    invoiceLineItems?: boolean | FeeStructure$invoiceLineItemsArgs<ExtArgs>
    _count?: boolean | FeeStructureCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FeeStructurePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeeStructure"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      invoiceLineItems: Prisma.$InvoiceLineItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      schoolId: string
      name: string
      description: string | null
      amount: Prisma.Decimal
      academicYear: string
      term: $Enums.TermPeriod | null
      frequency: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["feeStructure"]>
    composites: {}
  }

  type FeeStructureGetPayload<S extends boolean | null | undefined | FeeStructureDefaultArgs> = $Result.GetResult<Prisma.$FeeStructurePayload, S>

  type FeeStructureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeeStructureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeeStructureCountAggregateInputType | true
    }

  export interface FeeStructureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeeStructure'], meta: { name: 'FeeStructure' } }
    /**
     * Find zero or one FeeStructure that matches the filter.
     * @param {FeeStructureFindUniqueArgs} args - Arguments to find a FeeStructure
     * @example
     * // Get one FeeStructure
     * const feeStructure = await prisma.feeStructure.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeeStructureFindUniqueArgs>(args: SelectSubset<T, FeeStructureFindUniqueArgs<ExtArgs>>): Prisma__FeeStructureClient<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeeStructure that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeeStructureFindUniqueOrThrowArgs} args - Arguments to find a FeeStructure
     * @example
     * // Get one FeeStructure
     * const feeStructure = await prisma.feeStructure.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeeStructureFindUniqueOrThrowArgs>(args: SelectSubset<T, FeeStructureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeeStructureClient<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeeStructure that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeStructureFindFirstArgs} args - Arguments to find a FeeStructure
     * @example
     * // Get one FeeStructure
     * const feeStructure = await prisma.feeStructure.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeeStructureFindFirstArgs>(args?: SelectSubset<T, FeeStructureFindFirstArgs<ExtArgs>>): Prisma__FeeStructureClient<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeeStructure that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeStructureFindFirstOrThrowArgs} args - Arguments to find a FeeStructure
     * @example
     * // Get one FeeStructure
     * const feeStructure = await prisma.feeStructure.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeeStructureFindFirstOrThrowArgs>(args?: SelectSubset<T, FeeStructureFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeeStructureClient<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeeStructures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeStructureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeeStructures
     * const feeStructures = await prisma.feeStructure.findMany()
     * 
     * // Get first 10 FeeStructures
     * const feeStructures = await prisma.feeStructure.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feeStructureWithIdOnly = await prisma.feeStructure.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeeStructureFindManyArgs>(args?: SelectSubset<T, FeeStructureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeeStructure.
     * @param {FeeStructureCreateArgs} args - Arguments to create a FeeStructure.
     * @example
     * // Create one FeeStructure
     * const FeeStructure = await prisma.feeStructure.create({
     *   data: {
     *     // ... data to create a FeeStructure
     *   }
     * })
     * 
     */
    create<T extends FeeStructureCreateArgs>(args: SelectSubset<T, FeeStructureCreateArgs<ExtArgs>>): Prisma__FeeStructureClient<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeeStructures.
     * @param {FeeStructureCreateManyArgs} args - Arguments to create many FeeStructures.
     * @example
     * // Create many FeeStructures
     * const feeStructure = await prisma.feeStructure.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeeStructureCreateManyArgs>(args?: SelectSubset<T, FeeStructureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FeeStructure.
     * @param {FeeStructureDeleteArgs} args - Arguments to delete one FeeStructure.
     * @example
     * // Delete one FeeStructure
     * const FeeStructure = await prisma.feeStructure.delete({
     *   where: {
     *     // ... filter to delete one FeeStructure
     *   }
     * })
     * 
     */
    delete<T extends FeeStructureDeleteArgs>(args: SelectSubset<T, FeeStructureDeleteArgs<ExtArgs>>): Prisma__FeeStructureClient<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeeStructure.
     * @param {FeeStructureUpdateArgs} args - Arguments to update one FeeStructure.
     * @example
     * // Update one FeeStructure
     * const feeStructure = await prisma.feeStructure.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeeStructureUpdateArgs>(args: SelectSubset<T, FeeStructureUpdateArgs<ExtArgs>>): Prisma__FeeStructureClient<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeeStructures.
     * @param {FeeStructureDeleteManyArgs} args - Arguments to filter FeeStructures to delete.
     * @example
     * // Delete a few FeeStructures
     * const { count } = await prisma.feeStructure.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeeStructureDeleteManyArgs>(args?: SelectSubset<T, FeeStructureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeeStructures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeStructureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeeStructures
     * const feeStructure = await prisma.feeStructure.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeeStructureUpdateManyArgs>(args: SelectSubset<T, FeeStructureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FeeStructure.
     * @param {FeeStructureUpsertArgs} args - Arguments to update or create a FeeStructure.
     * @example
     * // Update or create a FeeStructure
     * const feeStructure = await prisma.feeStructure.upsert({
     *   create: {
     *     // ... data to create a FeeStructure
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeeStructure we want to update
     *   }
     * })
     */
    upsert<T extends FeeStructureUpsertArgs>(args: SelectSubset<T, FeeStructureUpsertArgs<ExtArgs>>): Prisma__FeeStructureClient<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeeStructures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeStructureCountArgs} args - Arguments to filter FeeStructures to count.
     * @example
     * // Count the number of FeeStructures
     * const count = await prisma.feeStructure.count({
     *   where: {
     *     // ... the filter for the FeeStructures we want to count
     *   }
     * })
    **/
    count<T extends FeeStructureCountArgs>(
      args?: Subset<T, FeeStructureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeeStructureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeeStructure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeStructureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeeStructureAggregateArgs>(args: Subset<T, FeeStructureAggregateArgs>): Prisma.PrismaPromise<GetFeeStructureAggregateType<T>>

    /**
     * Group by FeeStructure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeStructureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeeStructureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeeStructureGroupByArgs['orderBy'] }
        : { orderBy?: FeeStructureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeeStructureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeeStructureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeeStructure model
   */
  readonly fields: FeeStructureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeeStructure.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeeStructureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invoiceLineItems<T extends FeeStructure$invoiceLineItemsArgs<ExtArgs> = {}>(args?: Subset<T, FeeStructure$invoiceLineItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLineItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeeStructure model
   */
  interface FeeStructureFieldRefs {
    readonly id: FieldRef<"FeeStructure", 'String'>
    readonly schoolId: FieldRef<"FeeStructure", 'String'>
    readonly name: FieldRef<"FeeStructure", 'String'>
    readonly description: FieldRef<"FeeStructure", 'String'>
    readonly amount: FieldRef<"FeeStructure", 'Decimal'>
    readonly academicYear: FieldRef<"FeeStructure", 'String'>
    readonly term: FieldRef<"FeeStructure", 'TermPeriod'>
    readonly frequency: FieldRef<"FeeStructure", 'String'>
    readonly createdAt: FieldRef<"FeeStructure", 'DateTime'>
    readonly updatedAt: FieldRef<"FeeStructure", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeeStructure findUnique
   */
  export type FeeStructureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
    /**
     * Filter, which FeeStructure to fetch.
     */
    where: FeeStructureWhereUniqueInput
  }

  /**
   * FeeStructure findUniqueOrThrow
   */
  export type FeeStructureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
    /**
     * Filter, which FeeStructure to fetch.
     */
    where: FeeStructureWhereUniqueInput
  }

  /**
   * FeeStructure findFirst
   */
  export type FeeStructureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
    /**
     * Filter, which FeeStructure to fetch.
     */
    where?: FeeStructureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeStructures to fetch.
     */
    orderBy?: FeeStructureOrderByWithRelationInput | FeeStructureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeeStructures.
     */
    cursor?: FeeStructureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeStructures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeStructures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeeStructures.
     */
    distinct?: FeeStructureScalarFieldEnum | FeeStructureScalarFieldEnum[]
  }

  /**
   * FeeStructure findFirstOrThrow
   */
  export type FeeStructureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
    /**
     * Filter, which FeeStructure to fetch.
     */
    where?: FeeStructureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeStructures to fetch.
     */
    orderBy?: FeeStructureOrderByWithRelationInput | FeeStructureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeeStructures.
     */
    cursor?: FeeStructureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeStructures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeStructures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeeStructures.
     */
    distinct?: FeeStructureScalarFieldEnum | FeeStructureScalarFieldEnum[]
  }

  /**
   * FeeStructure findMany
   */
  export type FeeStructureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
    /**
     * Filter, which FeeStructures to fetch.
     */
    where?: FeeStructureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeStructures to fetch.
     */
    orderBy?: FeeStructureOrderByWithRelationInput | FeeStructureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeeStructures.
     */
    cursor?: FeeStructureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeStructures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeStructures.
     */
    skip?: number
    distinct?: FeeStructureScalarFieldEnum | FeeStructureScalarFieldEnum[]
  }

  /**
   * FeeStructure create
   */
  export type FeeStructureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
    /**
     * The data needed to create a FeeStructure.
     */
    data: XOR<FeeStructureCreateInput, FeeStructureUncheckedCreateInput>
  }

  /**
   * FeeStructure createMany
   */
  export type FeeStructureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeeStructures.
     */
    data: FeeStructureCreateManyInput | FeeStructureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeeStructure update
   */
  export type FeeStructureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
    /**
     * The data needed to update a FeeStructure.
     */
    data: XOR<FeeStructureUpdateInput, FeeStructureUncheckedUpdateInput>
    /**
     * Choose, which FeeStructure to update.
     */
    where: FeeStructureWhereUniqueInput
  }

  /**
   * FeeStructure updateMany
   */
  export type FeeStructureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeeStructures.
     */
    data: XOR<FeeStructureUpdateManyMutationInput, FeeStructureUncheckedUpdateManyInput>
    /**
     * Filter which FeeStructures to update
     */
    where?: FeeStructureWhereInput
    /**
     * Limit how many FeeStructures to update.
     */
    limit?: number
  }

  /**
   * FeeStructure upsert
   */
  export type FeeStructureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
    /**
     * The filter to search for the FeeStructure to update in case it exists.
     */
    where: FeeStructureWhereUniqueInput
    /**
     * In case the FeeStructure found by the `where` argument doesn't exist, create a new FeeStructure with this data.
     */
    create: XOR<FeeStructureCreateInput, FeeStructureUncheckedCreateInput>
    /**
     * In case the FeeStructure was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeeStructureUpdateInput, FeeStructureUncheckedUpdateInput>
  }

  /**
   * FeeStructure delete
   */
  export type FeeStructureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
    /**
     * Filter which FeeStructure to delete.
     */
    where: FeeStructureWhereUniqueInput
  }

  /**
   * FeeStructure deleteMany
   */
  export type FeeStructureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeeStructures to delete
     */
    where?: FeeStructureWhereInput
    /**
     * Limit how many FeeStructures to delete.
     */
    limit?: number
  }

  /**
   * FeeStructure.invoiceLineItems
   */
  export type FeeStructure$invoiceLineItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLineItem
     */
    omit?: InvoiceLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineItemInclude<ExtArgs> | null
    where?: InvoiceLineItemWhereInput
    orderBy?: InvoiceLineItemOrderByWithRelationInput | InvoiceLineItemOrderByWithRelationInput[]
    cursor?: InvoiceLineItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceLineItemScalarFieldEnum | InvoiceLineItemScalarFieldEnum[]
  }

  /**
   * FeeStructure without action
   */
  export type FeeStructureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    totalAmount: Decimal | null
    paidAmount: Decimal | null
  }

  export type InvoiceSumAggregateOutputType = {
    totalAmount: Decimal | null
    paidAmount: Decimal | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    schoolId: string | null
    studentId: string | null
    parentToBillId: string | null
    invoiceNumber: string | null
    issueDate: Date | null
    dueDate: Date | null
    totalAmount: Decimal | null
    paidAmount: Decimal | null
    status: $Enums.PaymentStatus | null
    notes: string | null
    academicYear: string | null
    term: $Enums.TermPeriod | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    schoolId: string | null
    studentId: string | null
    parentToBillId: string | null
    invoiceNumber: string | null
    issueDate: Date | null
    dueDate: Date | null
    totalAmount: Decimal | null
    paidAmount: Decimal | null
    status: $Enums.PaymentStatus | null
    notes: string | null
    academicYear: string | null
    term: $Enums.TermPeriod | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    schoolId: number
    studentId: number
    parentToBillId: number
    invoiceNumber: number
    issueDate: number
    dueDate: number
    totalAmount: number
    paidAmount: number
    status: number
    notes: number
    academicYear: number
    term: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    totalAmount?: true
    paidAmount?: true
  }

  export type InvoiceSumAggregateInputType = {
    totalAmount?: true
    paidAmount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    schoolId?: true
    studentId?: true
    parentToBillId?: true
    invoiceNumber?: true
    issueDate?: true
    dueDate?: true
    totalAmount?: true
    paidAmount?: true
    status?: true
    notes?: true
    academicYear?: true
    term?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    schoolId?: true
    studentId?: true
    parentToBillId?: true
    invoiceNumber?: true
    issueDate?: true
    dueDate?: true
    totalAmount?: true
    paidAmount?: true
    status?: true
    notes?: true
    academicYear?: true
    term?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    schoolId?: true
    studentId?: true
    parentToBillId?: true
    invoiceNumber?: true
    issueDate?: true
    dueDate?: true
    totalAmount?: true
    paidAmount?: true
    status?: true
    notes?: true
    academicYear?: true
    term?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    schoolId: string
    studentId: string
    parentToBillId: string | null
    invoiceNumber: string
    issueDate: Date
    dueDate: Date
    totalAmount: Decimal
    paidAmount: Decimal
    status: $Enums.PaymentStatus
    notes: string | null
    academicYear: string
    term: $Enums.TermPeriod
    createdAt: Date
    updatedAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    studentId?: boolean
    parentToBillId?: boolean
    invoiceNumber?: boolean
    issueDate?: boolean
    dueDate?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    status?: boolean
    notes?: boolean
    academicYear?: boolean
    term?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    parentToBill?: boolean | Invoice$parentToBillArgs<ExtArgs>
    lineItems?: boolean | Invoice$lineItemsArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>



  export type InvoiceSelectScalar = {
    id?: boolean
    schoolId?: boolean
    studentId?: boolean
    parentToBillId?: boolean
    invoiceNumber?: boolean
    issueDate?: boolean
    dueDate?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    status?: boolean
    notes?: boolean
    academicYear?: boolean
    term?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "schoolId" | "studentId" | "parentToBillId" | "invoiceNumber" | "issueDate" | "dueDate" | "totalAmount" | "paidAmount" | "status" | "notes" | "academicYear" | "term" | "createdAt" | "updatedAt", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    parentToBill?: boolean | Invoice$parentToBillArgs<ExtArgs>
    lineItems?: boolean | Invoice$lineItemsArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      student: Prisma.$StudentPayload<ExtArgs>
      parentToBill: Prisma.$ParentPayload<ExtArgs> | null
      lineItems: Prisma.$InvoiceLineItemPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      schoolId: string
      studentId: string
      parentToBillId: string | null
      invoiceNumber: string
      issueDate: Date
      dueDate: Date
      totalAmount: Prisma.Decimal
      paidAmount: Prisma.Decimal
      status: $Enums.PaymentStatus
      notes: string | null
      academicYear: string
      term: $Enums.TermPeriod
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parentToBill<T extends Invoice$parentToBillArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$parentToBillArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lineItems<T extends Invoice$lineItemsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$lineItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLineItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Invoice$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly schoolId: FieldRef<"Invoice", 'String'>
    readonly studentId: FieldRef<"Invoice", 'String'>
    readonly parentToBillId: FieldRef<"Invoice", 'String'>
    readonly invoiceNumber: FieldRef<"Invoice", 'String'>
    readonly issueDate: FieldRef<"Invoice", 'DateTime'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly totalAmount: FieldRef<"Invoice", 'Decimal'>
    readonly paidAmount: FieldRef<"Invoice", 'Decimal'>
    readonly status: FieldRef<"Invoice", 'PaymentStatus'>
    readonly notes: FieldRef<"Invoice", 'String'>
    readonly academicYear: FieldRef<"Invoice", 'String'>
    readonly term: FieldRef<"Invoice", 'TermPeriod'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice.parentToBill
   */
  export type Invoice$parentToBillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    where?: ParentWhereInput
  }

  /**
   * Invoice.lineItems
   */
  export type Invoice$lineItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLineItem
     */
    omit?: InvoiceLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineItemInclude<ExtArgs> | null
    where?: InvoiceLineItemWhereInput
    orderBy?: InvoiceLineItemOrderByWithRelationInput | InvoiceLineItemOrderByWithRelationInput[]
    cursor?: InvoiceLineItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceLineItemScalarFieldEnum | InvoiceLineItemScalarFieldEnum[]
  }

  /**
   * Invoice.payments
   */
  export type Invoice$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceLineItem
   */

  export type AggregateInvoiceLineItem = {
    _count: InvoiceLineItemCountAggregateOutputType | null
    _avg: InvoiceLineItemAvgAggregateOutputType | null
    _sum: InvoiceLineItemSumAggregateOutputType | null
    _min: InvoiceLineItemMinAggregateOutputType | null
    _max: InvoiceLineItemMaxAggregateOutputType | null
  }

  export type InvoiceLineItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: Decimal | null
    amount: Decimal | null
  }

  export type InvoiceLineItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: Decimal | null
    amount: Decimal | null
  }

  export type InvoiceLineItemMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    feeStructureId: string | null
    studentId: string | null
    description: string | null
    quantity: number | null
    unitPrice: Decimal | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceLineItemMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    feeStructureId: string | null
    studentId: string | null
    description: string | null
    quantity: number | null
    unitPrice: Decimal | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceLineItemCountAggregateOutputType = {
    id: number
    invoiceId: number
    feeStructureId: number
    studentId: number
    description: number
    quantity: number
    unitPrice: number
    amount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceLineItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    amount?: true
  }

  export type InvoiceLineItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    amount?: true
  }

  export type InvoiceLineItemMinAggregateInputType = {
    id?: true
    invoiceId?: true
    feeStructureId?: true
    studentId?: true
    description?: true
    quantity?: true
    unitPrice?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceLineItemMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    feeStructureId?: true
    studentId?: true
    description?: true
    quantity?: true
    unitPrice?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceLineItemCountAggregateInputType = {
    id?: true
    invoiceId?: true
    feeStructureId?: true
    studentId?: true
    description?: true
    quantity?: true
    unitPrice?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceLineItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceLineItem to aggregate.
     */
    where?: InvoiceLineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLineItems to fetch.
     */
    orderBy?: InvoiceLineItemOrderByWithRelationInput | InvoiceLineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceLineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLineItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceLineItems
    **/
    _count?: true | InvoiceLineItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceLineItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceLineItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceLineItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceLineItemMaxAggregateInputType
  }

  export type GetInvoiceLineItemAggregateType<T extends InvoiceLineItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceLineItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceLineItem[P]>
      : GetScalarType<T[P], AggregateInvoiceLineItem[P]>
  }




  export type InvoiceLineItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceLineItemWhereInput
    orderBy?: InvoiceLineItemOrderByWithAggregationInput | InvoiceLineItemOrderByWithAggregationInput[]
    by: InvoiceLineItemScalarFieldEnum[] | InvoiceLineItemScalarFieldEnum
    having?: InvoiceLineItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceLineItemCountAggregateInputType | true
    _avg?: InvoiceLineItemAvgAggregateInputType
    _sum?: InvoiceLineItemSumAggregateInputType
    _min?: InvoiceLineItemMinAggregateInputType
    _max?: InvoiceLineItemMaxAggregateInputType
  }

  export type InvoiceLineItemGroupByOutputType = {
    id: string
    invoiceId: string
    feeStructureId: string | null
    studentId: string
    description: string
    quantity: number
    unitPrice: Decimal
    amount: Decimal
    createdAt: Date
    updatedAt: Date
    _count: InvoiceLineItemCountAggregateOutputType | null
    _avg: InvoiceLineItemAvgAggregateOutputType | null
    _sum: InvoiceLineItemSumAggregateOutputType | null
    _min: InvoiceLineItemMinAggregateOutputType | null
    _max: InvoiceLineItemMaxAggregateOutputType | null
  }

  type GetInvoiceLineItemGroupByPayload<T extends InvoiceLineItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceLineItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceLineItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceLineItemGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceLineItemGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceLineItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    feeStructureId?: boolean
    studentId?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    feeStructure?: boolean | InvoiceLineItem$feeStructureArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceLineItem"]>



  export type InvoiceLineItemSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    feeStructureId?: boolean
    studentId?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceLineItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceId" | "feeStructureId" | "studentId" | "description" | "quantity" | "unitPrice" | "amount" | "createdAt" | "updatedAt", ExtArgs["result"]["invoiceLineItem"]>
  export type InvoiceLineItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    feeStructure?: boolean | InvoiceLineItem$feeStructureArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $InvoiceLineItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceLineItem"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
      feeStructure: Prisma.$FeeStructurePayload<ExtArgs> | null
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      feeStructureId: string | null
      studentId: string
      description: string
      quantity: number
      unitPrice: Prisma.Decimal
      amount: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoiceLineItem"]>
    composites: {}
  }

  type InvoiceLineItemGetPayload<S extends boolean | null | undefined | InvoiceLineItemDefaultArgs> = $Result.GetResult<Prisma.$InvoiceLineItemPayload, S>

  type InvoiceLineItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceLineItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceLineItemCountAggregateInputType | true
    }

  export interface InvoiceLineItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceLineItem'], meta: { name: 'InvoiceLineItem' } }
    /**
     * Find zero or one InvoiceLineItem that matches the filter.
     * @param {InvoiceLineItemFindUniqueArgs} args - Arguments to find a InvoiceLineItem
     * @example
     * // Get one InvoiceLineItem
     * const invoiceLineItem = await prisma.invoiceLineItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceLineItemFindUniqueArgs>(args: SelectSubset<T, InvoiceLineItemFindUniqueArgs<ExtArgs>>): Prisma__InvoiceLineItemClient<$Result.GetResult<Prisma.$InvoiceLineItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InvoiceLineItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceLineItemFindUniqueOrThrowArgs} args - Arguments to find a InvoiceLineItem
     * @example
     * // Get one InvoiceLineItem
     * const invoiceLineItem = await prisma.invoiceLineItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceLineItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceLineItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceLineItemClient<$Result.GetResult<Prisma.$InvoiceLineItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceLineItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineItemFindFirstArgs} args - Arguments to find a InvoiceLineItem
     * @example
     * // Get one InvoiceLineItem
     * const invoiceLineItem = await prisma.invoiceLineItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceLineItemFindFirstArgs>(args?: SelectSubset<T, InvoiceLineItemFindFirstArgs<ExtArgs>>): Prisma__InvoiceLineItemClient<$Result.GetResult<Prisma.$InvoiceLineItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceLineItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineItemFindFirstOrThrowArgs} args - Arguments to find a InvoiceLineItem
     * @example
     * // Get one InvoiceLineItem
     * const invoiceLineItem = await prisma.invoiceLineItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceLineItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceLineItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceLineItemClient<$Result.GetResult<Prisma.$InvoiceLineItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InvoiceLineItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceLineItems
     * const invoiceLineItems = await prisma.invoiceLineItem.findMany()
     * 
     * // Get first 10 InvoiceLineItems
     * const invoiceLineItems = await prisma.invoiceLineItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceLineItemWithIdOnly = await prisma.invoiceLineItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceLineItemFindManyArgs>(args?: SelectSubset<T, InvoiceLineItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLineItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InvoiceLineItem.
     * @param {InvoiceLineItemCreateArgs} args - Arguments to create a InvoiceLineItem.
     * @example
     * // Create one InvoiceLineItem
     * const InvoiceLineItem = await prisma.invoiceLineItem.create({
     *   data: {
     *     // ... data to create a InvoiceLineItem
     *   }
     * })
     * 
     */
    create<T extends InvoiceLineItemCreateArgs>(args: SelectSubset<T, InvoiceLineItemCreateArgs<ExtArgs>>): Prisma__InvoiceLineItemClient<$Result.GetResult<Prisma.$InvoiceLineItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InvoiceLineItems.
     * @param {InvoiceLineItemCreateManyArgs} args - Arguments to create many InvoiceLineItems.
     * @example
     * // Create many InvoiceLineItems
     * const invoiceLineItem = await prisma.invoiceLineItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceLineItemCreateManyArgs>(args?: SelectSubset<T, InvoiceLineItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InvoiceLineItem.
     * @param {InvoiceLineItemDeleteArgs} args - Arguments to delete one InvoiceLineItem.
     * @example
     * // Delete one InvoiceLineItem
     * const InvoiceLineItem = await prisma.invoiceLineItem.delete({
     *   where: {
     *     // ... filter to delete one InvoiceLineItem
     *   }
     * })
     * 
     */
    delete<T extends InvoiceLineItemDeleteArgs>(args: SelectSubset<T, InvoiceLineItemDeleteArgs<ExtArgs>>): Prisma__InvoiceLineItemClient<$Result.GetResult<Prisma.$InvoiceLineItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InvoiceLineItem.
     * @param {InvoiceLineItemUpdateArgs} args - Arguments to update one InvoiceLineItem.
     * @example
     * // Update one InvoiceLineItem
     * const invoiceLineItem = await prisma.invoiceLineItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceLineItemUpdateArgs>(args: SelectSubset<T, InvoiceLineItemUpdateArgs<ExtArgs>>): Prisma__InvoiceLineItemClient<$Result.GetResult<Prisma.$InvoiceLineItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InvoiceLineItems.
     * @param {InvoiceLineItemDeleteManyArgs} args - Arguments to filter InvoiceLineItems to delete.
     * @example
     * // Delete a few InvoiceLineItems
     * const { count } = await prisma.invoiceLineItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceLineItemDeleteManyArgs>(args?: SelectSubset<T, InvoiceLineItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceLineItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceLineItems
     * const invoiceLineItem = await prisma.invoiceLineItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceLineItemUpdateManyArgs>(args: SelectSubset<T, InvoiceLineItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvoiceLineItem.
     * @param {InvoiceLineItemUpsertArgs} args - Arguments to update or create a InvoiceLineItem.
     * @example
     * // Update or create a InvoiceLineItem
     * const invoiceLineItem = await prisma.invoiceLineItem.upsert({
     *   create: {
     *     // ... data to create a InvoiceLineItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceLineItem we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceLineItemUpsertArgs>(args: SelectSubset<T, InvoiceLineItemUpsertArgs<ExtArgs>>): Prisma__InvoiceLineItemClient<$Result.GetResult<Prisma.$InvoiceLineItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InvoiceLineItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineItemCountArgs} args - Arguments to filter InvoiceLineItems to count.
     * @example
     * // Count the number of InvoiceLineItems
     * const count = await prisma.invoiceLineItem.count({
     *   where: {
     *     // ... the filter for the InvoiceLineItems we want to count
     *   }
     * })
    **/
    count<T extends InvoiceLineItemCountArgs>(
      args?: Subset<T, InvoiceLineItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceLineItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceLineItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceLineItemAggregateArgs>(args: Subset<T, InvoiceLineItemAggregateArgs>): Prisma.PrismaPromise<GetInvoiceLineItemAggregateType<T>>

    /**
     * Group by InvoiceLineItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceLineItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceLineItemGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceLineItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceLineItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceLineItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceLineItem model
   */
  readonly fields: InvoiceLineItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceLineItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceLineItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    feeStructure<T extends InvoiceLineItem$feeStructureArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceLineItem$feeStructureArgs<ExtArgs>>): Prisma__FeeStructureClient<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceLineItem model
   */
  interface InvoiceLineItemFieldRefs {
    readonly id: FieldRef<"InvoiceLineItem", 'String'>
    readonly invoiceId: FieldRef<"InvoiceLineItem", 'String'>
    readonly feeStructureId: FieldRef<"InvoiceLineItem", 'String'>
    readonly studentId: FieldRef<"InvoiceLineItem", 'String'>
    readonly description: FieldRef<"InvoiceLineItem", 'String'>
    readonly quantity: FieldRef<"InvoiceLineItem", 'Int'>
    readonly unitPrice: FieldRef<"InvoiceLineItem", 'Decimal'>
    readonly amount: FieldRef<"InvoiceLineItem", 'Decimal'>
    readonly createdAt: FieldRef<"InvoiceLineItem", 'DateTime'>
    readonly updatedAt: FieldRef<"InvoiceLineItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceLineItem findUnique
   */
  export type InvoiceLineItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLineItem
     */
    omit?: InvoiceLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLineItem to fetch.
     */
    where: InvoiceLineItemWhereUniqueInput
  }

  /**
   * InvoiceLineItem findUniqueOrThrow
   */
  export type InvoiceLineItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLineItem
     */
    omit?: InvoiceLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLineItem to fetch.
     */
    where: InvoiceLineItemWhereUniqueInput
  }

  /**
   * InvoiceLineItem findFirst
   */
  export type InvoiceLineItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLineItem
     */
    omit?: InvoiceLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLineItem to fetch.
     */
    where?: InvoiceLineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLineItems to fetch.
     */
    orderBy?: InvoiceLineItemOrderByWithRelationInput | InvoiceLineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceLineItems.
     */
    cursor?: InvoiceLineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLineItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceLineItems.
     */
    distinct?: InvoiceLineItemScalarFieldEnum | InvoiceLineItemScalarFieldEnum[]
  }

  /**
   * InvoiceLineItem findFirstOrThrow
   */
  export type InvoiceLineItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLineItem
     */
    omit?: InvoiceLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLineItem to fetch.
     */
    where?: InvoiceLineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLineItems to fetch.
     */
    orderBy?: InvoiceLineItemOrderByWithRelationInput | InvoiceLineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceLineItems.
     */
    cursor?: InvoiceLineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLineItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceLineItems.
     */
    distinct?: InvoiceLineItemScalarFieldEnum | InvoiceLineItemScalarFieldEnum[]
  }

  /**
   * InvoiceLineItem findMany
   */
  export type InvoiceLineItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLineItem
     */
    omit?: InvoiceLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLineItems to fetch.
     */
    where?: InvoiceLineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLineItems to fetch.
     */
    orderBy?: InvoiceLineItemOrderByWithRelationInput | InvoiceLineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceLineItems.
     */
    cursor?: InvoiceLineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLineItems.
     */
    skip?: number
    distinct?: InvoiceLineItemScalarFieldEnum | InvoiceLineItemScalarFieldEnum[]
  }

  /**
   * InvoiceLineItem create
   */
  export type InvoiceLineItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLineItem
     */
    omit?: InvoiceLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceLineItem.
     */
    data: XOR<InvoiceLineItemCreateInput, InvoiceLineItemUncheckedCreateInput>
  }

  /**
   * InvoiceLineItem createMany
   */
  export type InvoiceLineItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceLineItems.
     */
    data: InvoiceLineItemCreateManyInput | InvoiceLineItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvoiceLineItem update
   */
  export type InvoiceLineItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLineItem
     */
    omit?: InvoiceLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceLineItem.
     */
    data: XOR<InvoiceLineItemUpdateInput, InvoiceLineItemUncheckedUpdateInput>
    /**
     * Choose, which InvoiceLineItem to update.
     */
    where: InvoiceLineItemWhereUniqueInput
  }

  /**
   * InvoiceLineItem updateMany
   */
  export type InvoiceLineItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceLineItems.
     */
    data: XOR<InvoiceLineItemUpdateManyMutationInput, InvoiceLineItemUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceLineItems to update
     */
    where?: InvoiceLineItemWhereInput
    /**
     * Limit how many InvoiceLineItems to update.
     */
    limit?: number
  }

  /**
   * InvoiceLineItem upsert
   */
  export type InvoiceLineItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLineItem
     */
    omit?: InvoiceLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceLineItem to update in case it exists.
     */
    where: InvoiceLineItemWhereUniqueInput
    /**
     * In case the InvoiceLineItem found by the `where` argument doesn't exist, create a new InvoiceLineItem with this data.
     */
    create: XOR<InvoiceLineItemCreateInput, InvoiceLineItemUncheckedCreateInput>
    /**
     * In case the InvoiceLineItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceLineItemUpdateInput, InvoiceLineItemUncheckedUpdateInput>
  }

  /**
   * InvoiceLineItem delete
   */
  export type InvoiceLineItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLineItem
     */
    omit?: InvoiceLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineItemInclude<ExtArgs> | null
    /**
     * Filter which InvoiceLineItem to delete.
     */
    where: InvoiceLineItemWhereUniqueInput
  }

  /**
   * InvoiceLineItem deleteMany
   */
  export type InvoiceLineItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceLineItems to delete
     */
    where?: InvoiceLineItemWhereInput
    /**
     * Limit how many InvoiceLineItems to delete.
     */
    limit?: number
  }

  /**
   * InvoiceLineItem.feeStructure
   */
  export type InvoiceLineItem$feeStructureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
    where?: FeeStructureWhereInput
  }

  /**
   * InvoiceLineItem without action
   */
  export type InvoiceLineItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLineItem
     */
    omit?: InvoiceLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineItemInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    paymentDate: Date | null
    amount: Decimal | null
    paymentMethod: string | null
    reference: string | null
    notes: string | null
    recordedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    paymentDate: Date | null
    amount: Decimal | null
    paymentMethod: string | null
    reference: string | null
    notes: string | null
    recordedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    invoiceId: number
    paymentDate: number
    amount: number
    paymentMethod: number
    reference: number
    notes: number
    recordedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    invoiceId?: true
    paymentDate?: true
    amount?: true
    paymentMethod?: true
    reference?: true
    notes?: true
    recordedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    paymentDate?: true
    amount?: true
    paymentMethod?: true
    reference?: true
    notes?: true
    recordedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    invoiceId?: true
    paymentDate?: true
    amount?: true
    paymentMethod?: true
    reference?: true
    notes?: true
    recordedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    invoiceId: string
    paymentDate: Date
    amount: Decimal
    paymentMethod: string
    reference: string | null
    notes: string | null
    recordedById: string | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    paymentDate?: boolean
    amount?: boolean
    paymentMethod?: boolean
    reference?: boolean
    notes?: boolean
    recordedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    recordedBy?: boolean | Payment$recordedByArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>



  export type PaymentSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    paymentDate?: boolean
    amount?: boolean
    paymentMethod?: boolean
    reference?: boolean
    notes?: boolean
    recordedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceId" | "paymentDate" | "amount" | "paymentMethod" | "reference" | "notes" | "recordedById" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    recordedBy?: boolean | Payment$recordedByArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
      recordedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      paymentDate: Date
      amount: Prisma.Decimal
      paymentMethod: string
      reference: string | null
      notes: string | null
      recordedById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    recordedBy<T extends Payment$recordedByArgs<ExtArgs> = {}>(args?: Subset<T, Payment$recordedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly invoiceId: FieldRef<"Payment", 'String'>
    readonly paymentDate: FieldRef<"Payment", 'DateTime'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly paymentMethod: FieldRef<"Payment", 'String'>
    readonly reference: FieldRef<"Payment", 'String'>
    readonly notes: FieldRef<"Payment", 'String'>
    readonly recordedById: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.recordedBy
   */
  export type Payment$recordedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model SchoolAnnouncement
   */

  export type AggregateSchoolAnnouncement = {
    _count: SchoolAnnouncementCountAggregateOutputType | null
    _min: SchoolAnnouncementMinAggregateOutputType | null
    _max: SchoolAnnouncementMaxAggregateOutputType | null
  }

  export type SchoolAnnouncementMinAggregateOutputType = {
    id: string | null
    schoolId: string | null
    title: string | null
    content: string | null
    publishDate: Date | null
    expiryDate: Date | null
    audience: string | null
    isPublished: boolean | null
    createdByAdminId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolAnnouncementMaxAggregateOutputType = {
    id: string | null
    schoolId: string | null
    title: string | null
    content: string | null
    publishDate: Date | null
    expiryDate: Date | null
    audience: string | null
    isPublished: boolean | null
    createdByAdminId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolAnnouncementCountAggregateOutputType = {
    id: number
    schoolId: number
    title: number
    content: number
    publishDate: number
    expiryDate: number
    audience: number
    isPublished: number
    createdByAdminId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolAnnouncementMinAggregateInputType = {
    id?: true
    schoolId?: true
    title?: true
    content?: true
    publishDate?: true
    expiryDate?: true
    audience?: true
    isPublished?: true
    createdByAdminId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolAnnouncementMaxAggregateInputType = {
    id?: true
    schoolId?: true
    title?: true
    content?: true
    publishDate?: true
    expiryDate?: true
    audience?: true
    isPublished?: true
    createdByAdminId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolAnnouncementCountAggregateInputType = {
    id?: true
    schoolId?: true
    title?: true
    content?: true
    publishDate?: true
    expiryDate?: true
    audience?: true
    isPublished?: true
    createdByAdminId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolAnnouncementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolAnnouncement to aggregate.
     */
    where?: SchoolAnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolAnnouncements to fetch.
     */
    orderBy?: SchoolAnnouncementOrderByWithRelationInput | SchoolAnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolAnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolAnnouncements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolAnnouncements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SchoolAnnouncements
    **/
    _count?: true | SchoolAnnouncementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolAnnouncementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolAnnouncementMaxAggregateInputType
  }

  export type GetSchoolAnnouncementAggregateType<T extends SchoolAnnouncementAggregateArgs> = {
        [P in keyof T & keyof AggregateSchoolAnnouncement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchoolAnnouncement[P]>
      : GetScalarType<T[P], AggregateSchoolAnnouncement[P]>
  }




  export type SchoolAnnouncementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolAnnouncementWhereInput
    orderBy?: SchoolAnnouncementOrderByWithAggregationInput | SchoolAnnouncementOrderByWithAggregationInput[]
    by: SchoolAnnouncementScalarFieldEnum[] | SchoolAnnouncementScalarFieldEnum
    having?: SchoolAnnouncementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolAnnouncementCountAggregateInputType | true
    _min?: SchoolAnnouncementMinAggregateInputType
    _max?: SchoolAnnouncementMaxAggregateInputType
  }

  export type SchoolAnnouncementGroupByOutputType = {
    id: string
    schoolId: string
    title: string
    content: string
    publishDate: Date
    expiryDate: Date | null
    audience: string | null
    isPublished: boolean
    createdByAdminId: string | null
    createdAt: Date
    updatedAt: Date
    _count: SchoolAnnouncementCountAggregateOutputType | null
    _min: SchoolAnnouncementMinAggregateOutputType | null
    _max: SchoolAnnouncementMaxAggregateOutputType | null
  }

  type GetSchoolAnnouncementGroupByPayload<T extends SchoolAnnouncementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolAnnouncementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolAnnouncementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolAnnouncementGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolAnnouncementGroupByOutputType[P]>
        }
      >
    >


  export type SchoolAnnouncementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    title?: boolean
    content?: boolean
    publishDate?: boolean
    expiryDate?: boolean
    audience?: boolean
    isPublished?: boolean
    createdByAdminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    createdByAdmin?: boolean | SchoolAnnouncement$createdByAdminArgs<ExtArgs>
  }, ExtArgs["result"]["schoolAnnouncement"]>



  export type SchoolAnnouncementSelectScalar = {
    id?: boolean
    schoolId?: boolean
    title?: boolean
    content?: boolean
    publishDate?: boolean
    expiryDate?: boolean
    audience?: boolean
    isPublished?: boolean
    createdByAdminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SchoolAnnouncementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "schoolId" | "title" | "content" | "publishDate" | "expiryDate" | "audience" | "isPublished" | "createdByAdminId" | "createdAt" | "updatedAt", ExtArgs["result"]["schoolAnnouncement"]>
  export type SchoolAnnouncementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    createdByAdmin?: boolean | SchoolAnnouncement$createdByAdminArgs<ExtArgs>
  }

  export type $SchoolAnnouncementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SchoolAnnouncement"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      createdByAdmin: Prisma.$SchoolAdminPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      schoolId: string
      title: string
      content: string
      publishDate: Date
      expiryDate: Date | null
      audience: string | null
      isPublished: boolean
      createdByAdminId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["schoolAnnouncement"]>
    composites: {}
  }

  type SchoolAnnouncementGetPayload<S extends boolean | null | undefined | SchoolAnnouncementDefaultArgs> = $Result.GetResult<Prisma.$SchoolAnnouncementPayload, S>

  type SchoolAnnouncementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SchoolAnnouncementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SchoolAnnouncementCountAggregateInputType | true
    }

  export interface SchoolAnnouncementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SchoolAnnouncement'], meta: { name: 'SchoolAnnouncement' } }
    /**
     * Find zero or one SchoolAnnouncement that matches the filter.
     * @param {SchoolAnnouncementFindUniqueArgs} args - Arguments to find a SchoolAnnouncement
     * @example
     * // Get one SchoolAnnouncement
     * const schoolAnnouncement = await prisma.schoolAnnouncement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolAnnouncementFindUniqueArgs>(args: SelectSubset<T, SchoolAnnouncementFindUniqueArgs<ExtArgs>>): Prisma__SchoolAnnouncementClient<$Result.GetResult<Prisma.$SchoolAnnouncementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SchoolAnnouncement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SchoolAnnouncementFindUniqueOrThrowArgs} args - Arguments to find a SchoolAnnouncement
     * @example
     * // Get one SchoolAnnouncement
     * const schoolAnnouncement = await prisma.schoolAnnouncement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolAnnouncementFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolAnnouncementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolAnnouncementClient<$Result.GetResult<Prisma.$SchoolAnnouncementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SchoolAnnouncement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAnnouncementFindFirstArgs} args - Arguments to find a SchoolAnnouncement
     * @example
     * // Get one SchoolAnnouncement
     * const schoolAnnouncement = await prisma.schoolAnnouncement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolAnnouncementFindFirstArgs>(args?: SelectSubset<T, SchoolAnnouncementFindFirstArgs<ExtArgs>>): Prisma__SchoolAnnouncementClient<$Result.GetResult<Prisma.$SchoolAnnouncementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SchoolAnnouncement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAnnouncementFindFirstOrThrowArgs} args - Arguments to find a SchoolAnnouncement
     * @example
     * // Get one SchoolAnnouncement
     * const schoolAnnouncement = await prisma.schoolAnnouncement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolAnnouncementFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolAnnouncementFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolAnnouncementClient<$Result.GetResult<Prisma.$SchoolAnnouncementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SchoolAnnouncements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAnnouncementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SchoolAnnouncements
     * const schoolAnnouncements = await prisma.schoolAnnouncement.findMany()
     * 
     * // Get first 10 SchoolAnnouncements
     * const schoolAnnouncements = await prisma.schoolAnnouncement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolAnnouncementWithIdOnly = await prisma.schoolAnnouncement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolAnnouncementFindManyArgs>(args?: SelectSubset<T, SchoolAnnouncementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolAnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SchoolAnnouncement.
     * @param {SchoolAnnouncementCreateArgs} args - Arguments to create a SchoolAnnouncement.
     * @example
     * // Create one SchoolAnnouncement
     * const SchoolAnnouncement = await prisma.schoolAnnouncement.create({
     *   data: {
     *     // ... data to create a SchoolAnnouncement
     *   }
     * })
     * 
     */
    create<T extends SchoolAnnouncementCreateArgs>(args: SelectSubset<T, SchoolAnnouncementCreateArgs<ExtArgs>>): Prisma__SchoolAnnouncementClient<$Result.GetResult<Prisma.$SchoolAnnouncementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SchoolAnnouncements.
     * @param {SchoolAnnouncementCreateManyArgs} args - Arguments to create many SchoolAnnouncements.
     * @example
     * // Create many SchoolAnnouncements
     * const schoolAnnouncement = await prisma.schoolAnnouncement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolAnnouncementCreateManyArgs>(args?: SelectSubset<T, SchoolAnnouncementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SchoolAnnouncement.
     * @param {SchoolAnnouncementDeleteArgs} args - Arguments to delete one SchoolAnnouncement.
     * @example
     * // Delete one SchoolAnnouncement
     * const SchoolAnnouncement = await prisma.schoolAnnouncement.delete({
     *   where: {
     *     // ... filter to delete one SchoolAnnouncement
     *   }
     * })
     * 
     */
    delete<T extends SchoolAnnouncementDeleteArgs>(args: SelectSubset<T, SchoolAnnouncementDeleteArgs<ExtArgs>>): Prisma__SchoolAnnouncementClient<$Result.GetResult<Prisma.$SchoolAnnouncementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SchoolAnnouncement.
     * @param {SchoolAnnouncementUpdateArgs} args - Arguments to update one SchoolAnnouncement.
     * @example
     * // Update one SchoolAnnouncement
     * const schoolAnnouncement = await prisma.schoolAnnouncement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolAnnouncementUpdateArgs>(args: SelectSubset<T, SchoolAnnouncementUpdateArgs<ExtArgs>>): Prisma__SchoolAnnouncementClient<$Result.GetResult<Prisma.$SchoolAnnouncementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SchoolAnnouncements.
     * @param {SchoolAnnouncementDeleteManyArgs} args - Arguments to filter SchoolAnnouncements to delete.
     * @example
     * // Delete a few SchoolAnnouncements
     * const { count } = await prisma.schoolAnnouncement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolAnnouncementDeleteManyArgs>(args?: SelectSubset<T, SchoolAnnouncementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolAnnouncements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAnnouncementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SchoolAnnouncements
     * const schoolAnnouncement = await prisma.schoolAnnouncement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolAnnouncementUpdateManyArgs>(args: SelectSubset<T, SchoolAnnouncementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SchoolAnnouncement.
     * @param {SchoolAnnouncementUpsertArgs} args - Arguments to update or create a SchoolAnnouncement.
     * @example
     * // Update or create a SchoolAnnouncement
     * const schoolAnnouncement = await prisma.schoolAnnouncement.upsert({
     *   create: {
     *     // ... data to create a SchoolAnnouncement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SchoolAnnouncement we want to update
     *   }
     * })
     */
    upsert<T extends SchoolAnnouncementUpsertArgs>(args: SelectSubset<T, SchoolAnnouncementUpsertArgs<ExtArgs>>): Prisma__SchoolAnnouncementClient<$Result.GetResult<Prisma.$SchoolAnnouncementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SchoolAnnouncements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAnnouncementCountArgs} args - Arguments to filter SchoolAnnouncements to count.
     * @example
     * // Count the number of SchoolAnnouncements
     * const count = await prisma.schoolAnnouncement.count({
     *   where: {
     *     // ... the filter for the SchoolAnnouncements we want to count
     *   }
     * })
    **/
    count<T extends SchoolAnnouncementCountArgs>(
      args?: Subset<T, SchoolAnnouncementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolAnnouncementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SchoolAnnouncement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAnnouncementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolAnnouncementAggregateArgs>(args: Subset<T, SchoolAnnouncementAggregateArgs>): Prisma.PrismaPromise<GetSchoolAnnouncementAggregateType<T>>

    /**
     * Group by SchoolAnnouncement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAnnouncementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolAnnouncementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolAnnouncementGroupByArgs['orderBy'] }
        : { orderBy?: SchoolAnnouncementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolAnnouncementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolAnnouncementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SchoolAnnouncement model
   */
  readonly fields: SchoolAnnouncementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SchoolAnnouncement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolAnnouncementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdByAdmin<T extends SchoolAnnouncement$createdByAdminArgs<ExtArgs> = {}>(args?: Subset<T, SchoolAnnouncement$createdByAdminArgs<ExtArgs>>): Prisma__SchoolAdminClient<$Result.GetResult<Prisma.$SchoolAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SchoolAnnouncement model
   */
  interface SchoolAnnouncementFieldRefs {
    readonly id: FieldRef<"SchoolAnnouncement", 'String'>
    readonly schoolId: FieldRef<"SchoolAnnouncement", 'String'>
    readonly title: FieldRef<"SchoolAnnouncement", 'String'>
    readonly content: FieldRef<"SchoolAnnouncement", 'String'>
    readonly publishDate: FieldRef<"SchoolAnnouncement", 'DateTime'>
    readonly expiryDate: FieldRef<"SchoolAnnouncement", 'DateTime'>
    readonly audience: FieldRef<"SchoolAnnouncement", 'String'>
    readonly isPublished: FieldRef<"SchoolAnnouncement", 'Boolean'>
    readonly createdByAdminId: FieldRef<"SchoolAnnouncement", 'String'>
    readonly createdAt: FieldRef<"SchoolAnnouncement", 'DateTime'>
    readonly updatedAt: FieldRef<"SchoolAnnouncement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SchoolAnnouncement findUnique
   */
  export type SchoolAnnouncementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAnnouncement
     */
    select?: SchoolAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAnnouncement
     */
    omit?: SchoolAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which SchoolAnnouncement to fetch.
     */
    where: SchoolAnnouncementWhereUniqueInput
  }

  /**
   * SchoolAnnouncement findUniqueOrThrow
   */
  export type SchoolAnnouncementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAnnouncement
     */
    select?: SchoolAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAnnouncement
     */
    omit?: SchoolAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which SchoolAnnouncement to fetch.
     */
    where: SchoolAnnouncementWhereUniqueInput
  }

  /**
   * SchoolAnnouncement findFirst
   */
  export type SchoolAnnouncementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAnnouncement
     */
    select?: SchoolAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAnnouncement
     */
    omit?: SchoolAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which SchoolAnnouncement to fetch.
     */
    where?: SchoolAnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolAnnouncements to fetch.
     */
    orderBy?: SchoolAnnouncementOrderByWithRelationInput | SchoolAnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolAnnouncements.
     */
    cursor?: SchoolAnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolAnnouncements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolAnnouncements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolAnnouncements.
     */
    distinct?: SchoolAnnouncementScalarFieldEnum | SchoolAnnouncementScalarFieldEnum[]
  }

  /**
   * SchoolAnnouncement findFirstOrThrow
   */
  export type SchoolAnnouncementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAnnouncement
     */
    select?: SchoolAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAnnouncement
     */
    omit?: SchoolAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which SchoolAnnouncement to fetch.
     */
    where?: SchoolAnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolAnnouncements to fetch.
     */
    orderBy?: SchoolAnnouncementOrderByWithRelationInput | SchoolAnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolAnnouncements.
     */
    cursor?: SchoolAnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolAnnouncements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolAnnouncements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolAnnouncements.
     */
    distinct?: SchoolAnnouncementScalarFieldEnum | SchoolAnnouncementScalarFieldEnum[]
  }

  /**
   * SchoolAnnouncement findMany
   */
  export type SchoolAnnouncementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAnnouncement
     */
    select?: SchoolAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAnnouncement
     */
    omit?: SchoolAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which SchoolAnnouncements to fetch.
     */
    where?: SchoolAnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolAnnouncements to fetch.
     */
    orderBy?: SchoolAnnouncementOrderByWithRelationInput | SchoolAnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SchoolAnnouncements.
     */
    cursor?: SchoolAnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolAnnouncements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolAnnouncements.
     */
    skip?: number
    distinct?: SchoolAnnouncementScalarFieldEnum | SchoolAnnouncementScalarFieldEnum[]
  }

  /**
   * SchoolAnnouncement create
   */
  export type SchoolAnnouncementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAnnouncement
     */
    select?: SchoolAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAnnouncement
     */
    omit?: SchoolAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAnnouncementInclude<ExtArgs> | null
    /**
     * The data needed to create a SchoolAnnouncement.
     */
    data: XOR<SchoolAnnouncementCreateInput, SchoolAnnouncementUncheckedCreateInput>
  }

  /**
   * SchoolAnnouncement createMany
   */
  export type SchoolAnnouncementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SchoolAnnouncements.
     */
    data: SchoolAnnouncementCreateManyInput | SchoolAnnouncementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SchoolAnnouncement update
   */
  export type SchoolAnnouncementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAnnouncement
     */
    select?: SchoolAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAnnouncement
     */
    omit?: SchoolAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAnnouncementInclude<ExtArgs> | null
    /**
     * The data needed to update a SchoolAnnouncement.
     */
    data: XOR<SchoolAnnouncementUpdateInput, SchoolAnnouncementUncheckedUpdateInput>
    /**
     * Choose, which SchoolAnnouncement to update.
     */
    where: SchoolAnnouncementWhereUniqueInput
  }

  /**
   * SchoolAnnouncement updateMany
   */
  export type SchoolAnnouncementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SchoolAnnouncements.
     */
    data: XOR<SchoolAnnouncementUpdateManyMutationInput, SchoolAnnouncementUncheckedUpdateManyInput>
    /**
     * Filter which SchoolAnnouncements to update
     */
    where?: SchoolAnnouncementWhereInput
    /**
     * Limit how many SchoolAnnouncements to update.
     */
    limit?: number
  }

  /**
   * SchoolAnnouncement upsert
   */
  export type SchoolAnnouncementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAnnouncement
     */
    select?: SchoolAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAnnouncement
     */
    omit?: SchoolAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAnnouncementInclude<ExtArgs> | null
    /**
     * The filter to search for the SchoolAnnouncement to update in case it exists.
     */
    where: SchoolAnnouncementWhereUniqueInput
    /**
     * In case the SchoolAnnouncement found by the `where` argument doesn't exist, create a new SchoolAnnouncement with this data.
     */
    create: XOR<SchoolAnnouncementCreateInput, SchoolAnnouncementUncheckedCreateInput>
    /**
     * In case the SchoolAnnouncement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolAnnouncementUpdateInput, SchoolAnnouncementUncheckedUpdateInput>
  }

  /**
   * SchoolAnnouncement delete
   */
  export type SchoolAnnouncementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAnnouncement
     */
    select?: SchoolAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAnnouncement
     */
    omit?: SchoolAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAnnouncementInclude<ExtArgs> | null
    /**
     * Filter which SchoolAnnouncement to delete.
     */
    where: SchoolAnnouncementWhereUniqueInput
  }

  /**
   * SchoolAnnouncement deleteMany
   */
  export type SchoolAnnouncementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolAnnouncements to delete
     */
    where?: SchoolAnnouncementWhereInput
    /**
     * Limit how many SchoolAnnouncements to delete.
     */
    limit?: number
  }

  /**
   * SchoolAnnouncement.createdByAdmin
   */
  export type SchoolAnnouncement$createdByAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAdmin
     */
    select?: SchoolAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAdmin
     */
    omit?: SchoolAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAdminInclude<ExtArgs> | null
    where?: SchoolAdminWhereInput
  }

  /**
   * SchoolAnnouncement without action
   */
  export type SchoolAnnouncementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAnnouncement
     */
    select?: SchoolAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAnnouncement
     */
    omit?: SchoolAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAnnouncementInclude<ExtArgs> | null
  }


  /**
   * Model ClassAnnouncement
   */

  export type AggregateClassAnnouncement = {
    _count: ClassAnnouncementCountAggregateOutputType | null
    _min: ClassAnnouncementMinAggregateOutputType | null
    _max: ClassAnnouncementMaxAggregateOutputType | null
  }

  export type ClassAnnouncementMinAggregateOutputType = {
    id: string | null
    schoolId: string | null
    classId: string | null
    title: string | null
    content: string | null
    publishDate: Date | null
    isPublished: boolean | null
    createdByTeacherId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassAnnouncementMaxAggregateOutputType = {
    id: string | null
    schoolId: string | null
    classId: string | null
    title: string | null
    content: string | null
    publishDate: Date | null
    isPublished: boolean | null
    createdByTeacherId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassAnnouncementCountAggregateOutputType = {
    id: number
    schoolId: number
    classId: number
    title: number
    content: number
    publishDate: number
    isPublished: number
    createdByTeacherId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClassAnnouncementMinAggregateInputType = {
    id?: true
    schoolId?: true
    classId?: true
    title?: true
    content?: true
    publishDate?: true
    isPublished?: true
    createdByTeacherId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassAnnouncementMaxAggregateInputType = {
    id?: true
    schoolId?: true
    classId?: true
    title?: true
    content?: true
    publishDate?: true
    isPublished?: true
    createdByTeacherId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassAnnouncementCountAggregateInputType = {
    id?: true
    schoolId?: true
    classId?: true
    title?: true
    content?: true
    publishDate?: true
    isPublished?: true
    createdByTeacherId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClassAnnouncementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassAnnouncement to aggregate.
     */
    where?: ClassAnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassAnnouncements to fetch.
     */
    orderBy?: ClassAnnouncementOrderByWithRelationInput | ClassAnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassAnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassAnnouncements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassAnnouncements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassAnnouncements
    **/
    _count?: true | ClassAnnouncementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassAnnouncementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassAnnouncementMaxAggregateInputType
  }

  export type GetClassAnnouncementAggregateType<T extends ClassAnnouncementAggregateArgs> = {
        [P in keyof T & keyof AggregateClassAnnouncement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassAnnouncement[P]>
      : GetScalarType<T[P], AggregateClassAnnouncement[P]>
  }




  export type ClassAnnouncementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassAnnouncementWhereInput
    orderBy?: ClassAnnouncementOrderByWithAggregationInput | ClassAnnouncementOrderByWithAggregationInput[]
    by: ClassAnnouncementScalarFieldEnum[] | ClassAnnouncementScalarFieldEnum
    having?: ClassAnnouncementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassAnnouncementCountAggregateInputType | true
    _min?: ClassAnnouncementMinAggregateInputType
    _max?: ClassAnnouncementMaxAggregateInputType
  }

  export type ClassAnnouncementGroupByOutputType = {
    id: string
    schoolId: string
    classId: string
    title: string
    content: string
    publishDate: Date
    isPublished: boolean
    createdByTeacherId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ClassAnnouncementCountAggregateOutputType | null
    _min: ClassAnnouncementMinAggregateOutputType | null
    _max: ClassAnnouncementMaxAggregateOutputType | null
  }

  type GetClassAnnouncementGroupByPayload<T extends ClassAnnouncementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassAnnouncementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassAnnouncementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassAnnouncementGroupByOutputType[P]>
            : GetScalarType<T[P], ClassAnnouncementGroupByOutputType[P]>
        }
      >
    >


  export type ClassAnnouncementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    classId?: boolean
    title?: boolean
    content?: boolean
    publishDate?: boolean
    isPublished?: boolean
    createdByTeacherId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    createdByTeacher?: boolean | ClassAnnouncement$createdByTeacherArgs<ExtArgs>
  }, ExtArgs["result"]["classAnnouncement"]>



  export type ClassAnnouncementSelectScalar = {
    id?: boolean
    schoolId?: boolean
    classId?: boolean
    title?: boolean
    content?: boolean
    publishDate?: boolean
    isPublished?: boolean
    createdByTeacherId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClassAnnouncementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "schoolId" | "classId" | "title" | "content" | "publishDate" | "isPublished" | "createdByTeacherId" | "createdAt" | "updatedAt", ExtArgs["result"]["classAnnouncement"]>
  export type ClassAnnouncementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    createdByTeacher?: boolean | ClassAnnouncement$createdByTeacherArgs<ExtArgs>
  }

  export type $ClassAnnouncementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClassAnnouncement"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs>
      createdByTeacher: Prisma.$TeacherPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      schoolId: string
      classId: string
      title: string
      content: string
      publishDate: Date
      isPublished: boolean
      createdByTeacherId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["classAnnouncement"]>
    composites: {}
  }

  type ClassAnnouncementGetPayload<S extends boolean | null | undefined | ClassAnnouncementDefaultArgs> = $Result.GetResult<Prisma.$ClassAnnouncementPayload, S>

  type ClassAnnouncementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassAnnouncementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassAnnouncementCountAggregateInputType | true
    }

  export interface ClassAnnouncementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClassAnnouncement'], meta: { name: 'ClassAnnouncement' } }
    /**
     * Find zero or one ClassAnnouncement that matches the filter.
     * @param {ClassAnnouncementFindUniqueArgs} args - Arguments to find a ClassAnnouncement
     * @example
     * // Get one ClassAnnouncement
     * const classAnnouncement = await prisma.classAnnouncement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassAnnouncementFindUniqueArgs>(args: SelectSubset<T, ClassAnnouncementFindUniqueArgs<ExtArgs>>): Prisma__ClassAnnouncementClient<$Result.GetResult<Prisma.$ClassAnnouncementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClassAnnouncement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassAnnouncementFindUniqueOrThrowArgs} args - Arguments to find a ClassAnnouncement
     * @example
     * // Get one ClassAnnouncement
     * const classAnnouncement = await prisma.classAnnouncement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassAnnouncementFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassAnnouncementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassAnnouncementClient<$Result.GetResult<Prisma.$ClassAnnouncementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassAnnouncement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAnnouncementFindFirstArgs} args - Arguments to find a ClassAnnouncement
     * @example
     * // Get one ClassAnnouncement
     * const classAnnouncement = await prisma.classAnnouncement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassAnnouncementFindFirstArgs>(args?: SelectSubset<T, ClassAnnouncementFindFirstArgs<ExtArgs>>): Prisma__ClassAnnouncementClient<$Result.GetResult<Prisma.$ClassAnnouncementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassAnnouncement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAnnouncementFindFirstOrThrowArgs} args - Arguments to find a ClassAnnouncement
     * @example
     * // Get one ClassAnnouncement
     * const classAnnouncement = await prisma.classAnnouncement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassAnnouncementFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassAnnouncementFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassAnnouncementClient<$Result.GetResult<Prisma.$ClassAnnouncementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClassAnnouncements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAnnouncementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassAnnouncements
     * const classAnnouncements = await prisma.classAnnouncement.findMany()
     * 
     * // Get first 10 ClassAnnouncements
     * const classAnnouncements = await prisma.classAnnouncement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classAnnouncementWithIdOnly = await prisma.classAnnouncement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassAnnouncementFindManyArgs>(args?: SelectSubset<T, ClassAnnouncementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassAnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClassAnnouncement.
     * @param {ClassAnnouncementCreateArgs} args - Arguments to create a ClassAnnouncement.
     * @example
     * // Create one ClassAnnouncement
     * const ClassAnnouncement = await prisma.classAnnouncement.create({
     *   data: {
     *     // ... data to create a ClassAnnouncement
     *   }
     * })
     * 
     */
    create<T extends ClassAnnouncementCreateArgs>(args: SelectSubset<T, ClassAnnouncementCreateArgs<ExtArgs>>): Prisma__ClassAnnouncementClient<$Result.GetResult<Prisma.$ClassAnnouncementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClassAnnouncements.
     * @param {ClassAnnouncementCreateManyArgs} args - Arguments to create many ClassAnnouncements.
     * @example
     * // Create many ClassAnnouncements
     * const classAnnouncement = await prisma.classAnnouncement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassAnnouncementCreateManyArgs>(args?: SelectSubset<T, ClassAnnouncementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClassAnnouncement.
     * @param {ClassAnnouncementDeleteArgs} args - Arguments to delete one ClassAnnouncement.
     * @example
     * // Delete one ClassAnnouncement
     * const ClassAnnouncement = await prisma.classAnnouncement.delete({
     *   where: {
     *     // ... filter to delete one ClassAnnouncement
     *   }
     * })
     * 
     */
    delete<T extends ClassAnnouncementDeleteArgs>(args: SelectSubset<T, ClassAnnouncementDeleteArgs<ExtArgs>>): Prisma__ClassAnnouncementClient<$Result.GetResult<Prisma.$ClassAnnouncementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClassAnnouncement.
     * @param {ClassAnnouncementUpdateArgs} args - Arguments to update one ClassAnnouncement.
     * @example
     * // Update one ClassAnnouncement
     * const classAnnouncement = await prisma.classAnnouncement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassAnnouncementUpdateArgs>(args: SelectSubset<T, ClassAnnouncementUpdateArgs<ExtArgs>>): Prisma__ClassAnnouncementClient<$Result.GetResult<Prisma.$ClassAnnouncementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClassAnnouncements.
     * @param {ClassAnnouncementDeleteManyArgs} args - Arguments to filter ClassAnnouncements to delete.
     * @example
     * // Delete a few ClassAnnouncements
     * const { count } = await prisma.classAnnouncement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassAnnouncementDeleteManyArgs>(args?: SelectSubset<T, ClassAnnouncementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassAnnouncements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAnnouncementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassAnnouncements
     * const classAnnouncement = await prisma.classAnnouncement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassAnnouncementUpdateManyArgs>(args: SelectSubset<T, ClassAnnouncementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClassAnnouncement.
     * @param {ClassAnnouncementUpsertArgs} args - Arguments to update or create a ClassAnnouncement.
     * @example
     * // Update or create a ClassAnnouncement
     * const classAnnouncement = await prisma.classAnnouncement.upsert({
     *   create: {
     *     // ... data to create a ClassAnnouncement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassAnnouncement we want to update
     *   }
     * })
     */
    upsert<T extends ClassAnnouncementUpsertArgs>(args: SelectSubset<T, ClassAnnouncementUpsertArgs<ExtArgs>>): Prisma__ClassAnnouncementClient<$Result.GetResult<Prisma.$ClassAnnouncementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClassAnnouncements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAnnouncementCountArgs} args - Arguments to filter ClassAnnouncements to count.
     * @example
     * // Count the number of ClassAnnouncements
     * const count = await prisma.classAnnouncement.count({
     *   where: {
     *     // ... the filter for the ClassAnnouncements we want to count
     *   }
     * })
    **/
    count<T extends ClassAnnouncementCountArgs>(
      args?: Subset<T, ClassAnnouncementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassAnnouncementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassAnnouncement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAnnouncementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassAnnouncementAggregateArgs>(args: Subset<T, ClassAnnouncementAggregateArgs>): Prisma.PrismaPromise<GetClassAnnouncementAggregateType<T>>

    /**
     * Group by ClassAnnouncement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAnnouncementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassAnnouncementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassAnnouncementGroupByArgs['orderBy'] }
        : { orderBy?: ClassAnnouncementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassAnnouncementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassAnnouncementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClassAnnouncement model
   */
  readonly fields: ClassAnnouncementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassAnnouncement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassAnnouncementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdByTeacher<T extends ClassAnnouncement$createdByTeacherArgs<ExtArgs> = {}>(args?: Subset<T, ClassAnnouncement$createdByTeacherArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClassAnnouncement model
   */
  interface ClassAnnouncementFieldRefs {
    readonly id: FieldRef<"ClassAnnouncement", 'String'>
    readonly schoolId: FieldRef<"ClassAnnouncement", 'String'>
    readonly classId: FieldRef<"ClassAnnouncement", 'String'>
    readonly title: FieldRef<"ClassAnnouncement", 'String'>
    readonly content: FieldRef<"ClassAnnouncement", 'String'>
    readonly publishDate: FieldRef<"ClassAnnouncement", 'DateTime'>
    readonly isPublished: FieldRef<"ClassAnnouncement", 'Boolean'>
    readonly createdByTeacherId: FieldRef<"ClassAnnouncement", 'String'>
    readonly createdAt: FieldRef<"ClassAnnouncement", 'DateTime'>
    readonly updatedAt: FieldRef<"ClassAnnouncement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClassAnnouncement findUnique
   */
  export type ClassAnnouncementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassAnnouncement
     */
    select?: ClassAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassAnnouncement
     */
    omit?: ClassAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassAnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which ClassAnnouncement to fetch.
     */
    where: ClassAnnouncementWhereUniqueInput
  }

  /**
   * ClassAnnouncement findUniqueOrThrow
   */
  export type ClassAnnouncementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassAnnouncement
     */
    select?: ClassAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassAnnouncement
     */
    omit?: ClassAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassAnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which ClassAnnouncement to fetch.
     */
    where: ClassAnnouncementWhereUniqueInput
  }

  /**
   * ClassAnnouncement findFirst
   */
  export type ClassAnnouncementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassAnnouncement
     */
    select?: ClassAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassAnnouncement
     */
    omit?: ClassAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassAnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which ClassAnnouncement to fetch.
     */
    where?: ClassAnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassAnnouncements to fetch.
     */
    orderBy?: ClassAnnouncementOrderByWithRelationInput | ClassAnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassAnnouncements.
     */
    cursor?: ClassAnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassAnnouncements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassAnnouncements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassAnnouncements.
     */
    distinct?: ClassAnnouncementScalarFieldEnum | ClassAnnouncementScalarFieldEnum[]
  }

  /**
   * ClassAnnouncement findFirstOrThrow
   */
  export type ClassAnnouncementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassAnnouncement
     */
    select?: ClassAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassAnnouncement
     */
    omit?: ClassAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassAnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which ClassAnnouncement to fetch.
     */
    where?: ClassAnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassAnnouncements to fetch.
     */
    orderBy?: ClassAnnouncementOrderByWithRelationInput | ClassAnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassAnnouncements.
     */
    cursor?: ClassAnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassAnnouncements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassAnnouncements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassAnnouncements.
     */
    distinct?: ClassAnnouncementScalarFieldEnum | ClassAnnouncementScalarFieldEnum[]
  }

  /**
   * ClassAnnouncement findMany
   */
  export type ClassAnnouncementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassAnnouncement
     */
    select?: ClassAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassAnnouncement
     */
    omit?: ClassAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassAnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which ClassAnnouncements to fetch.
     */
    where?: ClassAnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassAnnouncements to fetch.
     */
    orderBy?: ClassAnnouncementOrderByWithRelationInput | ClassAnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassAnnouncements.
     */
    cursor?: ClassAnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassAnnouncements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassAnnouncements.
     */
    skip?: number
    distinct?: ClassAnnouncementScalarFieldEnum | ClassAnnouncementScalarFieldEnum[]
  }

  /**
   * ClassAnnouncement create
   */
  export type ClassAnnouncementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassAnnouncement
     */
    select?: ClassAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassAnnouncement
     */
    omit?: ClassAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassAnnouncementInclude<ExtArgs> | null
    /**
     * The data needed to create a ClassAnnouncement.
     */
    data: XOR<ClassAnnouncementCreateInput, ClassAnnouncementUncheckedCreateInput>
  }

  /**
   * ClassAnnouncement createMany
   */
  export type ClassAnnouncementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClassAnnouncements.
     */
    data: ClassAnnouncementCreateManyInput | ClassAnnouncementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClassAnnouncement update
   */
  export type ClassAnnouncementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassAnnouncement
     */
    select?: ClassAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassAnnouncement
     */
    omit?: ClassAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassAnnouncementInclude<ExtArgs> | null
    /**
     * The data needed to update a ClassAnnouncement.
     */
    data: XOR<ClassAnnouncementUpdateInput, ClassAnnouncementUncheckedUpdateInput>
    /**
     * Choose, which ClassAnnouncement to update.
     */
    where: ClassAnnouncementWhereUniqueInput
  }

  /**
   * ClassAnnouncement updateMany
   */
  export type ClassAnnouncementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClassAnnouncements.
     */
    data: XOR<ClassAnnouncementUpdateManyMutationInput, ClassAnnouncementUncheckedUpdateManyInput>
    /**
     * Filter which ClassAnnouncements to update
     */
    where?: ClassAnnouncementWhereInput
    /**
     * Limit how many ClassAnnouncements to update.
     */
    limit?: number
  }

  /**
   * ClassAnnouncement upsert
   */
  export type ClassAnnouncementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassAnnouncement
     */
    select?: ClassAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassAnnouncement
     */
    omit?: ClassAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassAnnouncementInclude<ExtArgs> | null
    /**
     * The filter to search for the ClassAnnouncement to update in case it exists.
     */
    where: ClassAnnouncementWhereUniqueInput
    /**
     * In case the ClassAnnouncement found by the `where` argument doesn't exist, create a new ClassAnnouncement with this data.
     */
    create: XOR<ClassAnnouncementCreateInput, ClassAnnouncementUncheckedCreateInput>
    /**
     * In case the ClassAnnouncement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassAnnouncementUpdateInput, ClassAnnouncementUncheckedUpdateInput>
  }

  /**
   * ClassAnnouncement delete
   */
  export type ClassAnnouncementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassAnnouncement
     */
    select?: ClassAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassAnnouncement
     */
    omit?: ClassAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassAnnouncementInclude<ExtArgs> | null
    /**
     * Filter which ClassAnnouncement to delete.
     */
    where: ClassAnnouncementWhereUniqueInput
  }

  /**
   * ClassAnnouncement deleteMany
   */
  export type ClassAnnouncementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassAnnouncements to delete
     */
    where?: ClassAnnouncementWhereInput
    /**
     * Limit how many ClassAnnouncements to delete.
     */
    limit?: number
  }

  /**
   * ClassAnnouncement.createdByTeacher
   */
  export type ClassAnnouncement$createdByTeacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    where?: TeacherWhereInput
  }

  /**
   * ClassAnnouncement without action
   */
  export type ClassAnnouncementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassAnnouncement
     */
    select?: ClassAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassAnnouncement
     */
    omit?: ClassAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassAnnouncementInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    hashedPassword: 'hashedPassword',
    firstName: 'firstName',
    lastName: 'lastName',
    phoneNumber: 'phoneNumber',
    profilePicture: 'profilePicture',
    isActive: 'isActive',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    token: 'token',
    expires: 'expires',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const SuperAdminScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SuperAdminScalarFieldEnum = (typeof SuperAdminScalarFieldEnum)[keyof typeof SuperAdminScalarFieldEnum]


  export const SchoolScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    city: 'city',
    stateOrRegion: 'stateOrRegion',
    country: 'country',
    postalCode: 'postalCode',
    phoneNumber: 'phoneNumber',
    schoolEmail: 'schoolEmail',
    website: 'website',
    logoUrl: 'logoUrl',
    currentAcademicYear: 'currentAcademicYear',
    currentTerm: 'currentTerm',
    currency: 'currency',
    timezone: 'timezone',
    isActive: 'isActive',
    createdBySuperAdminId: 'createdBySuperAdminId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolScalarFieldEnum = (typeof SchoolScalarFieldEnum)[keyof typeof SchoolScalarFieldEnum]


  export const SchoolAdminScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    schoolId: 'schoolId',
    jobTitle: 'jobTitle',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolAdminScalarFieldEnum = (typeof SchoolAdminScalarFieldEnum)[keyof typeof SchoolAdminScalarFieldEnum]


  export const TeacherScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    schoolId: 'schoolId',
    teacherIdNumber: 'teacherIdNumber',
    dateOfJoining: 'dateOfJoining',
    qualifications: 'qualifications',
    specialization: 'specialization',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeacherScalarFieldEnum = (typeof TeacherScalarFieldEnum)[keyof typeof TeacherScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    schoolId: 'schoolId',
    studentIdNumber: 'studentIdNumber',
    firstName: 'firstName',
    lastName: 'lastName',
    middleName: 'middleName',
    dateOfBirth: 'dateOfBirth',
    gender: 'gender',
    enrollmentDate: 'enrollmentDate',
    profilePictureUrl: 'profilePictureUrl',
    address: 'address',
    city: 'city',
    stateOrRegion: 'stateOrRegion',
    country: 'country',
    postalCode: 'postalCode',
    emergencyContactName: 'emergencyContactName',
    emergencyContactPhone: 'emergencyContactPhone',
    bloodGroup: 'bloodGroup',
    allergies: 'allergies',
    medicalNotes: 'medicalNotes',
    isActive: 'isActive',
    currentClassId: 'currentClassId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const ParentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    occupation: 'occupation',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ParentScalarFieldEnum = (typeof ParentScalarFieldEnum)[keyof typeof ParentScalarFieldEnum]


  export const StudentParentLinkScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    parentId: 'parentId',
    relationshipToStudent: 'relationshipToStudent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentParentLinkScalarFieldEnum = (typeof StudentParentLinkScalarFieldEnum)[keyof typeof StudentParentLinkScalarFieldEnum]


  export const ClassScalarFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    name: 'name',
    section: 'section',
    academicYear: 'academicYear',
    homeroomTeacherId: 'homeroomTeacherId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClassScalarFieldEnum = (typeof ClassScalarFieldEnum)[keyof typeof ClassScalarFieldEnum]


  export const StudentClassEnrollmentScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    classId: 'classId',
    academicYear: 'academicYear',
    enrollmentDate: 'enrollmentDate',
    isCurrent: 'isCurrent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentClassEnrollmentScalarFieldEnum = (typeof StudentClassEnrollmentScalarFieldEnum)[keyof typeof StudentClassEnrollmentScalarFieldEnum]


  export const SubjectScalarFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    name: 'name',
    code: 'code',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubjectScalarFieldEnum = (typeof SubjectScalarFieldEnum)[keyof typeof SubjectScalarFieldEnum]


  export const TimetableSlotScalarFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    classId: 'classId',
    subjectId: 'subjectId',
    teacherId: 'teacherId',
    dayOfWeek: 'dayOfWeek',
    startTime: 'startTime',
    endTime: 'endTime',
    room: 'room',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TimetableSlotScalarFieldEnum = (typeof TimetableSlotScalarFieldEnum)[keyof typeof TimetableSlotScalarFieldEnum]


  export const StudentAttendanceScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    date: 'date',
    status: 'status',
    remarks: 'remarks',
    academicYear: 'academicYear',
    term: 'term',
    classId: 'classId',
    subjectId: 'subjectId',
    timetableSlotId: 'timetableSlotId',
    recordedById: 'recordedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentAttendanceScalarFieldEnum = (typeof StudentAttendanceScalarFieldEnum)[keyof typeof StudentAttendanceScalarFieldEnum]


  export const AssignmentScalarFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    classId: 'classId',
    subjectId: 'subjectId',
    teacherId: 'teacherId',
    title: 'title',
    description: 'description',
    maxPoints: 'maxPoints',
    dueDate: 'dueDate',
    academicYear: 'academicYear',
    term: 'term',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AssignmentScalarFieldEnum = (typeof AssignmentScalarFieldEnum)[keyof typeof AssignmentScalarFieldEnum]


  export const StudentGradeScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    subjectId: 'subjectId',
    assignmentId: 'assignmentId',
    teacherId: 'teacherId',
    grade: 'grade',
    numericValue: 'numericValue',
    comments: 'comments',
    academicYear: 'academicYear',
    term: 'term',
    dateRecorded: 'dateRecorded',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentGradeScalarFieldEnum = (typeof StudentGradeScalarFieldEnum)[keyof typeof StudentGradeScalarFieldEnum]


  export const FeeStructureScalarFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    name: 'name',
    description: 'description',
    amount: 'amount',
    academicYear: 'academicYear',
    term: 'term',
    frequency: 'frequency',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeeStructureScalarFieldEnum = (typeof FeeStructureScalarFieldEnum)[keyof typeof FeeStructureScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    studentId: 'studentId',
    parentToBillId: 'parentToBillId',
    invoiceNumber: 'invoiceNumber',
    issueDate: 'issueDate',
    dueDate: 'dueDate',
    totalAmount: 'totalAmount',
    paidAmount: 'paidAmount',
    status: 'status',
    notes: 'notes',
    academicYear: 'academicYear',
    term: 'term',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const InvoiceLineItemScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    feeStructureId: 'feeStructureId',
    studentId: 'studentId',
    description: 'description',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    amount: 'amount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceLineItemScalarFieldEnum = (typeof InvoiceLineItemScalarFieldEnum)[keyof typeof InvoiceLineItemScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    paymentDate: 'paymentDate',
    amount: 'amount',
    paymentMethod: 'paymentMethod',
    reference: 'reference',
    notes: 'notes',
    recordedById: 'recordedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const SchoolAnnouncementScalarFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    title: 'title',
    content: 'content',
    publishDate: 'publishDate',
    expiryDate: 'expiryDate',
    audience: 'audience',
    isPublished: 'isPublished',
    createdByAdminId: 'createdByAdminId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolAnnouncementScalarFieldEnum = (typeof SchoolAnnouncementScalarFieldEnum)[keyof typeof SchoolAnnouncementScalarFieldEnum]


  export const ClassAnnouncementScalarFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    classId: 'classId',
    title: 'title',
    content: 'content',
    publishDate: 'publishDate',
    isPublished: 'isPublished',
    createdByTeacherId: 'createdByTeacherId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClassAnnouncementScalarFieldEnum = (typeof ClassAnnouncementScalarFieldEnum)[keyof typeof ClassAnnouncementScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const UserOrderByRelevanceFieldEnum: {
    id: 'id',
    email: 'email',
    hashedPassword: 'hashedPassword',
    firstName: 'firstName',
    lastName: 'lastName',
    phoneNumber: 'phoneNumber',
    profilePicture: 'profilePicture'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const AccountOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountOrderByRelevanceFieldEnum = (typeof AccountOrderByRelevanceFieldEnum)[keyof typeof AccountOrderByRelevanceFieldEnum]


  export const SessionOrderByRelevanceFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId'
  };

  export type SessionOrderByRelevanceFieldEnum = (typeof SessionOrderByRelevanceFieldEnum)[keyof typeof SessionOrderByRelevanceFieldEnum]


  export const VerificationTokenOrderByRelevanceFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    token: 'token'
  };

  export type VerificationTokenOrderByRelevanceFieldEnum = (typeof VerificationTokenOrderByRelevanceFieldEnum)[keyof typeof VerificationTokenOrderByRelevanceFieldEnum]


  export const SuperAdminOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId'
  };

  export type SuperAdminOrderByRelevanceFieldEnum = (typeof SuperAdminOrderByRelevanceFieldEnum)[keyof typeof SuperAdminOrderByRelevanceFieldEnum]


  export const SchoolOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    city: 'city',
    stateOrRegion: 'stateOrRegion',
    country: 'country',
    postalCode: 'postalCode',
    phoneNumber: 'phoneNumber',
    schoolEmail: 'schoolEmail',
    website: 'website',
    logoUrl: 'logoUrl',
    currentAcademicYear: 'currentAcademicYear',
    currency: 'currency',
    timezone: 'timezone',
    createdBySuperAdminId: 'createdBySuperAdminId'
  };

  export type SchoolOrderByRelevanceFieldEnum = (typeof SchoolOrderByRelevanceFieldEnum)[keyof typeof SchoolOrderByRelevanceFieldEnum]


  export const SchoolAdminOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    schoolId: 'schoolId',
    jobTitle: 'jobTitle'
  };

  export type SchoolAdminOrderByRelevanceFieldEnum = (typeof SchoolAdminOrderByRelevanceFieldEnum)[keyof typeof SchoolAdminOrderByRelevanceFieldEnum]


  export const TeacherOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    schoolId: 'schoolId',
    teacherIdNumber: 'teacherIdNumber',
    qualifications: 'qualifications',
    specialization: 'specialization'
  };

  export type TeacherOrderByRelevanceFieldEnum = (typeof TeacherOrderByRelevanceFieldEnum)[keyof typeof TeacherOrderByRelevanceFieldEnum]


  export const StudentOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    schoolId: 'schoolId',
    studentIdNumber: 'studentIdNumber',
    firstName: 'firstName',
    lastName: 'lastName',
    middleName: 'middleName',
    profilePictureUrl: 'profilePictureUrl',
    address: 'address',
    city: 'city',
    stateOrRegion: 'stateOrRegion',
    country: 'country',
    postalCode: 'postalCode',
    emergencyContactName: 'emergencyContactName',
    emergencyContactPhone: 'emergencyContactPhone',
    bloodGroup: 'bloodGroup',
    allergies: 'allergies',
    medicalNotes: 'medicalNotes',
    currentClassId: 'currentClassId'
  };

  export type StudentOrderByRelevanceFieldEnum = (typeof StudentOrderByRelevanceFieldEnum)[keyof typeof StudentOrderByRelevanceFieldEnum]


  export const ParentOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    occupation: 'occupation'
  };

  export type ParentOrderByRelevanceFieldEnum = (typeof ParentOrderByRelevanceFieldEnum)[keyof typeof ParentOrderByRelevanceFieldEnum]


  export const StudentParentLinkOrderByRelevanceFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    parentId: 'parentId',
    relationshipToStudent: 'relationshipToStudent'
  };

  export type StudentParentLinkOrderByRelevanceFieldEnum = (typeof StudentParentLinkOrderByRelevanceFieldEnum)[keyof typeof StudentParentLinkOrderByRelevanceFieldEnum]


  export const ClassOrderByRelevanceFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    name: 'name',
    section: 'section',
    academicYear: 'academicYear',
    homeroomTeacherId: 'homeroomTeacherId'
  };

  export type ClassOrderByRelevanceFieldEnum = (typeof ClassOrderByRelevanceFieldEnum)[keyof typeof ClassOrderByRelevanceFieldEnum]


  export const StudentClassEnrollmentOrderByRelevanceFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    classId: 'classId',
    academicYear: 'academicYear'
  };

  export type StudentClassEnrollmentOrderByRelevanceFieldEnum = (typeof StudentClassEnrollmentOrderByRelevanceFieldEnum)[keyof typeof StudentClassEnrollmentOrderByRelevanceFieldEnum]


  export const SubjectOrderByRelevanceFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    name: 'name',
    code: 'code',
    description: 'description'
  };

  export type SubjectOrderByRelevanceFieldEnum = (typeof SubjectOrderByRelevanceFieldEnum)[keyof typeof SubjectOrderByRelevanceFieldEnum]


  export const TimetableSlotOrderByRelevanceFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    classId: 'classId',
    subjectId: 'subjectId',
    teacherId: 'teacherId',
    startTime: 'startTime',
    endTime: 'endTime',
    room: 'room'
  };

  export type TimetableSlotOrderByRelevanceFieldEnum = (typeof TimetableSlotOrderByRelevanceFieldEnum)[keyof typeof TimetableSlotOrderByRelevanceFieldEnum]


  export const StudentAttendanceOrderByRelevanceFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    remarks: 'remarks',
    academicYear: 'academicYear',
    classId: 'classId',
    subjectId: 'subjectId',
    timetableSlotId: 'timetableSlotId',
    recordedById: 'recordedById'
  };

  export type StudentAttendanceOrderByRelevanceFieldEnum = (typeof StudentAttendanceOrderByRelevanceFieldEnum)[keyof typeof StudentAttendanceOrderByRelevanceFieldEnum]


  export const AssignmentOrderByRelevanceFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    classId: 'classId',
    subjectId: 'subjectId',
    teacherId: 'teacherId',
    title: 'title',
    description: 'description',
    academicYear: 'academicYear'
  };

  export type AssignmentOrderByRelevanceFieldEnum = (typeof AssignmentOrderByRelevanceFieldEnum)[keyof typeof AssignmentOrderByRelevanceFieldEnum]


  export const StudentGradeOrderByRelevanceFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    subjectId: 'subjectId',
    assignmentId: 'assignmentId',
    teacherId: 'teacherId',
    grade: 'grade',
    comments: 'comments',
    academicYear: 'academicYear'
  };

  export type StudentGradeOrderByRelevanceFieldEnum = (typeof StudentGradeOrderByRelevanceFieldEnum)[keyof typeof StudentGradeOrderByRelevanceFieldEnum]


  export const FeeStructureOrderByRelevanceFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    name: 'name',
    description: 'description',
    academicYear: 'academicYear',
    frequency: 'frequency'
  };

  export type FeeStructureOrderByRelevanceFieldEnum = (typeof FeeStructureOrderByRelevanceFieldEnum)[keyof typeof FeeStructureOrderByRelevanceFieldEnum]


  export const InvoiceOrderByRelevanceFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    studentId: 'studentId',
    parentToBillId: 'parentToBillId',
    invoiceNumber: 'invoiceNumber',
    notes: 'notes',
    academicYear: 'academicYear'
  };

  export type InvoiceOrderByRelevanceFieldEnum = (typeof InvoiceOrderByRelevanceFieldEnum)[keyof typeof InvoiceOrderByRelevanceFieldEnum]


  export const InvoiceLineItemOrderByRelevanceFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    feeStructureId: 'feeStructureId',
    studentId: 'studentId',
    description: 'description'
  };

  export type InvoiceLineItemOrderByRelevanceFieldEnum = (typeof InvoiceLineItemOrderByRelevanceFieldEnum)[keyof typeof InvoiceLineItemOrderByRelevanceFieldEnum]


  export const PaymentOrderByRelevanceFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    paymentMethod: 'paymentMethod',
    reference: 'reference',
    notes: 'notes',
    recordedById: 'recordedById'
  };

  export type PaymentOrderByRelevanceFieldEnum = (typeof PaymentOrderByRelevanceFieldEnum)[keyof typeof PaymentOrderByRelevanceFieldEnum]


  export const SchoolAnnouncementOrderByRelevanceFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    title: 'title',
    content: 'content',
    audience: 'audience',
    createdByAdminId: 'createdByAdminId'
  };

  export type SchoolAnnouncementOrderByRelevanceFieldEnum = (typeof SchoolAnnouncementOrderByRelevanceFieldEnum)[keyof typeof SchoolAnnouncementOrderByRelevanceFieldEnum]


  export const ClassAnnouncementOrderByRelevanceFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    classId: 'classId',
    title: 'title',
    content: 'content',
    createdByTeacherId: 'createdByTeacherId'
  };

  export type ClassAnnouncementOrderByRelevanceFieldEnum = (typeof ClassAnnouncementOrderByRelevanceFieldEnum)[keyof typeof ClassAnnouncementOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'TermPeriod'
   */
  export type EnumTermPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TermPeriod'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'DayOfWeek'
   */
  export type EnumDayOfWeekFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DayOfWeek'>
    


  /**
   * Reference to a field of type 'AttendanceStatus'
   */
  export type EnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    hashedPassword?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    phoneNumber?: StringNullableFilter<"User"> | string | null
    profilePicture?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    superAdmin?: XOR<SuperAdminNullableScalarRelationFilter, SuperAdminWhereInput> | null
    schoolAdmins?: SchoolAdminListRelationFilter
    teacherLinks?: TeacherListRelationFilter
    studentLink?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    parentLink?: XOR<ParentNullableScalarRelationFilter, ParentWhereInput> | null
    recordedAttendances?: StudentAttendanceListRelationFilter
    recordedPayments?: PaymentListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    hashedPassword?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    profilePicture?: SortOrderInput | SortOrder
    isActive?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    superAdmin?: SuperAdminOrderByWithRelationInput
    schoolAdmins?: SchoolAdminOrderByRelationAggregateInput
    teacherLinks?: TeacherOrderByRelationAggregateInput
    studentLink?: StudentOrderByWithRelationInput
    parentLink?: ParentOrderByWithRelationInput
    recordedAttendances?: StudentAttendanceOrderByRelationAggregateInput
    recordedPayments?: PaymentOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    phoneNumber?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    hashedPassword?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    profilePicture?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    superAdmin?: XOR<SuperAdminNullableScalarRelationFilter, SuperAdminWhereInput> | null
    schoolAdmins?: SchoolAdminListRelationFilter
    teacherLinks?: TeacherListRelationFilter
    studentLink?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    parentLink?: XOR<ParentNullableScalarRelationFilter, ParentWhereInput> | null
    recordedAttendances?: StudentAttendanceListRelationFilter
    recordedPayments?: PaymentListRelationFilter
  }, "id" | "email" | "phoneNumber">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    hashedPassword?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    profilePicture?: SortOrderInput | SortOrder
    isActive?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    hashedPassword?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    profilePicture?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: AccountOrderByRelevanceInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: SessionOrderByRelevanceInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    id?: StringFilter<"VerificationToken"> | string
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
    createdAt?: DateTimeFilter<"VerificationToken"> | Date | string
    updatedAt?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: VerificationTokenOrderByRelevanceInput
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
    createdAt?: DateTimeFilter<"VerificationToken"> | Date | string
    updatedAt?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "id" | "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VerificationToken"> | string
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type SuperAdminWhereInput = {
    AND?: SuperAdminWhereInput | SuperAdminWhereInput[]
    OR?: SuperAdminWhereInput[]
    NOT?: SuperAdminWhereInput | SuperAdminWhereInput[]
    id?: StringFilter<"SuperAdmin"> | string
    userId?: StringFilter<"SuperAdmin"> | string
    createdAt?: DateTimeFilter<"SuperAdmin"> | Date | string
    updatedAt?: DateTimeFilter<"SuperAdmin"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    schoolsCreated?: SchoolListRelationFilter
  }

  export type SuperAdminOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    schoolsCreated?: SchoolOrderByRelationAggregateInput
    _relevance?: SuperAdminOrderByRelevanceInput
  }

  export type SuperAdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: SuperAdminWhereInput | SuperAdminWhereInput[]
    OR?: SuperAdminWhereInput[]
    NOT?: SuperAdminWhereInput | SuperAdminWhereInput[]
    createdAt?: DateTimeFilter<"SuperAdmin"> | Date | string
    updatedAt?: DateTimeFilter<"SuperAdmin"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    schoolsCreated?: SchoolListRelationFilter
  }, "id" | "userId">

  export type SuperAdminOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SuperAdminCountOrderByAggregateInput
    _max?: SuperAdminMaxOrderByAggregateInput
    _min?: SuperAdminMinOrderByAggregateInput
  }

  export type SuperAdminScalarWhereWithAggregatesInput = {
    AND?: SuperAdminScalarWhereWithAggregatesInput | SuperAdminScalarWhereWithAggregatesInput[]
    OR?: SuperAdminScalarWhereWithAggregatesInput[]
    NOT?: SuperAdminScalarWhereWithAggregatesInput | SuperAdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SuperAdmin"> | string
    userId?: StringWithAggregatesFilter<"SuperAdmin"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SuperAdmin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SuperAdmin"> | Date | string
  }

  export type SchoolWhereInput = {
    AND?: SchoolWhereInput | SchoolWhereInput[]
    OR?: SchoolWhereInput[]
    NOT?: SchoolWhereInput | SchoolWhereInput[]
    id?: StringFilter<"School"> | string
    name?: StringFilter<"School"> | string
    address?: StringNullableFilter<"School"> | string | null
    city?: StringNullableFilter<"School"> | string | null
    stateOrRegion?: StringNullableFilter<"School"> | string | null
    country?: StringNullableFilter<"School"> | string | null
    postalCode?: StringNullableFilter<"School"> | string | null
    phoneNumber?: StringNullableFilter<"School"> | string | null
    schoolEmail?: StringFilter<"School"> | string
    website?: StringNullableFilter<"School"> | string | null
    logoUrl?: StringNullableFilter<"School"> | string | null
    currentAcademicYear?: StringNullableFilter<"School"> | string | null
    currentTerm?: EnumTermPeriodNullableFilter<"School"> | $Enums.TermPeriod | null
    currency?: StringFilter<"School"> | string
    timezone?: StringFilter<"School"> | string
    isActive?: BoolFilter<"School"> | boolean
    createdBySuperAdminId?: StringNullableFilter<"School"> | string | null
    createdAt?: DateTimeFilter<"School"> | Date | string
    updatedAt?: DateTimeFilter<"School"> | Date | string
    createdBySuperAdmin?: XOR<SuperAdminNullableScalarRelationFilter, SuperAdminWhereInput> | null
    admins?: SchoolAdminListRelationFilter
    teachers?: TeacherListRelationFilter
    students?: StudentListRelationFilter
    classes?: ClassListRelationFilter
    subjects?: SubjectListRelationFilter
    feeStructures?: FeeStructureListRelationFilter
    invoices?: InvoiceListRelationFilter
    timetableSlots?: TimetableSlotListRelationFilter
    announcements?: SchoolAnnouncementListRelationFilter
    classAnnouncements?: ClassAnnouncementListRelationFilter
  }

  export type SchoolOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    stateOrRegion?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    schoolEmail?: SortOrder
    website?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    currentAcademicYear?: SortOrderInput | SortOrder
    currentTerm?: SortOrderInput | SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    isActive?: SortOrder
    createdBySuperAdminId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBySuperAdmin?: SuperAdminOrderByWithRelationInput
    admins?: SchoolAdminOrderByRelationAggregateInput
    teachers?: TeacherOrderByRelationAggregateInput
    students?: StudentOrderByRelationAggregateInput
    classes?: ClassOrderByRelationAggregateInput
    subjects?: SubjectOrderByRelationAggregateInput
    feeStructures?: FeeStructureOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    timetableSlots?: TimetableSlotOrderByRelationAggregateInput
    announcements?: SchoolAnnouncementOrderByRelationAggregateInput
    classAnnouncements?: ClassAnnouncementOrderByRelationAggregateInput
    _relevance?: SchoolOrderByRelevanceInput
  }

  export type SchoolWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    schoolEmail?: string
    AND?: SchoolWhereInput | SchoolWhereInput[]
    OR?: SchoolWhereInput[]
    NOT?: SchoolWhereInput | SchoolWhereInput[]
    name?: StringFilter<"School"> | string
    address?: StringNullableFilter<"School"> | string | null
    city?: StringNullableFilter<"School"> | string | null
    stateOrRegion?: StringNullableFilter<"School"> | string | null
    country?: StringNullableFilter<"School"> | string | null
    postalCode?: StringNullableFilter<"School"> | string | null
    phoneNumber?: StringNullableFilter<"School"> | string | null
    website?: StringNullableFilter<"School"> | string | null
    logoUrl?: StringNullableFilter<"School"> | string | null
    currentAcademicYear?: StringNullableFilter<"School"> | string | null
    currentTerm?: EnumTermPeriodNullableFilter<"School"> | $Enums.TermPeriod | null
    currency?: StringFilter<"School"> | string
    timezone?: StringFilter<"School"> | string
    isActive?: BoolFilter<"School"> | boolean
    createdBySuperAdminId?: StringNullableFilter<"School"> | string | null
    createdAt?: DateTimeFilter<"School"> | Date | string
    updatedAt?: DateTimeFilter<"School"> | Date | string
    createdBySuperAdmin?: XOR<SuperAdminNullableScalarRelationFilter, SuperAdminWhereInput> | null
    admins?: SchoolAdminListRelationFilter
    teachers?: TeacherListRelationFilter
    students?: StudentListRelationFilter
    classes?: ClassListRelationFilter
    subjects?: SubjectListRelationFilter
    feeStructures?: FeeStructureListRelationFilter
    invoices?: InvoiceListRelationFilter
    timetableSlots?: TimetableSlotListRelationFilter
    announcements?: SchoolAnnouncementListRelationFilter
    classAnnouncements?: ClassAnnouncementListRelationFilter
  }, "id" | "schoolEmail">

  export type SchoolOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    stateOrRegion?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    schoolEmail?: SortOrder
    website?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    currentAcademicYear?: SortOrderInput | SortOrder
    currentTerm?: SortOrderInput | SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    isActive?: SortOrder
    createdBySuperAdminId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SchoolCountOrderByAggregateInput
    _max?: SchoolMaxOrderByAggregateInput
    _min?: SchoolMinOrderByAggregateInput
  }

  export type SchoolScalarWhereWithAggregatesInput = {
    AND?: SchoolScalarWhereWithAggregatesInput | SchoolScalarWhereWithAggregatesInput[]
    OR?: SchoolScalarWhereWithAggregatesInput[]
    NOT?: SchoolScalarWhereWithAggregatesInput | SchoolScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"School"> | string
    name?: StringWithAggregatesFilter<"School"> | string
    address?: StringNullableWithAggregatesFilter<"School"> | string | null
    city?: StringNullableWithAggregatesFilter<"School"> | string | null
    stateOrRegion?: StringNullableWithAggregatesFilter<"School"> | string | null
    country?: StringNullableWithAggregatesFilter<"School"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"School"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"School"> | string | null
    schoolEmail?: StringWithAggregatesFilter<"School"> | string
    website?: StringNullableWithAggregatesFilter<"School"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"School"> | string | null
    currentAcademicYear?: StringNullableWithAggregatesFilter<"School"> | string | null
    currentTerm?: EnumTermPeriodNullableWithAggregatesFilter<"School"> | $Enums.TermPeriod | null
    currency?: StringWithAggregatesFilter<"School"> | string
    timezone?: StringWithAggregatesFilter<"School"> | string
    isActive?: BoolWithAggregatesFilter<"School"> | boolean
    createdBySuperAdminId?: StringNullableWithAggregatesFilter<"School"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"School"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"School"> | Date | string
  }

  export type SchoolAdminWhereInput = {
    AND?: SchoolAdminWhereInput | SchoolAdminWhereInput[]
    OR?: SchoolAdminWhereInput[]
    NOT?: SchoolAdminWhereInput | SchoolAdminWhereInput[]
    id?: StringFilter<"SchoolAdmin"> | string
    userId?: StringFilter<"SchoolAdmin"> | string
    schoolId?: StringFilter<"SchoolAdmin"> | string
    jobTitle?: StringNullableFilter<"SchoolAdmin"> | string | null
    createdAt?: DateTimeFilter<"SchoolAdmin"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolAdmin"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    createdSchoolAnnouncements?: SchoolAnnouncementListRelationFilter
  }

  export type SchoolAdminOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    schoolId?: SortOrder
    jobTitle?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    school?: SchoolOrderByWithRelationInput
    createdSchoolAnnouncements?: SchoolAnnouncementOrderByRelationAggregateInput
    _relevance?: SchoolAdminOrderByRelevanceInput
  }

  export type SchoolAdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_schoolId?: SchoolAdminUserIdSchoolIdCompoundUniqueInput
    AND?: SchoolAdminWhereInput | SchoolAdminWhereInput[]
    OR?: SchoolAdminWhereInput[]
    NOT?: SchoolAdminWhereInput | SchoolAdminWhereInput[]
    userId?: StringFilter<"SchoolAdmin"> | string
    schoolId?: StringFilter<"SchoolAdmin"> | string
    jobTitle?: StringNullableFilter<"SchoolAdmin"> | string | null
    createdAt?: DateTimeFilter<"SchoolAdmin"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolAdmin"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    createdSchoolAnnouncements?: SchoolAnnouncementListRelationFilter
  }, "id" | "userId_schoolId">

  export type SchoolAdminOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    schoolId?: SortOrder
    jobTitle?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SchoolAdminCountOrderByAggregateInput
    _max?: SchoolAdminMaxOrderByAggregateInput
    _min?: SchoolAdminMinOrderByAggregateInput
  }

  export type SchoolAdminScalarWhereWithAggregatesInput = {
    AND?: SchoolAdminScalarWhereWithAggregatesInput | SchoolAdminScalarWhereWithAggregatesInput[]
    OR?: SchoolAdminScalarWhereWithAggregatesInput[]
    NOT?: SchoolAdminScalarWhereWithAggregatesInput | SchoolAdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SchoolAdmin"> | string
    userId?: StringWithAggregatesFilter<"SchoolAdmin"> | string
    schoolId?: StringWithAggregatesFilter<"SchoolAdmin"> | string
    jobTitle?: StringNullableWithAggregatesFilter<"SchoolAdmin"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SchoolAdmin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SchoolAdmin"> | Date | string
  }

  export type TeacherWhereInput = {
    AND?: TeacherWhereInput | TeacherWhereInput[]
    OR?: TeacherWhereInput[]
    NOT?: TeacherWhereInput | TeacherWhereInput[]
    id?: StringFilter<"Teacher"> | string
    userId?: StringFilter<"Teacher"> | string
    schoolId?: StringFilter<"Teacher"> | string
    teacherIdNumber?: StringNullableFilter<"Teacher"> | string | null
    dateOfJoining?: DateTimeNullableFilter<"Teacher"> | Date | string | null
    qualifications?: StringNullableFilter<"Teacher"> | string | null
    specialization?: StringNullableFilter<"Teacher"> | string | null
    createdAt?: DateTimeFilter<"Teacher"> | Date | string
    updatedAt?: DateTimeFilter<"Teacher"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    classTeacherOf?: ClassListRelationFilter
    timetableSlots?: TimetableSlotListRelationFilter
    gradesGiven?: StudentGradeListRelationFilter
    assignmentsCreated?: AssignmentListRelationFilter
    createdClassAnnouncements?: ClassAnnouncementListRelationFilter
  }

  export type TeacherOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    schoolId?: SortOrder
    teacherIdNumber?: SortOrderInput | SortOrder
    dateOfJoining?: SortOrderInput | SortOrder
    qualifications?: SortOrderInput | SortOrder
    specialization?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    school?: SchoolOrderByWithRelationInput
    classTeacherOf?: ClassOrderByRelationAggregateInput
    timetableSlots?: TimetableSlotOrderByRelationAggregateInput
    gradesGiven?: StudentGradeOrderByRelationAggregateInput
    assignmentsCreated?: AssignmentOrderByRelationAggregateInput
    createdClassAnnouncements?: ClassAnnouncementOrderByRelationAggregateInput
    _relevance?: TeacherOrderByRelevanceInput
  }

  export type TeacherWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_schoolId?: TeacherUserIdSchoolIdCompoundUniqueInput
    schoolId_teacherIdNumber?: TeacherSchoolIdTeacherIdNumberCompoundUniqueInput
    AND?: TeacherWhereInput | TeacherWhereInput[]
    OR?: TeacherWhereInput[]
    NOT?: TeacherWhereInput | TeacherWhereInput[]
    userId?: StringFilter<"Teacher"> | string
    schoolId?: StringFilter<"Teacher"> | string
    teacherIdNumber?: StringNullableFilter<"Teacher"> | string | null
    dateOfJoining?: DateTimeNullableFilter<"Teacher"> | Date | string | null
    qualifications?: StringNullableFilter<"Teacher"> | string | null
    specialization?: StringNullableFilter<"Teacher"> | string | null
    createdAt?: DateTimeFilter<"Teacher"> | Date | string
    updatedAt?: DateTimeFilter<"Teacher"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    classTeacherOf?: ClassListRelationFilter
    timetableSlots?: TimetableSlotListRelationFilter
    gradesGiven?: StudentGradeListRelationFilter
    assignmentsCreated?: AssignmentListRelationFilter
    createdClassAnnouncements?: ClassAnnouncementListRelationFilter
  }, "id" | "userId_schoolId" | "schoolId_teacherIdNumber">

  export type TeacherOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    schoolId?: SortOrder
    teacherIdNumber?: SortOrderInput | SortOrder
    dateOfJoining?: SortOrderInput | SortOrder
    qualifications?: SortOrderInput | SortOrder
    specialization?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeacherCountOrderByAggregateInput
    _max?: TeacherMaxOrderByAggregateInput
    _min?: TeacherMinOrderByAggregateInput
  }

  export type TeacherScalarWhereWithAggregatesInput = {
    AND?: TeacherScalarWhereWithAggregatesInput | TeacherScalarWhereWithAggregatesInput[]
    OR?: TeacherScalarWhereWithAggregatesInput[]
    NOT?: TeacherScalarWhereWithAggregatesInput | TeacherScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Teacher"> | string
    userId?: StringWithAggregatesFilter<"Teacher"> | string
    schoolId?: StringWithAggregatesFilter<"Teacher"> | string
    teacherIdNumber?: StringNullableWithAggregatesFilter<"Teacher"> | string | null
    dateOfJoining?: DateTimeNullableWithAggregatesFilter<"Teacher"> | Date | string | null
    qualifications?: StringNullableWithAggregatesFilter<"Teacher"> | string | null
    specialization?: StringNullableWithAggregatesFilter<"Teacher"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Teacher"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Teacher"> | Date | string
  }

  export type StudentWhereInput = {
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    id?: StringFilter<"Student"> | string
    userId?: StringNullableFilter<"Student"> | string | null
    schoolId?: StringFilter<"Student"> | string
    studentIdNumber?: StringFilter<"Student"> | string
    firstName?: StringFilter<"Student"> | string
    lastName?: StringFilter<"Student"> | string
    middleName?: StringNullableFilter<"Student"> | string | null
    dateOfBirth?: DateTimeFilter<"Student"> | Date | string
    gender?: EnumGenderFilter<"Student"> | $Enums.Gender
    enrollmentDate?: DateTimeFilter<"Student"> | Date | string
    profilePictureUrl?: StringNullableFilter<"Student"> | string | null
    address?: StringNullableFilter<"Student"> | string | null
    city?: StringNullableFilter<"Student"> | string | null
    stateOrRegion?: StringNullableFilter<"Student"> | string | null
    country?: StringNullableFilter<"Student"> | string | null
    postalCode?: StringNullableFilter<"Student"> | string | null
    emergencyContactName?: StringNullableFilter<"Student"> | string | null
    emergencyContactPhone?: StringNullableFilter<"Student"> | string | null
    bloodGroup?: StringNullableFilter<"Student"> | string | null
    allergies?: StringNullableFilter<"Student"> | string | null
    medicalNotes?: StringNullableFilter<"Student"> | string | null
    isActive?: BoolFilter<"Student"> | boolean
    currentClassId?: StringNullableFilter<"Student"> | string | null
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    currentClass?: XOR<ClassNullableScalarRelationFilter, ClassWhereInput> | null
    parents?: StudentParentLinkListRelationFilter
    enrollments?: StudentClassEnrollmentListRelationFilter
    attendances?: StudentAttendanceListRelationFilter
    grades?: StudentGradeListRelationFilter
    invoiceLineItems?: InvoiceLineItemListRelationFilter
    invoices?: InvoiceListRelationFilter
  }

  export type StudentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    studentIdNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    middleName?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    enrollmentDate?: SortOrder
    profilePictureUrl?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    stateOrRegion?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    bloodGroup?: SortOrderInput | SortOrder
    allergies?: SortOrderInput | SortOrder
    medicalNotes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    currentClassId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    school?: SchoolOrderByWithRelationInput
    currentClass?: ClassOrderByWithRelationInput
    parents?: StudentParentLinkOrderByRelationAggregateInput
    enrollments?: StudentClassEnrollmentOrderByRelationAggregateInput
    attendances?: StudentAttendanceOrderByRelationAggregateInput
    grades?: StudentGradeOrderByRelationAggregateInput
    invoiceLineItems?: InvoiceLineItemOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    _relevance?: StudentOrderByRelevanceInput
  }

  export type StudentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    schoolId_studentIdNumber?: StudentSchoolIdStudentIdNumberCompoundUniqueInput
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    schoolId?: StringFilter<"Student"> | string
    studentIdNumber?: StringFilter<"Student"> | string
    firstName?: StringFilter<"Student"> | string
    lastName?: StringFilter<"Student"> | string
    middleName?: StringNullableFilter<"Student"> | string | null
    dateOfBirth?: DateTimeFilter<"Student"> | Date | string
    gender?: EnumGenderFilter<"Student"> | $Enums.Gender
    enrollmentDate?: DateTimeFilter<"Student"> | Date | string
    profilePictureUrl?: StringNullableFilter<"Student"> | string | null
    address?: StringNullableFilter<"Student"> | string | null
    city?: StringNullableFilter<"Student"> | string | null
    stateOrRegion?: StringNullableFilter<"Student"> | string | null
    country?: StringNullableFilter<"Student"> | string | null
    postalCode?: StringNullableFilter<"Student"> | string | null
    emergencyContactName?: StringNullableFilter<"Student"> | string | null
    emergencyContactPhone?: StringNullableFilter<"Student"> | string | null
    bloodGroup?: StringNullableFilter<"Student"> | string | null
    allergies?: StringNullableFilter<"Student"> | string | null
    medicalNotes?: StringNullableFilter<"Student"> | string | null
    isActive?: BoolFilter<"Student"> | boolean
    currentClassId?: StringNullableFilter<"Student"> | string | null
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    currentClass?: XOR<ClassNullableScalarRelationFilter, ClassWhereInput> | null
    parents?: StudentParentLinkListRelationFilter
    enrollments?: StudentClassEnrollmentListRelationFilter
    attendances?: StudentAttendanceListRelationFilter
    grades?: StudentGradeListRelationFilter
    invoiceLineItems?: InvoiceLineItemListRelationFilter
    invoices?: InvoiceListRelationFilter
  }, "id" | "userId" | "schoolId_studentIdNumber">

  export type StudentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    studentIdNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    middleName?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    enrollmentDate?: SortOrder
    profilePictureUrl?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    stateOrRegion?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    bloodGroup?: SortOrderInput | SortOrder
    allergies?: SortOrderInput | SortOrder
    medicalNotes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    currentClassId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentCountOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    OR?: StudentScalarWhereWithAggregatesInput[]
    NOT?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Student"> | string
    userId?: StringNullableWithAggregatesFilter<"Student"> | string | null
    schoolId?: StringWithAggregatesFilter<"Student"> | string
    studentIdNumber?: StringWithAggregatesFilter<"Student"> | string
    firstName?: StringWithAggregatesFilter<"Student"> | string
    lastName?: StringWithAggregatesFilter<"Student"> | string
    middleName?: StringNullableWithAggregatesFilter<"Student"> | string | null
    dateOfBirth?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    gender?: EnumGenderWithAggregatesFilter<"Student"> | $Enums.Gender
    enrollmentDate?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    profilePictureUrl?: StringNullableWithAggregatesFilter<"Student"> | string | null
    address?: StringNullableWithAggregatesFilter<"Student"> | string | null
    city?: StringNullableWithAggregatesFilter<"Student"> | string | null
    stateOrRegion?: StringNullableWithAggregatesFilter<"Student"> | string | null
    country?: StringNullableWithAggregatesFilter<"Student"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"Student"> | string | null
    emergencyContactName?: StringNullableWithAggregatesFilter<"Student"> | string | null
    emergencyContactPhone?: StringNullableWithAggregatesFilter<"Student"> | string | null
    bloodGroup?: StringNullableWithAggregatesFilter<"Student"> | string | null
    allergies?: StringNullableWithAggregatesFilter<"Student"> | string | null
    medicalNotes?: StringNullableWithAggregatesFilter<"Student"> | string | null
    isActive?: BoolWithAggregatesFilter<"Student"> | boolean
    currentClassId?: StringNullableWithAggregatesFilter<"Student"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
  }

  export type ParentWhereInput = {
    AND?: ParentWhereInput | ParentWhereInput[]
    OR?: ParentWhereInput[]
    NOT?: ParentWhereInput | ParentWhereInput[]
    id?: StringFilter<"Parent"> | string
    userId?: StringFilter<"Parent"> | string
    occupation?: StringNullableFilter<"Parent"> | string | null
    createdAt?: DateTimeFilter<"Parent"> | Date | string
    updatedAt?: DateTimeFilter<"Parent"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    children?: StudentParentLinkListRelationFilter
    invoices?: InvoiceListRelationFilter
  }

  export type ParentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    occupation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    children?: StudentParentLinkOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    _relevance?: ParentOrderByRelevanceInput
  }

  export type ParentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ParentWhereInput | ParentWhereInput[]
    OR?: ParentWhereInput[]
    NOT?: ParentWhereInput | ParentWhereInput[]
    occupation?: StringNullableFilter<"Parent"> | string | null
    createdAt?: DateTimeFilter<"Parent"> | Date | string
    updatedAt?: DateTimeFilter<"Parent"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    children?: StudentParentLinkListRelationFilter
    invoices?: InvoiceListRelationFilter
  }, "id" | "userId">

  export type ParentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    occupation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ParentCountOrderByAggregateInput
    _max?: ParentMaxOrderByAggregateInput
    _min?: ParentMinOrderByAggregateInput
  }

  export type ParentScalarWhereWithAggregatesInput = {
    AND?: ParentScalarWhereWithAggregatesInput | ParentScalarWhereWithAggregatesInput[]
    OR?: ParentScalarWhereWithAggregatesInput[]
    NOT?: ParentScalarWhereWithAggregatesInput | ParentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Parent"> | string
    userId?: StringWithAggregatesFilter<"Parent"> | string
    occupation?: StringNullableWithAggregatesFilter<"Parent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Parent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Parent"> | Date | string
  }

  export type StudentParentLinkWhereInput = {
    AND?: StudentParentLinkWhereInput | StudentParentLinkWhereInput[]
    OR?: StudentParentLinkWhereInput[]
    NOT?: StudentParentLinkWhereInput | StudentParentLinkWhereInput[]
    id?: StringFilter<"StudentParentLink"> | string
    studentId?: StringFilter<"StudentParentLink"> | string
    parentId?: StringFilter<"StudentParentLink"> | string
    relationshipToStudent?: StringFilter<"StudentParentLink"> | string
    createdAt?: DateTimeFilter<"StudentParentLink"> | Date | string
    updatedAt?: DateTimeFilter<"StudentParentLink"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    parent?: XOR<ParentScalarRelationFilter, ParentWhereInput>
  }

  export type StudentParentLinkOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    parentId?: SortOrder
    relationshipToStudent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    parent?: ParentOrderByWithRelationInput
    _relevance?: StudentParentLinkOrderByRelevanceInput
  }

  export type StudentParentLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId_parentId?: StudentParentLinkStudentIdParentIdCompoundUniqueInput
    AND?: StudentParentLinkWhereInput | StudentParentLinkWhereInput[]
    OR?: StudentParentLinkWhereInput[]
    NOT?: StudentParentLinkWhereInput | StudentParentLinkWhereInput[]
    studentId?: StringFilter<"StudentParentLink"> | string
    parentId?: StringFilter<"StudentParentLink"> | string
    relationshipToStudent?: StringFilter<"StudentParentLink"> | string
    createdAt?: DateTimeFilter<"StudentParentLink"> | Date | string
    updatedAt?: DateTimeFilter<"StudentParentLink"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    parent?: XOR<ParentScalarRelationFilter, ParentWhereInput>
  }, "id" | "studentId_parentId">

  export type StudentParentLinkOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    parentId?: SortOrder
    relationshipToStudent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentParentLinkCountOrderByAggregateInput
    _max?: StudentParentLinkMaxOrderByAggregateInput
    _min?: StudentParentLinkMinOrderByAggregateInput
  }

  export type StudentParentLinkScalarWhereWithAggregatesInput = {
    AND?: StudentParentLinkScalarWhereWithAggregatesInput | StudentParentLinkScalarWhereWithAggregatesInput[]
    OR?: StudentParentLinkScalarWhereWithAggregatesInput[]
    NOT?: StudentParentLinkScalarWhereWithAggregatesInput | StudentParentLinkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentParentLink"> | string
    studentId?: StringWithAggregatesFilter<"StudentParentLink"> | string
    parentId?: StringWithAggregatesFilter<"StudentParentLink"> | string
    relationshipToStudent?: StringWithAggregatesFilter<"StudentParentLink"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StudentParentLink"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentParentLink"> | Date | string
  }

  export type ClassWhereInput = {
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    id?: StringFilter<"Class"> | string
    schoolId?: StringFilter<"Class"> | string
    name?: StringFilter<"Class"> | string
    section?: StringNullableFilter<"Class"> | string | null
    academicYear?: StringFilter<"Class"> | string
    homeroomTeacherId?: StringNullableFilter<"Class"> | string | null
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    homeroomTeacher?: XOR<TeacherNullableScalarRelationFilter, TeacherWhereInput> | null
    studentsEnrolled?: StudentClassEnrollmentListRelationFilter
    currentStudents?: StudentListRelationFilter
    timetableSlots?: TimetableSlotListRelationFilter
    assignments?: AssignmentListRelationFilter
    announcements?: ClassAnnouncementListRelationFilter
  }

  export type ClassOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    section?: SortOrderInput | SortOrder
    academicYear?: SortOrder
    homeroomTeacherId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    homeroomTeacher?: TeacherOrderByWithRelationInput
    studentsEnrolled?: StudentClassEnrollmentOrderByRelationAggregateInput
    currentStudents?: StudentOrderByRelationAggregateInput
    timetableSlots?: TimetableSlotOrderByRelationAggregateInput
    assignments?: AssignmentOrderByRelationAggregateInput
    announcements?: ClassAnnouncementOrderByRelationAggregateInput
    _relevance?: ClassOrderByRelevanceInput
  }

  export type ClassWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    schoolId_name_section_academicYear?: ClassSchoolIdNameSectionAcademicYearCompoundUniqueInput
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    schoolId?: StringFilter<"Class"> | string
    name?: StringFilter<"Class"> | string
    section?: StringNullableFilter<"Class"> | string | null
    academicYear?: StringFilter<"Class"> | string
    homeroomTeacherId?: StringNullableFilter<"Class"> | string | null
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    homeroomTeacher?: XOR<TeacherNullableScalarRelationFilter, TeacherWhereInput> | null
    studentsEnrolled?: StudentClassEnrollmentListRelationFilter
    currentStudents?: StudentListRelationFilter
    timetableSlots?: TimetableSlotListRelationFilter
    assignments?: AssignmentListRelationFilter
    announcements?: ClassAnnouncementListRelationFilter
  }, "id" | "schoolId_name_section_academicYear">

  export type ClassOrderByWithAggregationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    section?: SortOrderInput | SortOrder
    academicYear?: SortOrder
    homeroomTeacherId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClassCountOrderByAggregateInput
    _max?: ClassMaxOrderByAggregateInput
    _min?: ClassMinOrderByAggregateInput
  }

  export type ClassScalarWhereWithAggregatesInput = {
    AND?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    OR?: ClassScalarWhereWithAggregatesInput[]
    NOT?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Class"> | string
    schoolId?: StringWithAggregatesFilter<"Class"> | string
    name?: StringWithAggregatesFilter<"Class"> | string
    section?: StringNullableWithAggregatesFilter<"Class"> | string | null
    academicYear?: StringWithAggregatesFilter<"Class"> | string
    homeroomTeacherId?: StringNullableWithAggregatesFilter<"Class"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string
  }

  export type StudentClassEnrollmentWhereInput = {
    AND?: StudentClassEnrollmentWhereInput | StudentClassEnrollmentWhereInput[]
    OR?: StudentClassEnrollmentWhereInput[]
    NOT?: StudentClassEnrollmentWhereInput | StudentClassEnrollmentWhereInput[]
    id?: StringFilter<"StudentClassEnrollment"> | string
    studentId?: StringFilter<"StudentClassEnrollment"> | string
    classId?: StringFilter<"StudentClassEnrollment"> | string
    academicYear?: StringFilter<"StudentClassEnrollment"> | string
    enrollmentDate?: DateTimeFilter<"StudentClassEnrollment"> | Date | string
    isCurrent?: BoolFilter<"StudentClassEnrollment"> | boolean
    createdAt?: DateTimeFilter<"StudentClassEnrollment"> | Date | string
    updatedAt?: DateTimeFilter<"StudentClassEnrollment"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
  }

  export type StudentClassEnrollmentOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    academicYear?: SortOrder
    enrollmentDate?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
    _relevance?: StudentClassEnrollmentOrderByRelevanceInput
  }

  export type StudentClassEnrollmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId_classId_academicYear?: StudentClassEnrollmentStudentIdClassIdAcademicYearCompoundUniqueInput
    AND?: StudentClassEnrollmentWhereInput | StudentClassEnrollmentWhereInput[]
    OR?: StudentClassEnrollmentWhereInput[]
    NOT?: StudentClassEnrollmentWhereInput | StudentClassEnrollmentWhereInput[]
    studentId?: StringFilter<"StudentClassEnrollment"> | string
    classId?: StringFilter<"StudentClassEnrollment"> | string
    academicYear?: StringFilter<"StudentClassEnrollment"> | string
    enrollmentDate?: DateTimeFilter<"StudentClassEnrollment"> | Date | string
    isCurrent?: BoolFilter<"StudentClassEnrollment"> | boolean
    createdAt?: DateTimeFilter<"StudentClassEnrollment"> | Date | string
    updatedAt?: DateTimeFilter<"StudentClassEnrollment"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
  }, "id" | "studentId_classId_academicYear">

  export type StudentClassEnrollmentOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    academicYear?: SortOrder
    enrollmentDate?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentClassEnrollmentCountOrderByAggregateInput
    _max?: StudentClassEnrollmentMaxOrderByAggregateInput
    _min?: StudentClassEnrollmentMinOrderByAggregateInput
  }

  export type StudentClassEnrollmentScalarWhereWithAggregatesInput = {
    AND?: StudentClassEnrollmentScalarWhereWithAggregatesInput | StudentClassEnrollmentScalarWhereWithAggregatesInput[]
    OR?: StudentClassEnrollmentScalarWhereWithAggregatesInput[]
    NOT?: StudentClassEnrollmentScalarWhereWithAggregatesInput | StudentClassEnrollmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentClassEnrollment"> | string
    studentId?: StringWithAggregatesFilter<"StudentClassEnrollment"> | string
    classId?: StringWithAggregatesFilter<"StudentClassEnrollment"> | string
    academicYear?: StringWithAggregatesFilter<"StudentClassEnrollment"> | string
    enrollmentDate?: DateTimeWithAggregatesFilter<"StudentClassEnrollment"> | Date | string
    isCurrent?: BoolWithAggregatesFilter<"StudentClassEnrollment"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"StudentClassEnrollment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentClassEnrollment"> | Date | string
  }

  export type SubjectWhereInput = {
    AND?: SubjectWhereInput | SubjectWhereInput[]
    OR?: SubjectWhereInput[]
    NOT?: SubjectWhereInput | SubjectWhereInput[]
    id?: StringFilter<"Subject"> | string
    schoolId?: StringFilter<"Subject"> | string
    name?: StringFilter<"Subject"> | string
    code?: StringNullableFilter<"Subject"> | string | null
    description?: StringNullableFilter<"Subject"> | string | null
    createdAt?: DateTimeFilter<"Subject"> | Date | string
    updatedAt?: DateTimeFilter<"Subject"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    timetableSlots?: TimetableSlotListRelationFilter
    assignments?: AssignmentListRelationFilter
    grades?: StudentGradeListRelationFilter
  }

  export type SubjectOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    timetableSlots?: TimetableSlotOrderByRelationAggregateInput
    assignments?: AssignmentOrderByRelationAggregateInput
    grades?: StudentGradeOrderByRelationAggregateInput
    _relevance?: SubjectOrderByRelevanceInput
  }

  export type SubjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    schoolId_name?: SubjectSchoolIdNameCompoundUniqueInput
    schoolId_code?: SubjectSchoolIdCodeCompoundUniqueInput
    AND?: SubjectWhereInput | SubjectWhereInput[]
    OR?: SubjectWhereInput[]
    NOT?: SubjectWhereInput | SubjectWhereInput[]
    schoolId?: StringFilter<"Subject"> | string
    name?: StringFilter<"Subject"> | string
    code?: StringNullableFilter<"Subject"> | string | null
    description?: StringNullableFilter<"Subject"> | string | null
    createdAt?: DateTimeFilter<"Subject"> | Date | string
    updatedAt?: DateTimeFilter<"Subject"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    timetableSlots?: TimetableSlotListRelationFilter
    assignments?: AssignmentListRelationFilter
    grades?: StudentGradeListRelationFilter
  }, "id" | "schoolId_name" | "schoolId_code">

  export type SubjectOrderByWithAggregationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubjectCountOrderByAggregateInput
    _max?: SubjectMaxOrderByAggregateInput
    _min?: SubjectMinOrderByAggregateInput
  }

  export type SubjectScalarWhereWithAggregatesInput = {
    AND?: SubjectScalarWhereWithAggregatesInput | SubjectScalarWhereWithAggregatesInput[]
    OR?: SubjectScalarWhereWithAggregatesInput[]
    NOT?: SubjectScalarWhereWithAggregatesInput | SubjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subject"> | string
    schoolId?: StringWithAggregatesFilter<"Subject"> | string
    name?: StringWithAggregatesFilter<"Subject"> | string
    code?: StringNullableWithAggregatesFilter<"Subject"> | string | null
    description?: StringNullableWithAggregatesFilter<"Subject"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Subject"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subject"> | Date | string
  }

  export type TimetableSlotWhereInput = {
    AND?: TimetableSlotWhereInput | TimetableSlotWhereInput[]
    OR?: TimetableSlotWhereInput[]
    NOT?: TimetableSlotWhereInput | TimetableSlotWhereInput[]
    id?: StringFilter<"TimetableSlot"> | string
    schoolId?: StringFilter<"TimetableSlot"> | string
    classId?: StringFilter<"TimetableSlot"> | string
    subjectId?: StringFilter<"TimetableSlot"> | string
    teacherId?: StringFilter<"TimetableSlot"> | string
    dayOfWeek?: EnumDayOfWeekFilter<"TimetableSlot"> | $Enums.DayOfWeek
    startTime?: StringFilter<"TimetableSlot"> | string
    endTime?: StringFilter<"TimetableSlot"> | string
    room?: StringNullableFilter<"TimetableSlot"> | string | null
    createdAt?: DateTimeFilter<"TimetableSlot"> | Date | string
    updatedAt?: DateTimeFilter<"TimetableSlot"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    teacher?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    attendances?: StudentAttendanceListRelationFilter
  }

  export type TimetableSlotOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    teacherId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    room?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
    teacher?: TeacherOrderByWithRelationInput
    attendances?: StudentAttendanceOrderByRelationAggregateInput
    _relevance?: TimetableSlotOrderByRelevanceInput
  }

  export type TimetableSlotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TimetableSlotWhereInput | TimetableSlotWhereInput[]
    OR?: TimetableSlotWhereInput[]
    NOT?: TimetableSlotWhereInput | TimetableSlotWhereInput[]
    schoolId?: StringFilter<"TimetableSlot"> | string
    classId?: StringFilter<"TimetableSlot"> | string
    subjectId?: StringFilter<"TimetableSlot"> | string
    teacherId?: StringFilter<"TimetableSlot"> | string
    dayOfWeek?: EnumDayOfWeekFilter<"TimetableSlot"> | $Enums.DayOfWeek
    startTime?: StringFilter<"TimetableSlot"> | string
    endTime?: StringFilter<"TimetableSlot"> | string
    room?: StringNullableFilter<"TimetableSlot"> | string | null
    createdAt?: DateTimeFilter<"TimetableSlot"> | Date | string
    updatedAt?: DateTimeFilter<"TimetableSlot"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    teacher?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    attendances?: StudentAttendanceListRelationFilter
  }, "id">

  export type TimetableSlotOrderByWithAggregationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    teacherId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    room?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TimetableSlotCountOrderByAggregateInput
    _max?: TimetableSlotMaxOrderByAggregateInput
    _min?: TimetableSlotMinOrderByAggregateInput
  }

  export type TimetableSlotScalarWhereWithAggregatesInput = {
    AND?: TimetableSlotScalarWhereWithAggregatesInput | TimetableSlotScalarWhereWithAggregatesInput[]
    OR?: TimetableSlotScalarWhereWithAggregatesInput[]
    NOT?: TimetableSlotScalarWhereWithAggregatesInput | TimetableSlotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TimetableSlot"> | string
    schoolId?: StringWithAggregatesFilter<"TimetableSlot"> | string
    classId?: StringWithAggregatesFilter<"TimetableSlot"> | string
    subjectId?: StringWithAggregatesFilter<"TimetableSlot"> | string
    teacherId?: StringWithAggregatesFilter<"TimetableSlot"> | string
    dayOfWeek?: EnumDayOfWeekWithAggregatesFilter<"TimetableSlot"> | $Enums.DayOfWeek
    startTime?: StringWithAggregatesFilter<"TimetableSlot"> | string
    endTime?: StringWithAggregatesFilter<"TimetableSlot"> | string
    room?: StringNullableWithAggregatesFilter<"TimetableSlot"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TimetableSlot"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TimetableSlot"> | Date | string
  }

  export type StudentAttendanceWhereInput = {
    AND?: StudentAttendanceWhereInput | StudentAttendanceWhereInput[]
    OR?: StudentAttendanceWhereInput[]
    NOT?: StudentAttendanceWhereInput | StudentAttendanceWhereInput[]
    id?: StringFilter<"StudentAttendance"> | string
    studentId?: StringFilter<"StudentAttendance"> | string
    date?: DateTimeFilter<"StudentAttendance"> | Date | string
    status?: EnumAttendanceStatusFilter<"StudentAttendance"> | $Enums.AttendanceStatus
    remarks?: StringNullableFilter<"StudentAttendance"> | string | null
    academicYear?: StringFilter<"StudentAttendance"> | string
    term?: EnumTermPeriodFilter<"StudentAttendance"> | $Enums.TermPeriod
    classId?: StringNullableFilter<"StudentAttendance"> | string | null
    subjectId?: StringNullableFilter<"StudentAttendance"> | string | null
    timetableSlotId?: StringNullableFilter<"StudentAttendance"> | string | null
    recordedById?: StringNullableFilter<"StudentAttendance"> | string | null
    createdAt?: DateTimeFilter<"StudentAttendance"> | Date | string
    updatedAt?: DateTimeFilter<"StudentAttendance"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    timetableSlot?: XOR<TimetableSlotNullableScalarRelationFilter, TimetableSlotWhereInput> | null
    recordedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type StudentAttendanceOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    remarks?: SortOrderInput | SortOrder
    academicYear?: SortOrder
    term?: SortOrder
    classId?: SortOrderInput | SortOrder
    subjectId?: SortOrderInput | SortOrder
    timetableSlotId?: SortOrderInput | SortOrder
    recordedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    timetableSlot?: TimetableSlotOrderByWithRelationInput
    recordedBy?: UserOrderByWithRelationInput
    _relevance?: StudentAttendanceOrderByRelevanceInput
  }

  export type StudentAttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    unique_student_attendance_per_slot?: StudentAttendanceUnique_student_attendance_per_slotCompoundUniqueInput
    unique_student_attendance_per_class_subject?: StudentAttendanceUnique_student_attendance_per_class_subjectCompoundUniqueInput
    AND?: StudentAttendanceWhereInput | StudentAttendanceWhereInput[]
    OR?: StudentAttendanceWhereInput[]
    NOT?: StudentAttendanceWhereInput | StudentAttendanceWhereInput[]
    studentId?: StringFilter<"StudentAttendance"> | string
    date?: DateTimeFilter<"StudentAttendance"> | Date | string
    status?: EnumAttendanceStatusFilter<"StudentAttendance"> | $Enums.AttendanceStatus
    remarks?: StringNullableFilter<"StudentAttendance"> | string | null
    academicYear?: StringFilter<"StudentAttendance"> | string
    term?: EnumTermPeriodFilter<"StudentAttendance"> | $Enums.TermPeriod
    classId?: StringNullableFilter<"StudentAttendance"> | string | null
    subjectId?: StringNullableFilter<"StudentAttendance"> | string | null
    timetableSlotId?: StringNullableFilter<"StudentAttendance"> | string | null
    recordedById?: StringNullableFilter<"StudentAttendance"> | string | null
    createdAt?: DateTimeFilter<"StudentAttendance"> | Date | string
    updatedAt?: DateTimeFilter<"StudentAttendance"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    timetableSlot?: XOR<TimetableSlotNullableScalarRelationFilter, TimetableSlotWhereInput> | null
    recordedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "unique_student_attendance_per_slot" | "unique_student_attendance_per_class_subject">

  export type StudentAttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    remarks?: SortOrderInput | SortOrder
    academicYear?: SortOrder
    term?: SortOrder
    classId?: SortOrderInput | SortOrder
    subjectId?: SortOrderInput | SortOrder
    timetableSlotId?: SortOrderInput | SortOrder
    recordedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentAttendanceCountOrderByAggregateInput
    _max?: StudentAttendanceMaxOrderByAggregateInput
    _min?: StudentAttendanceMinOrderByAggregateInput
  }

  export type StudentAttendanceScalarWhereWithAggregatesInput = {
    AND?: StudentAttendanceScalarWhereWithAggregatesInput | StudentAttendanceScalarWhereWithAggregatesInput[]
    OR?: StudentAttendanceScalarWhereWithAggregatesInput[]
    NOT?: StudentAttendanceScalarWhereWithAggregatesInput | StudentAttendanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentAttendance"> | string
    studentId?: StringWithAggregatesFilter<"StudentAttendance"> | string
    date?: DateTimeWithAggregatesFilter<"StudentAttendance"> | Date | string
    status?: EnumAttendanceStatusWithAggregatesFilter<"StudentAttendance"> | $Enums.AttendanceStatus
    remarks?: StringNullableWithAggregatesFilter<"StudentAttendance"> | string | null
    academicYear?: StringWithAggregatesFilter<"StudentAttendance"> | string
    term?: EnumTermPeriodWithAggregatesFilter<"StudentAttendance"> | $Enums.TermPeriod
    classId?: StringNullableWithAggregatesFilter<"StudentAttendance"> | string | null
    subjectId?: StringNullableWithAggregatesFilter<"StudentAttendance"> | string | null
    timetableSlotId?: StringNullableWithAggregatesFilter<"StudentAttendance"> | string | null
    recordedById?: StringNullableWithAggregatesFilter<"StudentAttendance"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StudentAttendance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentAttendance"> | Date | string
  }

  export type AssignmentWhereInput = {
    AND?: AssignmentWhereInput | AssignmentWhereInput[]
    OR?: AssignmentWhereInput[]
    NOT?: AssignmentWhereInput | AssignmentWhereInput[]
    id?: StringFilter<"Assignment"> | string
    schoolId?: StringFilter<"Assignment"> | string
    classId?: StringFilter<"Assignment"> | string
    subjectId?: StringFilter<"Assignment"> | string
    teacherId?: StringFilter<"Assignment"> | string
    title?: StringFilter<"Assignment"> | string
    description?: StringNullableFilter<"Assignment"> | string | null
    maxPoints?: FloatNullableFilter<"Assignment"> | number | null
    dueDate?: DateTimeNullableFilter<"Assignment"> | Date | string | null
    academicYear?: StringFilter<"Assignment"> | string
    term?: EnumTermPeriodFilter<"Assignment"> | $Enums.TermPeriod
    createdAt?: DateTimeFilter<"Assignment"> | Date | string
    updatedAt?: DateTimeFilter<"Assignment"> | Date | string
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    teacher?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    grades?: StudentGradeListRelationFilter
  }

  export type AssignmentOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    teacherId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    maxPoints?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    academicYear?: SortOrder
    term?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    class?: ClassOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
    teacher?: TeacherOrderByWithRelationInput
    grades?: StudentGradeOrderByRelationAggregateInput
    _relevance?: AssignmentOrderByRelevanceInput
  }

  export type AssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AssignmentWhereInput | AssignmentWhereInput[]
    OR?: AssignmentWhereInput[]
    NOT?: AssignmentWhereInput | AssignmentWhereInput[]
    schoolId?: StringFilter<"Assignment"> | string
    classId?: StringFilter<"Assignment"> | string
    subjectId?: StringFilter<"Assignment"> | string
    teacherId?: StringFilter<"Assignment"> | string
    title?: StringFilter<"Assignment"> | string
    description?: StringNullableFilter<"Assignment"> | string | null
    maxPoints?: FloatNullableFilter<"Assignment"> | number | null
    dueDate?: DateTimeNullableFilter<"Assignment"> | Date | string | null
    academicYear?: StringFilter<"Assignment"> | string
    term?: EnumTermPeriodFilter<"Assignment"> | $Enums.TermPeriod
    createdAt?: DateTimeFilter<"Assignment"> | Date | string
    updatedAt?: DateTimeFilter<"Assignment"> | Date | string
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    teacher?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    grades?: StudentGradeListRelationFilter
  }, "id">

  export type AssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    teacherId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    maxPoints?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    academicYear?: SortOrder
    term?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AssignmentCountOrderByAggregateInput
    _avg?: AssignmentAvgOrderByAggregateInput
    _max?: AssignmentMaxOrderByAggregateInput
    _min?: AssignmentMinOrderByAggregateInput
    _sum?: AssignmentSumOrderByAggregateInput
  }

  export type AssignmentScalarWhereWithAggregatesInput = {
    AND?: AssignmentScalarWhereWithAggregatesInput | AssignmentScalarWhereWithAggregatesInput[]
    OR?: AssignmentScalarWhereWithAggregatesInput[]
    NOT?: AssignmentScalarWhereWithAggregatesInput | AssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Assignment"> | string
    schoolId?: StringWithAggregatesFilter<"Assignment"> | string
    classId?: StringWithAggregatesFilter<"Assignment"> | string
    subjectId?: StringWithAggregatesFilter<"Assignment"> | string
    teacherId?: StringWithAggregatesFilter<"Assignment"> | string
    title?: StringWithAggregatesFilter<"Assignment"> | string
    description?: StringNullableWithAggregatesFilter<"Assignment"> | string | null
    maxPoints?: FloatNullableWithAggregatesFilter<"Assignment"> | number | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"Assignment"> | Date | string | null
    academicYear?: StringWithAggregatesFilter<"Assignment"> | string
    term?: EnumTermPeriodWithAggregatesFilter<"Assignment"> | $Enums.TermPeriod
    createdAt?: DateTimeWithAggregatesFilter<"Assignment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Assignment"> | Date | string
  }

  export type StudentGradeWhereInput = {
    AND?: StudentGradeWhereInput | StudentGradeWhereInput[]
    OR?: StudentGradeWhereInput[]
    NOT?: StudentGradeWhereInput | StudentGradeWhereInput[]
    id?: StringFilter<"StudentGrade"> | string
    studentId?: StringFilter<"StudentGrade"> | string
    subjectId?: StringFilter<"StudentGrade"> | string
    assignmentId?: StringNullableFilter<"StudentGrade"> | string | null
    teacherId?: StringNullableFilter<"StudentGrade"> | string | null
    grade?: StringFilter<"StudentGrade"> | string
    numericValue?: FloatNullableFilter<"StudentGrade"> | number | null
    comments?: StringNullableFilter<"StudentGrade"> | string | null
    academicYear?: StringFilter<"StudentGrade"> | string
    term?: EnumTermPeriodFilter<"StudentGrade"> | $Enums.TermPeriod
    dateRecorded?: DateTimeFilter<"StudentGrade"> | Date | string
    createdAt?: DateTimeFilter<"StudentGrade"> | Date | string
    updatedAt?: DateTimeFilter<"StudentGrade"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    assignment?: XOR<AssignmentNullableScalarRelationFilter, AssignmentWhereInput> | null
    teacher?: XOR<TeacherNullableScalarRelationFilter, TeacherWhereInput> | null
  }

  export type StudentGradeOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    assignmentId?: SortOrderInput | SortOrder
    teacherId?: SortOrderInput | SortOrder
    grade?: SortOrder
    numericValue?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    academicYear?: SortOrder
    term?: SortOrder
    dateRecorded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
    assignment?: AssignmentOrderByWithRelationInput
    teacher?: TeacherOrderByWithRelationInput
    _relevance?: StudentGradeOrderByRelevanceInput
  }

  export type StudentGradeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId_subjectId_assignmentId_academicYear_term?: StudentGradeStudentIdSubjectIdAssignmentIdAcademicYearTermCompoundUniqueInput
    AND?: StudentGradeWhereInput | StudentGradeWhereInput[]
    OR?: StudentGradeWhereInput[]
    NOT?: StudentGradeWhereInput | StudentGradeWhereInput[]
    studentId?: StringFilter<"StudentGrade"> | string
    subjectId?: StringFilter<"StudentGrade"> | string
    assignmentId?: StringNullableFilter<"StudentGrade"> | string | null
    teacherId?: StringNullableFilter<"StudentGrade"> | string | null
    grade?: StringFilter<"StudentGrade"> | string
    numericValue?: FloatNullableFilter<"StudentGrade"> | number | null
    comments?: StringNullableFilter<"StudentGrade"> | string | null
    academicYear?: StringFilter<"StudentGrade"> | string
    term?: EnumTermPeriodFilter<"StudentGrade"> | $Enums.TermPeriod
    dateRecorded?: DateTimeFilter<"StudentGrade"> | Date | string
    createdAt?: DateTimeFilter<"StudentGrade"> | Date | string
    updatedAt?: DateTimeFilter<"StudentGrade"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    assignment?: XOR<AssignmentNullableScalarRelationFilter, AssignmentWhereInput> | null
    teacher?: XOR<TeacherNullableScalarRelationFilter, TeacherWhereInput> | null
  }, "id" | "studentId_subjectId_assignmentId_academicYear_term">

  export type StudentGradeOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    assignmentId?: SortOrderInput | SortOrder
    teacherId?: SortOrderInput | SortOrder
    grade?: SortOrder
    numericValue?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    academicYear?: SortOrder
    term?: SortOrder
    dateRecorded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentGradeCountOrderByAggregateInput
    _avg?: StudentGradeAvgOrderByAggregateInput
    _max?: StudentGradeMaxOrderByAggregateInput
    _min?: StudentGradeMinOrderByAggregateInput
    _sum?: StudentGradeSumOrderByAggregateInput
  }

  export type StudentGradeScalarWhereWithAggregatesInput = {
    AND?: StudentGradeScalarWhereWithAggregatesInput | StudentGradeScalarWhereWithAggregatesInput[]
    OR?: StudentGradeScalarWhereWithAggregatesInput[]
    NOT?: StudentGradeScalarWhereWithAggregatesInput | StudentGradeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentGrade"> | string
    studentId?: StringWithAggregatesFilter<"StudentGrade"> | string
    subjectId?: StringWithAggregatesFilter<"StudentGrade"> | string
    assignmentId?: StringNullableWithAggregatesFilter<"StudentGrade"> | string | null
    teacherId?: StringNullableWithAggregatesFilter<"StudentGrade"> | string | null
    grade?: StringWithAggregatesFilter<"StudentGrade"> | string
    numericValue?: FloatNullableWithAggregatesFilter<"StudentGrade"> | number | null
    comments?: StringNullableWithAggregatesFilter<"StudentGrade"> | string | null
    academicYear?: StringWithAggregatesFilter<"StudentGrade"> | string
    term?: EnumTermPeriodWithAggregatesFilter<"StudentGrade"> | $Enums.TermPeriod
    dateRecorded?: DateTimeWithAggregatesFilter<"StudentGrade"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"StudentGrade"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentGrade"> | Date | string
  }

  export type FeeStructureWhereInput = {
    AND?: FeeStructureWhereInput | FeeStructureWhereInput[]
    OR?: FeeStructureWhereInput[]
    NOT?: FeeStructureWhereInput | FeeStructureWhereInput[]
    id?: StringFilter<"FeeStructure"> | string
    schoolId?: StringFilter<"FeeStructure"> | string
    name?: StringFilter<"FeeStructure"> | string
    description?: StringNullableFilter<"FeeStructure"> | string | null
    amount?: DecimalFilter<"FeeStructure"> | Decimal | DecimalJsLike | number | string
    academicYear?: StringFilter<"FeeStructure"> | string
    term?: EnumTermPeriodNullableFilter<"FeeStructure"> | $Enums.TermPeriod | null
    frequency?: StringFilter<"FeeStructure"> | string
    createdAt?: DateTimeFilter<"FeeStructure"> | Date | string
    updatedAt?: DateTimeFilter<"FeeStructure"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    invoiceLineItems?: InvoiceLineItemListRelationFilter
  }

  export type FeeStructureOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    academicYear?: SortOrder
    term?: SortOrderInput | SortOrder
    frequency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    invoiceLineItems?: InvoiceLineItemOrderByRelationAggregateInput
    _relevance?: FeeStructureOrderByRelevanceInput
  }

  export type FeeStructureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    schoolId_name_academicYear_term?: FeeStructureSchoolIdNameAcademicYearTermCompoundUniqueInput
    AND?: FeeStructureWhereInput | FeeStructureWhereInput[]
    OR?: FeeStructureWhereInput[]
    NOT?: FeeStructureWhereInput | FeeStructureWhereInput[]
    schoolId?: StringFilter<"FeeStructure"> | string
    name?: StringFilter<"FeeStructure"> | string
    description?: StringNullableFilter<"FeeStructure"> | string | null
    amount?: DecimalFilter<"FeeStructure"> | Decimal | DecimalJsLike | number | string
    academicYear?: StringFilter<"FeeStructure"> | string
    term?: EnumTermPeriodNullableFilter<"FeeStructure"> | $Enums.TermPeriod | null
    frequency?: StringFilter<"FeeStructure"> | string
    createdAt?: DateTimeFilter<"FeeStructure"> | Date | string
    updatedAt?: DateTimeFilter<"FeeStructure"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    invoiceLineItems?: InvoiceLineItemListRelationFilter
  }, "id" | "schoolId_name_academicYear_term">

  export type FeeStructureOrderByWithAggregationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    academicYear?: SortOrder
    term?: SortOrderInput | SortOrder
    frequency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeeStructureCountOrderByAggregateInput
    _avg?: FeeStructureAvgOrderByAggregateInput
    _max?: FeeStructureMaxOrderByAggregateInput
    _min?: FeeStructureMinOrderByAggregateInput
    _sum?: FeeStructureSumOrderByAggregateInput
  }

  export type FeeStructureScalarWhereWithAggregatesInput = {
    AND?: FeeStructureScalarWhereWithAggregatesInput | FeeStructureScalarWhereWithAggregatesInput[]
    OR?: FeeStructureScalarWhereWithAggregatesInput[]
    NOT?: FeeStructureScalarWhereWithAggregatesInput | FeeStructureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeeStructure"> | string
    schoolId?: StringWithAggregatesFilter<"FeeStructure"> | string
    name?: StringWithAggregatesFilter<"FeeStructure"> | string
    description?: StringNullableWithAggregatesFilter<"FeeStructure"> | string | null
    amount?: DecimalWithAggregatesFilter<"FeeStructure"> | Decimal | DecimalJsLike | number | string
    academicYear?: StringWithAggregatesFilter<"FeeStructure"> | string
    term?: EnumTermPeriodNullableWithAggregatesFilter<"FeeStructure"> | $Enums.TermPeriod | null
    frequency?: StringWithAggregatesFilter<"FeeStructure"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FeeStructure"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FeeStructure"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    schoolId?: StringFilter<"Invoice"> | string
    studentId?: StringFilter<"Invoice"> | string
    parentToBillId?: StringNullableFilter<"Invoice"> | string | null
    invoiceNumber?: StringFilter<"Invoice"> | string
    issueDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    totalAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFilter<"Invoice"> | $Enums.PaymentStatus
    notes?: StringNullableFilter<"Invoice"> | string | null
    academicYear?: StringFilter<"Invoice"> | string
    term?: EnumTermPeriodFilter<"Invoice"> | $Enums.TermPeriod
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    parentToBill?: XOR<ParentNullableScalarRelationFilter, ParentWhereInput> | null
    lineItems?: InvoiceLineItemListRelationFilter
    payments?: PaymentListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    studentId?: SortOrder
    parentToBillId?: SortOrderInput | SortOrder
    invoiceNumber?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    academicYear?: SortOrder
    term?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
    parentToBill?: ParentOrderByWithRelationInput
    lineItems?: InvoiceLineItemOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    _relevance?: InvoiceOrderByRelevanceInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    schoolId_invoiceNumber?: InvoiceSchoolIdInvoiceNumberCompoundUniqueInput
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    schoolId?: StringFilter<"Invoice"> | string
    studentId?: StringFilter<"Invoice"> | string
    parentToBillId?: StringNullableFilter<"Invoice"> | string | null
    invoiceNumber?: StringFilter<"Invoice"> | string
    issueDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    totalAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFilter<"Invoice"> | $Enums.PaymentStatus
    notes?: StringNullableFilter<"Invoice"> | string | null
    academicYear?: StringFilter<"Invoice"> | string
    term?: EnumTermPeriodFilter<"Invoice"> | $Enums.TermPeriod
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    parentToBill?: XOR<ParentNullableScalarRelationFilter, ParentWhereInput> | null
    lineItems?: InvoiceLineItemListRelationFilter
    payments?: PaymentListRelationFilter
  }, "id" | "schoolId_invoiceNumber">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    studentId?: SortOrder
    parentToBillId?: SortOrderInput | SortOrder
    invoiceNumber?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    academicYear?: SortOrder
    term?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    schoolId?: StringWithAggregatesFilter<"Invoice"> | string
    studentId?: StringWithAggregatesFilter<"Invoice"> | string
    parentToBillId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    invoiceNumber?: StringWithAggregatesFilter<"Invoice"> | string
    issueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    totalAmount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusWithAggregatesFilter<"Invoice"> | $Enums.PaymentStatus
    notes?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    academicYear?: StringWithAggregatesFilter<"Invoice"> | string
    term?: EnumTermPeriodWithAggregatesFilter<"Invoice"> | $Enums.TermPeriod
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type InvoiceLineItemWhereInput = {
    AND?: InvoiceLineItemWhereInput | InvoiceLineItemWhereInput[]
    OR?: InvoiceLineItemWhereInput[]
    NOT?: InvoiceLineItemWhereInput | InvoiceLineItemWhereInput[]
    id?: StringFilter<"InvoiceLineItem"> | string
    invoiceId?: StringFilter<"InvoiceLineItem"> | string
    feeStructureId?: StringNullableFilter<"InvoiceLineItem"> | string | null
    studentId?: StringFilter<"InvoiceLineItem"> | string
    description?: StringFilter<"InvoiceLineItem"> | string
    quantity?: IntFilter<"InvoiceLineItem"> | number
    unitPrice?: DecimalFilter<"InvoiceLineItem"> | Decimal | DecimalJsLike | number | string
    amount?: DecimalFilter<"InvoiceLineItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"InvoiceLineItem"> | Date | string
    updatedAt?: DateTimeFilter<"InvoiceLineItem"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
    feeStructure?: XOR<FeeStructureNullableScalarRelationFilter, FeeStructureWhereInput> | null
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }

  export type InvoiceLineItemOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    feeStructureId?: SortOrderInput | SortOrder
    studentId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    feeStructure?: FeeStructureOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
    _relevance?: InvoiceLineItemOrderByRelevanceInput
  }

  export type InvoiceLineItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceLineItemWhereInput | InvoiceLineItemWhereInput[]
    OR?: InvoiceLineItemWhereInput[]
    NOT?: InvoiceLineItemWhereInput | InvoiceLineItemWhereInput[]
    invoiceId?: StringFilter<"InvoiceLineItem"> | string
    feeStructureId?: StringNullableFilter<"InvoiceLineItem"> | string | null
    studentId?: StringFilter<"InvoiceLineItem"> | string
    description?: StringFilter<"InvoiceLineItem"> | string
    quantity?: IntFilter<"InvoiceLineItem"> | number
    unitPrice?: DecimalFilter<"InvoiceLineItem"> | Decimal | DecimalJsLike | number | string
    amount?: DecimalFilter<"InvoiceLineItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"InvoiceLineItem"> | Date | string
    updatedAt?: DateTimeFilter<"InvoiceLineItem"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
    feeStructure?: XOR<FeeStructureNullableScalarRelationFilter, FeeStructureWhereInput> | null
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }, "id">

  export type InvoiceLineItemOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    feeStructureId?: SortOrderInput | SortOrder
    studentId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceLineItemCountOrderByAggregateInput
    _avg?: InvoiceLineItemAvgOrderByAggregateInput
    _max?: InvoiceLineItemMaxOrderByAggregateInput
    _min?: InvoiceLineItemMinOrderByAggregateInput
    _sum?: InvoiceLineItemSumOrderByAggregateInput
  }

  export type InvoiceLineItemScalarWhereWithAggregatesInput = {
    AND?: InvoiceLineItemScalarWhereWithAggregatesInput | InvoiceLineItemScalarWhereWithAggregatesInput[]
    OR?: InvoiceLineItemScalarWhereWithAggregatesInput[]
    NOT?: InvoiceLineItemScalarWhereWithAggregatesInput | InvoiceLineItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvoiceLineItem"> | string
    invoiceId?: StringWithAggregatesFilter<"InvoiceLineItem"> | string
    feeStructureId?: StringNullableWithAggregatesFilter<"InvoiceLineItem"> | string | null
    studentId?: StringWithAggregatesFilter<"InvoiceLineItem"> | string
    description?: StringWithAggregatesFilter<"InvoiceLineItem"> | string
    quantity?: IntWithAggregatesFilter<"InvoiceLineItem"> | number
    unitPrice?: DecimalWithAggregatesFilter<"InvoiceLineItem"> | Decimal | DecimalJsLike | number | string
    amount?: DecimalWithAggregatesFilter<"InvoiceLineItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"InvoiceLineItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InvoiceLineItem"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    invoiceId?: StringFilter<"Payment"> | string
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFilter<"Payment"> | string
    reference?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    recordedById?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
    recordedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    paymentDate?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    recordedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    recordedBy?: UserOrderByWithRelationInput
    _relevance?: PaymentOrderByRelevanceInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    invoiceId?: StringFilter<"Payment"> | string
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFilter<"Payment"> | string
    reference?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    recordedById?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
    recordedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    paymentDate?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    recordedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    invoiceId?: StringWithAggregatesFilter<"Payment"> | string
    paymentDate?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringWithAggregatesFilter<"Payment"> | string
    reference?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    recordedById?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type SchoolAnnouncementWhereInput = {
    AND?: SchoolAnnouncementWhereInput | SchoolAnnouncementWhereInput[]
    OR?: SchoolAnnouncementWhereInput[]
    NOT?: SchoolAnnouncementWhereInput | SchoolAnnouncementWhereInput[]
    id?: StringFilter<"SchoolAnnouncement"> | string
    schoolId?: StringFilter<"SchoolAnnouncement"> | string
    title?: StringFilter<"SchoolAnnouncement"> | string
    content?: StringFilter<"SchoolAnnouncement"> | string
    publishDate?: DateTimeFilter<"SchoolAnnouncement"> | Date | string
    expiryDate?: DateTimeNullableFilter<"SchoolAnnouncement"> | Date | string | null
    audience?: StringNullableFilter<"SchoolAnnouncement"> | string | null
    isPublished?: BoolFilter<"SchoolAnnouncement"> | boolean
    createdByAdminId?: StringNullableFilter<"SchoolAnnouncement"> | string | null
    createdAt?: DateTimeFilter<"SchoolAnnouncement"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolAnnouncement"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    createdByAdmin?: XOR<SchoolAdminNullableScalarRelationFilter, SchoolAdminWhereInput> | null
  }

  export type SchoolAnnouncementOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    publishDate?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    audience?: SortOrderInput | SortOrder
    isPublished?: SortOrder
    createdByAdminId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    createdByAdmin?: SchoolAdminOrderByWithRelationInput
    _relevance?: SchoolAnnouncementOrderByRelevanceInput
  }

  export type SchoolAnnouncementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SchoolAnnouncementWhereInput | SchoolAnnouncementWhereInput[]
    OR?: SchoolAnnouncementWhereInput[]
    NOT?: SchoolAnnouncementWhereInput | SchoolAnnouncementWhereInput[]
    schoolId?: StringFilter<"SchoolAnnouncement"> | string
    title?: StringFilter<"SchoolAnnouncement"> | string
    content?: StringFilter<"SchoolAnnouncement"> | string
    publishDate?: DateTimeFilter<"SchoolAnnouncement"> | Date | string
    expiryDate?: DateTimeNullableFilter<"SchoolAnnouncement"> | Date | string | null
    audience?: StringNullableFilter<"SchoolAnnouncement"> | string | null
    isPublished?: BoolFilter<"SchoolAnnouncement"> | boolean
    createdByAdminId?: StringNullableFilter<"SchoolAnnouncement"> | string | null
    createdAt?: DateTimeFilter<"SchoolAnnouncement"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolAnnouncement"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    createdByAdmin?: XOR<SchoolAdminNullableScalarRelationFilter, SchoolAdminWhereInput> | null
  }, "id">

  export type SchoolAnnouncementOrderByWithAggregationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    publishDate?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    audience?: SortOrderInput | SortOrder
    isPublished?: SortOrder
    createdByAdminId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SchoolAnnouncementCountOrderByAggregateInput
    _max?: SchoolAnnouncementMaxOrderByAggregateInput
    _min?: SchoolAnnouncementMinOrderByAggregateInput
  }

  export type SchoolAnnouncementScalarWhereWithAggregatesInput = {
    AND?: SchoolAnnouncementScalarWhereWithAggregatesInput | SchoolAnnouncementScalarWhereWithAggregatesInput[]
    OR?: SchoolAnnouncementScalarWhereWithAggregatesInput[]
    NOT?: SchoolAnnouncementScalarWhereWithAggregatesInput | SchoolAnnouncementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SchoolAnnouncement"> | string
    schoolId?: StringWithAggregatesFilter<"SchoolAnnouncement"> | string
    title?: StringWithAggregatesFilter<"SchoolAnnouncement"> | string
    content?: StringWithAggregatesFilter<"SchoolAnnouncement"> | string
    publishDate?: DateTimeWithAggregatesFilter<"SchoolAnnouncement"> | Date | string
    expiryDate?: DateTimeNullableWithAggregatesFilter<"SchoolAnnouncement"> | Date | string | null
    audience?: StringNullableWithAggregatesFilter<"SchoolAnnouncement"> | string | null
    isPublished?: BoolWithAggregatesFilter<"SchoolAnnouncement"> | boolean
    createdByAdminId?: StringNullableWithAggregatesFilter<"SchoolAnnouncement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SchoolAnnouncement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SchoolAnnouncement"> | Date | string
  }

  export type ClassAnnouncementWhereInput = {
    AND?: ClassAnnouncementWhereInput | ClassAnnouncementWhereInput[]
    OR?: ClassAnnouncementWhereInput[]
    NOT?: ClassAnnouncementWhereInput | ClassAnnouncementWhereInput[]
    id?: StringFilter<"ClassAnnouncement"> | string
    schoolId?: StringFilter<"ClassAnnouncement"> | string
    classId?: StringFilter<"ClassAnnouncement"> | string
    title?: StringFilter<"ClassAnnouncement"> | string
    content?: StringFilter<"ClassAnnouncement"> | string
    publishDate?: DateTimeFilter<"ClassAnnouncement"> | Date | string
    isPublished?: BoolFilter<"ClassAnnouncement"> | boolean
    createdByTeacherId?: StringNullableFilter<"ClassAnnouncement"> | string | null
    createdAt?: DateTimeFilter<"ClassAnnouncement"> | Date | string
    updatedAt?: DateTimeFilter<"ClassAnnouncement"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    createdByTeacher?: XOR<TeacherNullableScalarRelationFilter, TeacherWhereInput> | null
  }

  export type ClassAnnouncementOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    classId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    publishDate?: SortOrder
    isPublished?: SortOrder
    createdByTeacherId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
    createdByTeacher?: TeacherOrderByWithRelationInput
    _relevance?: ClassAnnouncementOrderByRelevanceInput
  }

  export type ClassAnnouncementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClassAnnouncementWhereInput | ClassAnnouncementWhereInput[]
    OR?: ClassAnnouncementWhereInput[]
    NOT?: ClassAnnouncementWhereInput | ClassAnnouncementWhereInput[]
    schoolId?: StringFilter<"ClassAnnouncement"> | string
    classId?: StringFilter<"ClassAnnouncement"> | string
    title?: StringFilter<"ClassAnnouncement"> | string
    content?: StringFilter<"ClassAnnouncement"> | string
    publishDate?: DateTimeFilter<"ClassAnnouncement"> | Date | string
    isPublished?: BoolFilter<"ClassAnnouncement"> | boolean
    createdByTeacherId?: StringNullableFilter<"ClassAnnouncement"> | string | null
    createdAt?: DateTimeFilter<"ClassAnnouncement"> | Date | string
    updatedAt?: DateTimeFilter<"ClassAnnouncement"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    createdByTeacher?: XOR<TeacherNullableScalarRelationFilter, TeacherWhereInput> | null
  }, "id">

  export type ClassAnnouncementOrderByWithAggregationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    classId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    publishDate?: SortOrder
    isPublished?: SortOrder
    createdByTeacherId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClassAnnouncementCountOrderByAggregateInput
    _max?: ClassAnnouncementMaxOrderByAggregateInput
    _min?: ClassAnnouncementMinOrderByAggregateInput
  }

  export type ClassAnnouncementScalarWhereWithAggregatesInput = {
    AND?: ClassAnnouncementScalarWhereWithAggregatesInput | ClassAnnouncementScalarWhereWithAggregatesInput[]
    OR?: ClassAnnouncementScalarWhereWithAggregatesInput[]
    NOT?: ClassAnnouncementScalarWhereWithAggregatesInput | ClassAnnouncementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClassAnnouncement"> | string
    schoolId?: StringWithAggregatesFilter<"ClassAnnouncement"> | string
    classId?: StringWithAggregatesFilter<"ClassAnnouncement"> | string
    title?: StringWithAggregatesFilter<"ClassAnnouncement"> | string
    content?: StringWithAggregatesFilter<"ClassAnnouncement"> | string
    publishDate?: DateTimeWithAggregatesFilter<"ClassAnnouncement"> | Date | string
    isPublished?: BoolWithAggregatesFilter<"ClassAnnouncement"> | boolean
    createdByTeacherId?: StringNullableWithAggregatesFilter<"ClassAnnouncement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ClassAnnouncement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClassAnnouncement"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    hashedPassword: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    profilePicture?: string | null
    isActive?: boolean
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    schoolAdmins?: SchoolAdminCreateNestedManyWithoutUserInput
    teacherLinks?: TeacherCreateNestedManyWithoutUserInput
    studentLink?: StudentCreateNestedOneWithoutUserInput
    parentLink?: ParentCreateNestedOneWithoutUserInput
    recordedAttendances?: StudentAttendanceCreateNestedManyWithoutRecordedByInput
    recordedPayments?: PaymentCreateNestedManyWithoutRecordedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    hashedPassword: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    profilePicture?: string | null
    isActive?: boolean
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    schoolAdmins?: SchoolAdminUncheckedCreateNestedManyWithoutUserInput
    teacherLinks?: TeacherUncheckedCreateNestedManyWithoutUserInput
    studentLink?: StudentUncheckedCreateNestedOneWithoutUserInput
    parentLink?: ParentUncheckedCreateNestedOneWithoutUserInput
    recordedAttendances?: StudentAttendanceUncheckedCreateNestedManyWithoutRecordedByInput
    recordedPayments?: PaymentUncheckedCreateNestedManyWithoutRecordedByInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    schoolAdmins?: SchoolAdminUpdateManyWithoutUserNestedInput
    teacherLinks?: TeacherUpdateManyWithoutUserNestedInput
    studentLink?: StudentUpdateOneWithoutUserNestedInput
    parentLink?: ParentUpdateOneWithoutUserNestedInput
    recordedAttendances?: StudentAttendanceUpdateManyWithoutRecordedByNestedInput
    recordedPayments?: PaymentUpdateManyWithoutRecordedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    schoolAdmins?: SchoolAdminUncheckedUpdateManyWithoutUserNestedInput
    teacherLinks?: TeacherUncheckedUpdateManyWithoutUserNestedInput
    studentLink?: StudentUncheckedUpdateOneWithoutUserNestedInput
    parentLink?: ParentUncheckedUpdateOneWithoutUserNestedInput
    recordedAttendances?: StudentAttendanceUncheckedUpdateManyWithoutRecordedByNestedInput
    recordedPayments?: PaymentUncheckedUpdateManyWithoutRecordedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    hashedPassword: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    profilePicture?: string | null
    isActive?: boolean
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    id?: string
    identifier: string
    token: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    id?: string
    identifier: string
    token: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    id?: string
    identifier: string
    token: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuperAdminCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSuperAdminInput
    schoolsCreated?: SchoolCreateNestedManyWithoutCreatedBySuperAdminInput
  }

  export type SuperAdminUncheckedCreateInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schoolsCreated?: SchoolUncheckedCreateNestedManyWithoutCreatedBySuperAdminInput
  }

  export type SuperAdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSuperAdminNestedInput
    schoolsCreated?: SchoolUpdateManyWithoutCreatedBySuperAdminNestedInput
  }

  export type SuperAdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolsCreated?: SchoolUncheckedUpdateManyWithoutCreatedBySuperAdminNestedInput
  }

  export type SuperAdminCreateManyInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SuperAdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuperAdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolCreateInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    schoolEmail: string
    website?: string | null
    logoUrl?: string | null
    currentAcademicYear?: string | null
    currentTerm?: $Enums.TermPeriod | null
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBySuperAdmin?: SuperAdminCreateNestedOneWithoutSchoolsCreatedInput
    admins?: SchoolAdminCreateNestedManyWithoutSchoolInput
    teachers?: TeacherCreateNestedManyWithoutSchoolInput
    students?: StudentCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    subjects?: SubjectCreateNestedManyWithoutSchoolInput
    feeStructures?: FeeStructureCreateNestedManyWithoutSchoolInput
    invoices?: InvoiceCreateNestedManyWithoutSchoolInput
    timetableSlots?: TimetableSlotCreateNestedManyWithoutSchoolInput
    announcements?: SchoolAnnouncementCreateNestedManyWithoutSchoolInput
    classAnnouncements?: ClassAnnouncementCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    schoolEmail: string
    website?: string | null
    logoUrl?: string | null
    currentAcademicYear?: string | null
    currentTerm?: $Enums.TermPeriod | null
    currency?: string
    timezone?: string
    isActive?: boolean
    createdBySuperAdminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admins?: SchoolAdminUncheckedCreateNestedManyWithoutSchoolInput
    teachers?: TeacherUncheckedCreateNestedManyWithoutSchoolInput
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutSchoolInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutSchoolInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSchoolInput
    timetableSlots?: TimetableSlotUncheckedCreateNestedManyWithoutSchoolInput
    announcements?: SchoolAnnouncementUncheckedCreateNestedManyWithoutSchoolInput
    classAnnouncements?: ClassAnnouncementUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    schoolEmail?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    currentAcademicYear?: NullableStringFieldUpdateOperationsInput | string | null
    currentTerm?: NullableEnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBySuperAdmin?: SuperAdminUpdateOneWithoutSchoolsCreatedNestedInput
    admins?: SchoolAdminUpdateManyWithoutSchoolNestedInput
    teachers?: TeacherUpdateManyWithoutSchoolNestedInput
    students?: StudentUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUpdateManyWithoutSchoolNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutSchoolNestedInput
    invoices?: InvoiceUpdateManyWithoutSchoolNestedInput
    timetableSlots?: TimetableSlotUpdateManyWithoutSchoolNestedInput
    announcements?: SchoolAnnouncementUpdateManyWithoutSchoolNestedInput
    classAnnouncements?: ClassAnnouncementUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    schoolEmail?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    currentAcademicYear?: NullableStringFieldUpdateOperationsInput | string | null
    currentTerm?: NullableEnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBySuperAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admins?: SchoolAdminUncheckedUpdateManyWithoutSchoolNestedInput
    teachers?: TeacherUncheckedUpdateManyWithoutSchoolNestedInput
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutSchoolNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutSchoolNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSchoolNestedInput
    timetableSlots?: TimetableSlotUncheckedUpdateManyWithoutSchoolNestedInput
    announcements?: SchoolAnnouncementUncheckedUpdateManyWithoutSchoolNestedInput
    classAnnouncements?: ClassAnnouncementUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolCreateManyInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    schoolEmail: string
    website?: string | null
    logoUrl?: string | null
    currentAcademicYear?: string | null
    currentTerm?: $Enums.TermPeriod | null
    currency?: string
    timezone?: string
    isActive?: boolean
    createdBySuperAdminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    schoolEmail?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    currentAcademicYear?: NullableStringFieldUpdateOperationsInput | string | null
    currentTerm?: NullableEnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    schoolEmail?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    currentAcademicYear?: NullableStringFieldUpdateOperationsInput | string | null
    currentTerm?: NullableEnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBySuperAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolAdminCreateInput = {
    id?: string
    jobTitle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSchoolAdminsInput
    school: SchoolCreateNestedOneWithoutAdminsInput
    createdSchoolAnnouncements?: SchoolAnnouncementCreateNestedManyWithoutCreatedByAdminInput
  }

  export type SchoolAdminUncheckedCreateInput = {
    id?: string
    userId: string
    schoolId: string
    jobTitle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdSchoolAnnouncements?: SchoolAnnouncementUncheckedCreateNestedManyWithoutCreatedByAdminInput
  }

  export type SchoolAdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSchoolAdminsNestedInput
    school?: SchoolUpdateOneRequiredWithoutAdminsNestedInput
    createdSchoolAnnouncements?: SchoolAnnouncementUpdateManyWithoutCreatedByAdminNestedInput
  }

  export type SchoolAdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdSchoolAnnouncements?: SchoolAnnouncementUncheckedUpdateManyWithoutCreatedByAdminNestedInput
  }

  export type SchoolAdminCreateManyInput = {
    id?: string
    userId: string
    schoolId: string
    jobTitle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolAdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolAdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherCreateInput = {
    id?: string
    teacherIdNumber?: string | null
    dateOfJoining?: Date | string | null
    qualifications?: string | null
    specialization?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTeacherLinksInput
    school: SchoolCreateNestedOneWithoutTeachersInput
    classTeacherOf?: ClassCreateNestedManyWithoutHomeroomTeacherInput
    timetableSlots?: TimetableSlotCreateNestedManyWithoutTeacherInput
    gradesGiven?: StudentGradeCreateNestedManyWithoutTeacherInput
    assignmentsCreated?: AssignmentCreateNestedManyWithoutTeacherInput
    createdClassAnnouncements?: ClassAnnouncementCreateNestedManyWithoutCreatedByTeacherInput
  }

  export type TeacherUncheckedCreateInput = {
    id?: string
    userId: string
    schoolId: string
    teacherIdNumber?: string | null
    dateOfJoining?: Date | string | null
    qualifications?: string | null
    specialization?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classTeacherOf?: ClassUncheckedCreateNestedManyWithoutHomeroomTeacherInput
    timetableSlots?: TimetableSlotUncheckedCreateNestedManyWithoutTeacherInput
    gradesGiven?: StudentGradeUncheckedCreateNestedManyWithoutTeacherInput
    assignmentsCreated?: AssignmentUncheckedCreateNestedManyWithoutTeacherInput
    createdClassAnnouncements?: ClassAnnouncementUncheckedCreateNestedManyWithoutCreatedByTeacherInput
  }

  export type TeacherUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeacherLinksNestedInput
    school?: SchoolUpdateOneRequiredWithoutTeachersNestedInput
    classTeacherOf?: ClassUpdateManyWithoutHomeroomTeacherNestedInput
    timetableSlots?: TimetableSlotUpdateManyWithoutTeacherNestedInput
    gradesGiven?: StudentGradeUpdateManyWithoutTeacherNestedInput
    assignmentsCreated?: AssignmentUpdateManyWithoutTeacherNestedInput
    createdClassAnnouncements?: ClassAnnouncementUpdateManyWithoutCreatedByTeacherNestedInput
  }

  export type TeacherUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    teacherIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classTeacherOf?: ClassUncheckedUpdateManyWithoutHomeroomTeacherNestedInput
    timetableSlots?: TimetableSlotUncheckedUpdateManyWithoutTeacherNestedInput
    gradesGiven?: StudentGradeUncheckedUpdateManyWithoutTeacherNestedInput
    assignmentsCreated?: AssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    createdClassAnnouncements?: ClassAnnouncementUncheckedUpdateManyWithoutCreatedByTeacherNestedInput
  }

  export type TeacherCreateManyInput = {
    id?: string
    userId: string
    schoolId: string
    teacherIdNumber?: string | null
    dateOfJoining?: Date | string | null
    qualifications?: string | null
    specialization?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    teacherIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateInput = {
    id?: string
    studentIdNumber: string
    firstName: string
    lastName: string
    middleName?: string | null
    dateOfBirth: Date | string
    gender: $Enums.Gender
    enrollmentDate: Date | string
    profilePictureUrl?: string | null
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    bloodGroup?: string | null
    allergies?: string | null
    medicalNotes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentLinkInput
    school: SchoolCreateNestedOneWithoutStudentsInput
    currentClass?: ClassCreateNestedOneWithoutCurrentStudentsInput
    parents?: StudentParentLinkCreateNestedManyWithoutStudentInput
    enrollments?: StudentClassEnrollmentCreateNestedManyWithoutStudentInput
    attendances?: StudentAttendanceCreateNestedManyWithoutStudentInput
    grades?: StudentGradeCreateNestedManyWithoutStudentInput
    invoiceLineItems?: InvoiceLineItemCreateNestedManyWithoutStudentInput
    invoices?: InvoiceCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateInput = {
    id?: string
    userId?: string | null
    schoolId: string
    studentIdNumber: string
    firstName: string
    lastName: string
    middleName?: string | null
    dateOfBirth: Date | string
    gender: $Enums.Gender
    enrollmentDate: Date | string
    profilePictureUrl?: string | null
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    bloodGroup?: string | null
    allergies?: string | null
    medicalNotes?: string | null
    isActive?: boolean
    currentClassId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: StudentParentLinkUncheckedCreateNestedManyWithoutStudentInput
    enrollments?: StudentClassEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    attendances?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    grades?: StudentGradeUncheckedCreateNestedManyWithoutStudentInput
    invoiceLineItems?: InvoiceLineItemUncheckedCreateNestedManyWithoutStudentInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentIdNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentLinkNestedInput
    school?: SchoolUpdateOneRequiredWithoutStudentsNestedInput
    currentClass?: ClassUpdateOneWithoutCurrentStudentsNestedInput
    parents?: StudentParentLinkUpdateManyWithoutStudentNestedInput
    enrollments?: StudentClassEnrollmentUpdateManyWithoutStudentNestedInput
    attendances?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    grades?: StudentGradeUpdateManyWithoutStudentNestedInput
    invoiceLineItems?: InvoiceLineItemUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    studentIdNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    currentClassId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: StudentParentLinkUncheckedUpdateManyWithoutStudentNestedInput
    enrollments?: StudentClassEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    grades?: StudentGradeUncheckedUpdateManyWithoutStudentNestedInput
    invoiceLineItems?: InvoiceLineItemUncheckedUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateManyInput = {
    id?: string
    userId?: string | null
    schoolId: string
    studentIdNumber: string
    firstName: string
    lastName: string
    middleName?: string | null
    dateOfBirth: Date | string
    gender: $Enums.Gender
    enrollmentDate: Date | string
    profilePictureUrl?: string | null
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    bloodGroup?: string | null
    allergies?: string | null
    medicalNotes?: string | null
    isActive?: boolean
    currentClassId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentIdNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    studentIdNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    currentClassId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentCreateInput = {
    id?: string
    occupation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutParentLinkInput
    children?: StudentParentLinkCreateNestedManyWithoutParentInput
    invoices?: InvoiceCreateNestedManyWithoutParentToBillInput
  }

  export type ParentUncheckedCreateInput = {
    id?: string
    userId: string
    occupation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: StudentParentLinkUncheckedCreateNestedManyWithoutParentInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutParentToBillInput
  }

  export type ParentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutParentLinkNestedInput
    children?: StudentParentLinkUpdateManyWithoutParentNestedInput
    invoices?: InvoiceUpdateManyWithoutParentToBillNestedInput
  }

  export type ParentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: StudentParentLinkUncheckedUpdateManyWithoutParentNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutParentToBillNestedInput
  }

  export type ParentCreateManyInput = {
    id?: string
    userId: string
    occupation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentParentLinkCreateInput = {
    id?: string
    relationshipToStudent: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutParentsInput
    parent: ParentCreateNestedOneWithoutChildrenInput
  }

  export type StudentParentLinkUncheckedCreateInput = {
    id?: string
    studentId: string
    parentId: string
    relationshipToStudent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentParentLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipToStudent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutParentsNestedInput
    parent?: ParentUpdateOneRequiredWithoutChildrenNestedInput
  }

  export type StudentParentLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    relationshipToStudent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentParentLinkCreateManyInput = {
    id?: string
    studentId: string
    parentId: string
    relationshipToStudent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentParentLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipToStudent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentParentLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    relationshipToStudent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassCreateInput = {
    id?: string
    name: string
    section?: string | null
    academicYear: string
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutClassesInput
    homeroomTeacher?: TeacherCreateNestedOneWithoutClassTeacherOfInput
    studentsEnrolled?: StudentClassEnrollmentCreateNestedManyWithoutClassInput
    currentStudents?: StudentCreateNestedManyWithoutCurrentClassInput
    timetableSlots?: TimetableSlotCreateNestedManyWithoutClassInput
    assignments?: AssignmentCreateNestedManyWithoutClassInput
    announcements?: ClassAnnouncementCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateInput = {
    id?: string
    schoolId: string
    name: string
    section?: string | null
    academicYear: string
    homeroomTeacherId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentsEnrolled?: StudentClassEnrollmentUncheckedCreateNestedManyWithoutClassInput
    currentStudents?: StudentUncheckedCreateNestedManyWithoutCurrentClassInput
    timetableSlots?: TimetableSlotUncheckedCreateNestedManyWithoutClassInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClassInput
    announcements?: ClassAnnouncementUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    homeroomTeacher?: TeacherUpdateOneWithoutClassTeacherOfNestedInput
    studentsEnrolled?: StudentClassEnrollmentUpdateManyWithoutClassNestedInput
    currentStudents?: StudentUpdateManyWithoutCurrentClassNestedInput
    timetableSlots?: TimetableSlotUpdateManyWithoutClassNestedInput
    assignments?: AssignmentUpdateManyWithoutClassNestedInput
    announcements?: ClassAnnouncementUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    homeroomTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentsEnrolled?: StudentClassEnrollmentUncheckedUpdateManyWithoutClassNestedInput
    currentStudents?: StudentUncheckedUpdateManyWithoutCurrentClassNestedInput
    timetableSlots?: TimetableSlotUncheckedUpdateManyWithoutClassNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutClassNestedInput
    announcements?: ClassAnnouncementUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassCreateManyInput = {
    id?: string
    schoolId: string
    name: string
    section?: string | null
    academicYear: string
    homeroomTeacherId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    homeroomTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentClassEnrollmentCreateInput = {
    id?: string
    academicYear: string
    enrollmentDate?: Date | string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutEnrollmentsInput
    class: ClassCreateNestedOneWithoutStudentsEnrolledInput
  }

  export type StudentClassEnrollmentUncheckedCreateInput = {
    id?: string
    studentId: string
    classId: string
    academicYear: string
    enrollmentDate?: Date | string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentClassEnrollmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutEnrollmentsNestedInput
    class?: ClassUpdateOneRequiredWithoutStudentsEnrolledNestedInput
  }

  export type StudentClassEnrollmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentClassEnrollmentCreateManyInput = {
    id?: string
    studentId: string
    classId: string
    academicYear: string
    enrollmentDate?: Date | string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentClassEnrollmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentClassEnrollmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectCreateInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutSubjectsInput
    timetableSlots?: TimetableSlotCreateNestedManyWithoutSubjectInput
    assignments?: AssignmentCreateNestedManyWithoutSubjectInput
    grades?: StudentGradeCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateInput = {
    id?: string
    schoolId: string
    name: string
    code?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timetableSlots?: TimetableSlotUncheckedCreateNestedManyWithoutSubjectInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutSubjectInput
    grades?: StudentGradeUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutSubjectsNestedInput
    timetableSlots?: TimetableSlotUpdateManyWithoutSubjectNestedInput
    assignments?: AssignmentUpdateManyWithoutSubjectNestedInput
    grades?: StudentGradeUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timetableSlots?: TimetableSlotUncheckedUpdateManyWithoutSubjectNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutSubjectNestedInput
    grades?: StudentGradeUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectCreateManyInput = {
    id?: string
    schoolId: string
    name: string
    code?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimetableSlotCreateInput = {
    id?: string
    dayOfWeek: $Enums.DayOfWeek
    startTime: string
    endTime: string
    room?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutTimetableSlotsInput
    class: ClassCreateNestedOneWithoutTimetableSlotsInput
    subject: SubjectCreateNestedOneWithoutTimetableSlotsInput
    teacher: TeacherCreateNestedOneWithoutTimetableSlotsInput
    attendances?: StudentAttendanceCreateNestedManyWithoutTimetableSlotInput
  }

  export type TimetableSlotUncheckedCreateInput = {
    id?: string
    schoolId: string
    classId: string
    subjectId: string
    teacherId: string
    dayOfWeek: $Enums.DayOfWeek
    startTime: string
    endTime: string
    room?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendances?: StudentAttendanceUncheckedCreateNestedManyWithoutTimetableSlotInput
  }

  export type TimetableSlotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutTimetableSlotsNestedInput
    class?: ClassUpdateOneRequiredWithoutTimetableSlotsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutTimetableSlotsNestedInput
    teacher?: TeacherUpdateOneRequiredWithoutTimetableSlotsNestedInput
    attendances?: StudentAttendanceUpdateManyWithoutTimetableSlotNestedInput
  }

  export type TimetableSlotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: StudentAttendanceUncheckedUpdateManyWithoutTimetableSlotNestedInput
  }

  export type TimetableSlotCreateManyInput = {
    id?: string
    schoolId: string
    classId: string
    subjectId: string
    teacherId: string
    dayOfWeek: $Enums.DayOfWeek
    startTime: string
    endTime: string
    room?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimetableSlotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimetableSlotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAttendanceCreateInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    classId?: string | null
    subjectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutAttendancesInput
    timetableSlot?: TimetableSlotCreateNestedOneWithoutAttendancesInput
    recordedBy?: UserCreateNestedOneWithoutRecordedAttendancesInput
  }

  export type StudentAttendanceUncheckedCreateInput = {
    id?: string
    studentId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    classId?: string | null
    subjectId?: string | null
    timetableSlotId?: string | null
    recordedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAttendanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutAttendancesNestedInput
    timetableSlot?: TimetableSlotUpdateOneWithoutAttendancesNestedInput
    recordedBy?: UserUpdateOneWithoutRecordedAttendancesNestedInput
  }

  export type StudentAttendanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    timetableSlotId?: NullableStringFieldUpdateOperationsInput | string | null
    recordedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAttendanceCreateManyInput = {
    id?: string
    studentId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    classId?: string | null
    subjectId?: string | null
    timetableSlotId?: string | null
    recordedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAttendanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAttendanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    timetableSlotId?: NullableStringFieldUpdateOperationsInput | string | null
    recordedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentCreateInput = {
    id?: string
    schoolId: string
    title: string
    description?: string | null
    maxPoints?: number | null
    dueDate?: Date | string | null
    academicYear: string
    term: $Enums.TermPeriod
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutAssignmentsInput
    subject: SubjectCreateNestedOneWithoutAssignmentsInput
    teacher: TeacherCreateNestedOneWithoutAssignmentsCreatedInput
    grades?: StudentGradeCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentUncheckedCreateInput = {
    id?: string
    schoolId: string
    classId: string
    subjectId: string
    teacherId: string
    title: string
    description?: string | null
    maxPoints?: number | null
    dueDate?: Date | string | null
    academicYear: string
    term: $Enums.TermPeriod
    createdAt?: Date | string
    updatedAt?: Date | string
    grades?: StudentGradeUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutAssignmentsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutAssignmentsNestedInput
    teacher?: TeacherUpdateOneRequiredWithoutAssignmentsCreatedNestedInput
    grades?: StudentGradeUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grades?: StudentGradeUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentCreateManyInput = {
    id?: string
    schoolId: string
    classId: string
    subjectId: string
    teacherId: string
    title: string
    description?: string | null
    maxPoints?: number | null
    dueDate?: Date | string | null
    academicYear: string
    term: $Enums.TermPeriod
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentGradeCreateInput = {
    id?: string
    grade: string
    numericValue?: number | null
    comments?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    dateRecorded?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutGradesInput
    subject: SubjectCreateNestedOneWithoutGradesInput
    assignment?: AssignmentCreateNestedOneWithoutGradesInput
    teacher?: TeacherCreateNestedOneWithoutGradesGivenInput
  }

  export type StudentGradeUncheckedCreateInput = {
    id?: string
    studentId: string
    subjectId: string
    assignmentId?: string | null
    teacherId?: string | null
    grade: string
    numericValue?: number | null
    comments?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    dateRecorded?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentGradeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    numericValue?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    dateRecorded?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutGradesNestedInput
    subject?: SubjectUpdateOneRequiredWithoutGradesNestedInput
    assignment?: AssignmentUpdateOneWithoutGradesNestedInput
    teacher?: TeacherUpdateOneWithoutGradesGivenNestedInput
  }

  export type StudentGradeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: StringFieldUpdateOperationsInput | string
    numericValue?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    dateRecorded?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentGradeCreateManyInput = {
    id?: string
    studentId: string
    subjectId: string
    assignmentId?: string | null
    teacherId?: string | null
    grade: string
    numericValue?: number | null
    comments?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    dateRecorded?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentGradeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    numericValue?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    dateRecorded?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentGradeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: StringFieldUpdateOperationsInput | string
    numericValue?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    dateRecorded?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeStructureCreateInput = {
    id?: string
    name: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    academicYear: string
    term?: $Enums.TermPeriod | null
    frequency: string
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutFeeStructuresInput
    invoiceLineItems?: InvoiceLineItemCreateNestedManyWithoutFeeStructureInput
  }

  export type FeeStructureUncheckedCreateInput = {
    id?: string
    schoolId: string
    name: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    academicYear: string
    term?: $Enums.TermPeriod | null
    frequency: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceLineItems?: InvoiceLineItemUncheckedCreateNestedManyWithoutFeeStructureInput
  }

  export type FeeStructureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: NullableEnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod | null
    frequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutFeeStructuresNestedInput
    invoiceLineItems?: InvoiceLineItemUpdateManyWithoutFeeStructureNestedInput
  }

  export type FeeStructureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: NullableEnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod | null
    frequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceLineItems?: InvoiceLineItemUncheckedUpdateManyWithoutFeeStructureNestedInput
  }

  export type FeeStructureCreateManyInput = {
    id?: string
    schoolId: string
    name: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    academicYear: string
    term?: $Enums.TermPeriod | null
    frequency: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeeStructureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: NullableEnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod | null
    frequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeStructureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: NullableEnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod | null
    frequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    invoiceNumber: string
    issueDate: Date | string
    dueDate: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.PaymentStatus
    notes?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutInvoicesInput
    student: StudentCreateNestedOneWithoutInvoicesInput
    parentToBill?: ParentCreateNestedOneWithoutInvoicesInput
    lineItems?: InvoiceLineItemCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    schoolId: string
    studentId: string
    parentToBillId?: string | null
    invoiceNumber: string
    issueDate: Date | string
    dueDate: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.PaymentStatus
    notes?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    createdAt?: Date | string
    updatedAt?: Date | string
    lineItems?: InvoiceLineItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutInvoicesNestedInput
    student?: StudentUpdateOneRequiredWithoutInvoicesNestedInput
    parentToBill?: ParentUpdateOneWithoutInvoicesNestedInput
    lineItems?: InvoiceLineItemUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    parentToBillId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lineItems?: InvoiceLineItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    schoolId: string
    studentId: string
    parentToBillId?: string | null
    invoiceNumber: string
    issueDate: Date | string
    dueDate: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.PaymentStatus
    notes?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    parentToBillId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLineItemCreateInput = {
    id?: string
    description: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutLineItemsInput
    feeStructure?: FeeStructureCreateNestedOneWithoutInvoiceLineItemsInput
    student: StudentCreateNestedOneWithoutInvoiceLineItemsInput
  }

  export type InvoiceLineItemUncheckedCreateInput = {
    id?: string
    invoiceId: string
    feeStructureId?: string | null
    studentId: string
    description: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceLineItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutLineItemsNestedInput
    feeStructure?: FeeStructureUpdateOneWithoutInvoiceLineItemsNestedInput
    student?: StudentUpdateOneRequiredWithoutInvoiceLineItemsNestedInput
  }

  export type InvoiceLineItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    feeStructureId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLineItemCreateManyInput = {
    id?: string
    invoiceId: string
    feeStructureId?: string | null
    studentId: string
    description: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceLineItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLineItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    feeStructureId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    paymentDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
    recordedBy?: UserCreateNestedOneWithoutRecordedPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    invoiceId: string
    paymentDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    reference?: string | null
    notes?: string | null
    recordedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
    recordedBy?: UserUpdateOneWithoutRecordedPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    invoiceId: string
    paymentDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    reference?: string | null
    notes?: string | null
    recordedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolAnnouncementCreateInput = {
    id?: string
    title: string
    content: string
    publishDate: Date | string
    expiryDate?: Date | string | null
    audience?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutAnnouncementsInput
    createdByAdmin?: SchoolAdminCreateNestedOneWithoutCreatedSchoolAnnouncementsInput
  }

  export type SchoolAnnouncementUncheckedCreateInput = {
    id?: string
    schoolId: string
    title: string
    content: string
    publishDate: Date | string
    expiryDate?: Date | string | null
    audience?: string | null
    isPublished?: boolean
    createdByAdminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolAnnouncementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audience?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutAnnouncementsNestedInput
    createdByAdmin?: SchoolAdminUpdateOneWithoutCreatedSchoolAnnouncementsNestedInput
  }

  export type SchoolAnnouncementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audience?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolAnnouncementCreateManyInput = {
    id?: string
    schoolId: string
    title: string
    content: string
    publishDate: Date | string
    expiryDate?: Date | string | null
    audience?: string | null
    isPublished?: boolean
    createdByAdminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolAnnouncementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audience?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolAnnouncementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audience?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassAnnouncementCreateInput = {
    id?: string
    title: string
    content: string
    publishDate: Date | string
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutClassAnnouncementsInput
    class: ClassCreateNestedOneWithoutAnnouncementsInput
    createdByTeacher?: TeacherCreateNestedOneWithoutCreatedClassAnnouncementsInput
  }

  export type ClassAnnouncementUncheckedCreateInput = {
    id?: string
    schoolId: string
    classId: string
    title: string
    content: string
    publishDate: Date | string
    isPublished?: boolean
    createdByTeacherId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassAnnouncementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutClassAnnouncementsNestedInput
    class?: ClassUpdateOneRequiredWithoutAnnouncementsNestedInput
    createdByTeacher?: TeacherUpdateOneWithoutCreatedClassAnnouncementsNestedInput
  }

  export type ClassAnnouncementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdByTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassAnnouncementCreateManyInput = {
    id?: string
    schoolId: string
    classId: string
    title: string
    content: string
    publishDate: Date | string
    isPublished?: boolean
    createdByTeacherId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassAnnouncementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassAnnouncementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdByTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type SuperAdminNullableScalarRelationFilter = {
    is?: SuperAdminWhereInput | null
    isNot?: SuperAdminWhereInput | null
  }

  export type SchoolAdminListRelationFilter = {
    every?: SchoolAdminWhereInput
    some?: SchoolAdminWhereInput
    none?: SchoolAdminWhereInput
  }

  export type TeacherListRelationFilter = {
    every?: TeacherWhereInput
    some?: TeacherWhereInput
    none?: TeacherWhereInput
  }

  export type StudentNullableScalarRelationFilter = {
    is?: StudentWhereInput | null
    isNot?: StudentWhereInput | null
  }

  export type ParentNullableScalarRelationFilter = {
    is?: ParentWhereInput | null
    isNot?: ParentWhereInput | null
  }

  export type StudentAttendanceListRelationFilter = {
    every?: StudentAttendanceWhereInput
    some?: StudentAttendanceWhereInput
    none?: StudentAttendanceWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolAdminOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeacherOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentAttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    hashedPassword?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrder
    profilePicture?: SortOrder
    isActive?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    hashedPassword?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrder
    profilePicture?: SortOrder
    isActive?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    hashedPassword?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrder
    profilePicture?: SortOrder
    isActive?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountOrderByRelevanceInput = {
    fields: AccountOrderByRelevanceFieldEnum | AccountOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SessionOrderByRelevanceInput = {
    fields: SessionOrderByRelevanceFieldEnum | SessionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationTokenOrderByRelevanceInput = {
    fields: VerificationTokenOrderByRelevanceFieldEnum | VerificationTokenOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolListRelationFilter = {
    every?: SchoolWhereInput
    some?: SchoolWhereInput
    none?: SchoolWhereInput
  }

  export type SchoolOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SuperAdminOrderByRelevanceInput = {
    fields: SuperAdminOrderByRelevanceFieldEnum | SuperAdminOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SuperAdminCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SuperAdminMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SuperAdminMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTermPeriodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TermPeriod | EnumTermPeriodFieldRefInput<$PrismaModel> | null
    in?: $Enums.TermPeriod[] | null
    notIn?: $Enums.TermPeriod[] | null
    not?: NestedEnumTermPeriodNullableFilter<$PrismaModel> | $Enums.TermPeriod | null
  }

  export type StudentListRelationFilter = {
    every?: StudentWhereInput
    some?: StudentWhereInput
    none?: StudentWhereInput
  }

  export type ClassListRelationFilter = {
    every?: ClassWhereInput
    some?: ClassWhereInput
    none?: ClassWhereInput
  }

  export type SubjectListRelationFilter = {
    every?: SubjectWhereInput
    some?: SubjectWhereInput
    none?: SubjectWhereInput
  }

  export type FeeStructureListRelationFilter = {
    every?: FeeStructureWhereInput
    some?: FeeStructureWhereInput
    none?: FeeStructureWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type TimetableSlotListRelationFilter = {
    every?: TimetableSlotWhereInput
    some?: TimetableSlotWhereInput
    none?: TimetableSlotWhereInput
  }

  export type SchoolAnnouncementListRelationFilter = {
    every?: SchoolAnnouncementWhereInput
    some?: SchoolAnnouncementWhereInput
    none?: SchoolAnnouncementWhereInput
  }

  export type ClassAnnouncementListRelationFilter = {
    every?: ClassAnnouncementWhereInput
    some?: ClassAnnouncementWhereInput
    none?: ClassAnnouncementWhereInput
  }

  export type StudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeeStructureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TimetableSlotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolAnnouncementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassAnnouncementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolOrderByRelevanceInput = {
    fields: SchoolOrderByRelevanceFieldEnum | SchoolOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SchoolCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    stateOrRegion?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    phoneNumber?: SortOrder
    schoolEmail?: SortOrder
    website?: SortOrder
    logoUrl?: SortOrder
    currentAcademicYear?: SortOrder
    currentTerm?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    isActive?: SortOrder
    createdBySuperAdminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    stateOrRegion?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    phoneNumber?: SortOrder
    schoolEmail?: SortOrder
    website?: SortOrder
    logoUrl?: SortOrder
    currentAcademicYear?: SortOrder
    currentTerm?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    isActive?: SortOrder
    createdBySuperAdminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    stateOrRegion?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    phoneNumber?: SortOrder
    schoolEmail?: SortOrder
    website?: SortOrder
    logoUrl?: SortOrder
    currentAcademicYear?: SortOrder
    currentTerm?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    isActive?: SortOrder
    createdBySuperAdminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTermPeriodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TermPeriod | EnumTermPeriodFieldRefInput<$PrismaModel> | null
    in?: $Enums.TermPeriod[] | null
    notIn?: $Enums.TermPeriod[] | null
    not?: NestedEnumTermPeriodNullableWithAggregatesFilter<$PrismaModel> | $Enums.TermPeriod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTermPeriodNullableFilter<$PrismaModel>
    _max?: NestedEnumTermPeriodNullableFilter<$PrismaModel>
  }

  export type SchoolScalarRelationFilter = {
    is?: SchoolWhereInput
    isNot?: SchoolWhereInput
  }

  export type SchoolAdminOrderByRelevanceInput = {
    fields: SchoolAdminOrderByRelevanceFieldEnum | SchoolAdminOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SchoolAdminUserIdSchoolIdCompoundUniqueInput = {
    userId: string
    schoolId: string
  }

  export type SchoolAdminCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    schoolId?: SortOrder
    jobTitle?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolAdminMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    schoolId?: SortOrder
    jobTitle?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolAdminMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    schoolId?: SortOrder
    jobTitle?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StudentGradeListRelationFilter = {
    every?: StudentGradeWhereInput
    some?: StudentGradeWhereInput
    none?: StudentGradeWhereInput
  }

  export type AssignmentListRelationFilter = {
    every?: AssignmentWhereInput
    some?: AssignmentWhereInput
    none?: AssignmentWhereInput
  }

  export type StudentGradeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeacherOrderByRelevanceInput = {
    fields: TeacherOrderByRelevanceFieldEnum | TeacherOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TeacherUserIdSchoolIdCompoundUniqueInput = {
    userId: string
    schoolId: string
  }

  export type TeacherSchoolIdTeacherIdNumberCompoundUniqueInput = {
    schoolId: string
    teacherIdNumber: string
  }

  export type TeacherCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    schoolId?: SortOrder
    teacherIdNumber?: SortOrder
    dateOfJoining?: SortOrder
    qualifications?: SortOrder
    specialization?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    schoolId?: SortOrder
    teacherIdNumber?: SortOrder
    dateOfJoining?: SortOrder
    qualifications?: SortOrder
    specialization?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    schoolId?: SortOrder
    teacherIdNumber?: SortOrder
    dateOfJoining?: SortOrder
    qualifications?: SortOrder
    specialization?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[]
    notIn?: $Enums.Gender[]
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ClassNullableScalarRelationFilter = {
    is?: ClassWhereInput | null
    isNot?: ClassWhereInput | null
  }

  export type StudentParentLinkListRelationFilter = {
    every?: StudentParentLinkWhereInput
    some?: StudentParentLinkWhereInput
    none?: StudentParentLinkWhereInput
  }

  export type StudentClassEnrollmentListRelationFilter = {
    every?: StudentClassEnrollmentWhereInput
    some?: StudentClassEnrollmentWhereInput
    none?: StudentClassEnrollmentWhereInput
  }

  export type InvoiceLineItemListRelationFilter = {
    every?: InvoiceLineItemWhereInput
    some?: InvoiceLineItemWhereInput
    none?: InvoiceLineItemWhereInput
  }

  export type StudentParentLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentClassEnrollmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceLineItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentOrderByRelevanceInput = {
    fields: StudentOrderByRelevanceFieldEnum | StudentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StudentSchoolIdStudentIdNumberCompoundUniqueInput = {
    schoolId: string
    studentIdNumber: string
  }

  export type StudentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    schoolId?: SortOrder
    studentIdNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    middleName?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    enrollmentDate?: SortOrder
    profilePictureUrl?: SortOrder
    address?: SortOrder
    city?: SortOrder
    stateOrRegion?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    bloodGroup?: SortOrder
    allergies?: SortOrder
    medicalNotes?: SortOrder
    isActive?: SortOrder
    currentClassId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    schoolId?: SortOrder
    studentIdNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    middleName?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    enrollmentDate?: SortOrder
    profilePictureUrl?: SortOrder
    address?: SortOrder
    city?: SortOrder
    stateOrRegion?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    bloodGroup?: SortOrder
    allergies?: SortOrder
    medicalNotes?: SortOrder
    isActive?: SortOrder
    currentClassId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    schoolId?: SortOrder
    studentIdNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    middleName?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    enrollmentDate?: SortOrder
    profilePictureUrl?: SortOrder
    address?: SortOrder
    city?: SortOrder
    stateOrRegion?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    bloodGroup?: SortOrder
    allergies?: SortOrder
    medicalNotes?: SortOrder
    isActive?: SortOrder
    currentClassId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[]
    notIn?: $Enums.Gender[]
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type ParentOrderByRelevanceInput = {
    fields: ParentOrderByRelevanceFieldEnum | ParentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ParentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    occupation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    occupation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    occupation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentScalarRelationFilter = {
    is?: StudentWhereInput
    isNot?: StudentWhereInput
  }

  export type ParentScalarRelationFilter = {
    is?: ParentWhereInput
    isNot?: ParentWhereInput
  }

  export type StudentParentLinkOrderByRelevanceInput = {
    fields: StudentParentLinkOrderByRelevanceFieldEnum | StudentParentLinkOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StudentParentLinkStudentIdParentIdCompoundUniqueInput = {
    studentId: string
    parentId: string
  }

  export type StudentParentLinkCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    parentId?: SortOrder
    relationshipToStudent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentParentLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    parentId?: SortOrder
    relationshipToStudent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentParentLinkMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    parentId?: SortOrder
    relationshipToStudent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherNullableScalarRelationFilter = {
    is?: TeacherWhereInput | null
    isNot?: TeacherWhereInput | null
  }

  export type ClassOrderByRelevanceInput = {
    fields: ClassOrderByRelevanceFieldEnum | ClassOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ClassSchoolIdNameSectionAcademicYearCompoundUniqueInput = {
    schoolId: string
    name: string
    section: string
    academicYear: string
  }

  export type ClassCountOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    section?: SortOrder
    academicYear?: SortOrder
    homeroomTeacherId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    section?: SortOrder
    academicYear?: SortOrder
    homeroomTeacherId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassMinOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    section?: SortOrder
    academicYear?: SortOrder
    homeroomTeacherId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassScalarRelationFilter = {
    is?: ClassWhereInput
    isNot?: ClassWhereInput
  }

  export type StudentClassEnrollmentOrderByRelevanceInput = {
    fields: StudentClassEnrollmentOrderByRelevanceFieldEnum | StudentClassEnrollmentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StudentClassEnrollmentStudentIdClassIdAcademicYearCompoundUniqueInput = {
    studentId: string
    classId: string
    academicYear: string
  }

  export type StudentClassEnrollmentCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    academicYear?: SortOrder
    enrollmentDate?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentClassEnrollmentMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    academicYear?: SortOrder
    enrollmentDate?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentClassEnrollmentMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    academicYear?: SortOrder
    enrollmentDate?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectOrderByRelevanceInput = {
    fields: SubjectOrderByRelevanceFieldEnum | SubjectOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SubjectSchoolIdNameCompoundUniqueInput = {
    schoolId: string
    name: string
  }

  export type SubjectSchoolIdCodeCompoundUniqueInput = {
    schoolId: string
    code: string
  }

  export type SubjectCountOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectMinOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDayOfWeekFilter<$PrismaModel = never> = {
    equals?: $Enums.DayOfWeek | EnumDayOfWeekFieldRefInput<$PrismaModel>
    in?: $Enums.DayOfWeek[]
    notIn?: $Enums.DayOfWeek[]
    not?: NestedEnumDayOfWeekFilter<$PrismaModel> | $Enums.DayOfWeek
  }

  export type SubjectScalarRelationFilter = {
    is?: SubjectWhereInput
    isNot?: SubjectWhereInput
  }

  export type TeacherScalarRelationFilter = {
    is?: TeacherWhereInput
    isNot?: TeacherWhereInput
  }

  export type TimetableSlotOrderByRelevanceInput = {
    fields: TimetableSlotOrderByRelevanceFieldEnum | TimetableSlotOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TimetableSlotCountOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    teacherId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    room?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimetableSlotMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    teacherId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    room?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimetableSlotMinOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    teacherId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    room?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDayOfWeekWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DayOfWeek | EnumDayOfWeekFieldRefInput<$PrismaModel>
    in?: $Enums.DayOfWeek[]
    notIn?: $Enums.DayOfWeek[]
    not?: NestedEnumDayOfWeekWithAggregatesFilter<$PrismaModel> | $Enums.DayOfWeek
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDayOfWeekFilter<$PrismaModel>
    _max?: NestedEnumDayOfWeekFilter<$PrismaModel>
  }

  export type EnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[]
    notIn?: $Enums.AttendanceStatus[]
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type EnumTermPeriodFilter<$PrismaModel = never> = {
    equals?: $Enums.TermPeriod | EnumTermPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.TermPeriod[]
    notIn?: $Enums.TermPeriod[]
    not?: NestedEnumTermPeriodFilter<$PrismaModel> | $Enums.TermPeriod
  }

  export type TimetableSlotNullableScalarRelationFilter = {
    is?: TimetableSlotWhereInput | null
    isNot?: TimetableSlotWhereInput | null
  }

  export type StudentAttendanceOrderByRelevanceInput = {
    fields: StudentAttendanceOrderByRelevanceFieldEnum | StudentAttendanceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StudentAttendanceUnique_student_attendance_per_slotCompoundUniqueInput = {
    studentId: string
    date: Date | string
    timetableSlotId: string
    academicYear: string
    term: $Enums.TermPeriod
  }

  export type StudentAttendanceUnique_student_attendance_per_class_subjectCompoundUniqueInput = {
    studentId: string
    date: Date | string
    classId: string
    subjectId: string
    academicYear: string
    term: $Enums.TermPeriod
  }

  export type StudentAttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    academicYear?: SortOrder
    term?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    timetableSlotId?: SortOrder
    recordedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentAttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    academicYear?: SortOrder
    term?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    timetableSlotId?: SortOrder
    recordedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentAttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    academicYear?: SortOrder
    term?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    timetableSlotId?: SortOrder
    recordedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[]
    notIn?: $Enums.AttendanceStatus[]
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type EnumTermPeriodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TermPeriod | EnumTermPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.TermPeriod[]
    notIn?: $Enums.TermPeriod[]
    not?: NestedEnumTermPeriodWithAggregatesFilter<$PrismaModel> | $Enums.TermPeriod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTermPeriodFilter<$PrismaModel>
    _max?: NestedEnumTermPeriodFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type AssignmentOrderByRelevanceInput = {
    fields: AssignmentOrderByRelevanceFieldEnum | AssignmentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    teacherId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    maxPoints?: SortOrder
    dueDate?: SortOrder
    academicYear?: SortOrder
    term?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssignmentAvgOrderByAggregateInput = {
    maxPoints?: SortOrder
  }

  export type AssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    teacherId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    maxPoints?: SortOrder
    dueDate?: SortOrder
    academicYear?: SortOrder
    term?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    teacherId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    maxPoints?: SortOrder
    dueDate?: SortOrder
    academicYear?: SortOrder
    term?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssignmentSumOrderByAggregateInput = {
    maxPoints?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type AssignmentNullableScalarRelationFilter = {
    is?: AssignmentWhereInput | null
    isNot?: AssignmentWhereInput | null
  }

  export type StudentGradeOrderByRelevanceInput = {
    fields: StudentGradeOrderByRelevanceFieldEnum | StudentGradeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StudentGradeStudentIdSubjectIdAssignmentIdAcademicYearTermCompoundUniqueInput = {
    studentId: string
    subjectId: string
    assignmentId: string
    academicYear: string
    term: $Enums.TermPeriod
  }

  export type StudentGradeCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    assignmentId?: SortOrder
    teacherId?: SortOrder
    grade?: SortOrder
    numericValue?: SortOrder
    comments?: SortOrder
    academicYear?: SortOrder
    term?: SortOrder
    dateRecorded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentGradeAvgOrderByAggregateInput = {
    numericValue?: SortOrder
  }

  export type StudentGradeMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    assignmentId?: SortOrder
    teacherId?: SortOrder
    grade?: SortOrder
    numericValue?: SortOrder
    comments?: SortOrder
    academicYear?: SortOrder
    term?: SortOrder
    dateRecorded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentGradeMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    assignmentId?: SortOrder
    teacherId?: SortOrder
    grade?: SortOrder
    numericValue?: SortOrder
    comments?: SortOrder
    academicYear?: SortOrder
    term?: SortOrder
    dateRecorded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentGradeSumOrderByAggregateInput = {
    numericValue?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type FeeStructureOrderByRelevanceInput = {
    fields: FeeStructureOrderByRelevanceFieldEnum | FeeStructureOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FeeStructureSchoolIdNameAcademicYearTermCompoundUniqueInput = {
    schoolId: string
    name: string
    academicYear: string
    term: $Enums.TermPeriod
  }

  export type FeeStructureCountOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    academicYear?: SortOrder
    term?: SortOrder
    frequency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeeStructureAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type FeeStructureMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    academicYear?: SortOrder
    term?: SortOrder
    frequency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeeStructureMinOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    academicYear?: SortOrder
    term?: SortOrder
    frequency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeeStructureSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[]
    notIn?: $Enums.PaymentStatus[]
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type InvoiceOrderByRelevanceInput = {
    fields: InvoiceOrderByRelevanceFieldEnum | InvoiceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type InvoiceSchoolIdInvoiceNumberCompoundUniqueInput = {
    schoolId: string
    invoiceNumber: string
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    studentId?: SortOrder
    parentToBillId?: SortOrder
    invoiceNumber?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    academicYear?: SortOrder
    term?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
    paidAmount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    studentId?: SortOrder
    parentToBillId?: SortOrder
    invoiceNumber?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    academicYear?: SortOrder
    term?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    studentId?: SortOrder
    parentToBillId?: SortOrder
    invoiceNumber?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    academicYear?: SortOrder
    term?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    totalAmount?: SortOrder
    paidAmount?: SortOrder
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[]
    notIn?: $Enums.PaymentStatus[]
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type InvoiceScalarRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type FeeStructureNullableScalarRelationFilter = {
    is?: FeeStructureWhereInput | null
    isNot?: FeeStructureWhereInput | null
  }

  export type InvoiceLineItemOrderByRelevanceInput = {
    fields: InvoiceLineItemOrderByRelevanceFieldEnum | InvoiceLineItemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type InvoiceLineItemCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    feeStructureId?: SortOrder
    studentId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceLineItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    amount?: SortOrder
  }

  export type InvoiceLineItemMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    feeStructureId?: SortOrder
    studentId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceLineItemMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    feeStructureId?: SortOrder
    studentId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceLineItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    amount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type PaymentOrderByRelevanceInput = {
    fields: PaymentOrderByRelevanceFieldEnum | PaymentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    paymentDate?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    recordedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    paymentDate?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    recordedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    paymentDate?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    recordedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type SchoolAdminNullableScalarRelationFilter = {
    is?: SchoolAdminWhereInput | null
    isNot?: SchoolAdminWhereInput | null
  }

  export type SchoolAnnouncementOrderByRelevanceInput = {
    fields: SchoolAnnouncementOrderByRelevanceFieldEnum | SchoolAnnouncementOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SchoolAnnouncementCountOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    publishDate?: SortOrder
    expiryDate?: SortOrder
    audience?: SortOrder
    isPublished?: SortOrder
    createdByAdminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolAnnouncementMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    publishDate?: SortOrder
    expiryDate?: SortOrder
    audience?: SortOrder
    isPublished?: SortOrder
    createdByAdminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolAnnouncementMinOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    publishDate?: SortOrder
    expiryDate?: SortOrder
    audience?: SortOrder
    isPublished?: SortOrder
    createdByAdminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassAnnouncementOrderByRelevanceInput = {
    fields: ClassAnnouncementOrderByRelevanceFieldEnum | ClassAnnouncementOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ClassAnnouncementCountOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    classId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    publishDate?: SortOrder
    isPublished?: SortOrder
    createdByTeacherId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassAnnouncementMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    classId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    publishDate?: SortOrder
    isPublished?: SortOrder
    createdByTeacherId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassAnnouncementMinOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    classId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    publishDate?: SortOrder
    isPublished?: SortOrder
    createdByTeacherId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type SuperAdminCreateNestedOneWithoutUserInput = {
    create?: XOR<SuperAdminCreateWithoutUserInput, SuperAdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: SuperAdminCreateOrConnectWithoutUserInput
    connect?: SuperAdminWhereUniqueInput
  }

  export type SchoolAdminCreateNestedManyWithoutUserInput = {
    create?: XOR<SchoolAdminCreateWithoutUserInput, SchoolAdminUncheckedCreateWithoutUserInput> | SchoolAdminCreateWithoutUserInput[] | SchoolAdminUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SchoolAdminCreateOrConnectWithoutUserInput | SchoolAdminCreateOrConnectWithoutUserInput[]
    createMany?: SchoolAdminCreateManyUserInputEnvelope
    connect?: SchoolAdminWhereUniqueInput | SchoolAdminWhereUniqueInput[]
  }

  export type TeacherCreateNestedManyWithoutUserInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput> | TeacherCreateWithoutUserInput[] | TeacherUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput | TeacherCreateOrConnectWithoutUserInput[]
    createMany?: TeacherCreateManyUserInputEnvelope
    connect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
  }

  export type StudentCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    connect?: StudentWhereUniqueInput
  }

  export type ParentCreateNestedOneWithoutUserInput = {
    create?: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParentCreateOrConnectWithoutUserInput
    connect?: ParentWhereUniqueInput
  }

  export type StudentAttendanceCreateNestedManyWithoutRecordedByInput = {
    create?: XOR<StudentAttendanceCreateWithoutRecordedByInput, StudentAttendanceUncheckedCreateWithoutRecordedByInput> | StudentAttendanceCreateWithoutRecordedByInput[] | StudentAttendanceUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutRecordedByInput | StudentAttendanceCreateOrConnectWithoutRecordedByInput[]
    createMany?: StudentAttendanceCreateManyRecordedByInputEnvelope
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutRecordedByInput = {
    create?: XOR<PaymentCreateWithoutRecordedByInput, PaymentUncheckedCreateWithoutRecordedByInput> | PaymentCreateWithoutRecordedByInput[] | PaymentUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutRecordedByInput | PaymentCreateOrConnectWithoutRecordedByInput[]
    createMany?: PaymentCreateManyRecordedByInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type SuperAdminUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<SuperAdminCreateWithoutUserInput, SuperAdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: SuperAdminCreateOrConnectWithoutUserInput
    connect?: SuperAdminWhereUniqueInput
  }

  export type SchoolAdminUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SchoolAdminCreateWithoutUserInput, SchoolAdminUncheckedCreateWithoutUserInput> | SchoolAdminCreateWithoutUserInput[] | SchoolAdminUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SchoolAdminCreateOrConnectWithoutUserInput | SchoolAdminCreateOrConnectWithoutUserInput[]
    createMany?: SchoolAdminCreateManyUserInputEnvelope
    connect?: SchoolAdminWhereUniqueInput | SchoolAdminWhereUniqueInput[]
  }

  export type TeacherUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput> | TeacherCreateWithoutUserInput[] | TeacherUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput | TeacherCreateOrConnectWithoutUserInput[]
    createMany?: TeacherCreateManyUserInputEnvelope
    connect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    connect?: StudentWhereUniqueInput
  }

  export type ParentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParentCreateOrConnectWithoutUserInput
    connect?: ParentWhereUniqueInput
  }

  export type StudentAttendanceUncheckedCreateNestedManyWithoutRecordedByInput = {
    create?: XOR<StudentAttendanceCreateWithoutRecordedByInput, StudentAttendanceUncheckedCreateWithoutRecordedByInput> | StudentAttendanceCreateWithoutRecordedByInput[] | StudentAttendanceUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutRecordedByInput | StudentAttendanceCreateOrConnectWithoutRecordedByInput[]
    createMany?: StudentAttendanceCreateManyRecordedByInputEnvelope
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutRecordedByInput = {
    create?: XOR<PaymentCreateWithoutRecordedByInput, PaymentUncheckedCreateWithoutRecordedByInput> | PaymentCreateWithoutRecordedByInput[] | PaymentUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutRecordedByInput | PaymentCreateOrConnectWithoutRecordedByInput[]
    createMany?: PaymentCreateManyRecordedByInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type SuperAdminUpdateOneWithoutUserNestedInput = {
    create?: XOR<SuperAdminCreateWithoutUserInput, SuperAdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: SuperAdminCreateOrConnectWithoutUserInput
    upsert?: SuperAdminUpsertWithoutUserInput
    disconnect?: SuperAdminWhereInput | boolean
    delete?: SuperAdminWhereInput | boolean
    connect?: SuperAdminWhereUniqueInput
    update?: XOR<XOR<SuperAdminUpdateToOneWithWhereWithoutUserInput, SuperAdminUpdateWithoutUserInput>, SuperAdminUncheckedUpdateWithoutUserInput>
  }

  export type SchoolAdminUpdateManyWithoutUserNestedInput = {
    create?: XOR<SchoolAdminCreateWithoutUserInput, SchoolAdminUncheckedCreateWithoutUserInput> | SchoolAdminCreateWithoutUserInput[] | SchoolAdminUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SchoolAdminCreateOrConnectWithoutUserInput | SchoolAdminCreateOrConnectWithoutUserInput[]
    upsert?: SchoolAdminUpsertWithWhereUniqueWithoutUserInput | SchoolAdminUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SchoolAdminCreateManyUserInputEnvelope
    set?: SchoolAdminWhereUniqueInput | SchoolAdminWhereUniqueInput[]
    disconnect?: SchoolAdminWhereUniqueInput | SchoolAdminWhereUniqueInput[]
    delete?: SchoolAdminWhereUniqueInput | SchoolAdminWhereUniqueInput[]
    connect?: SchoolAdminWhereUniqueInput | SchoolAdminWhereUniqueInput[]
    update?: SchoolAdminUpdateWithWhereUniqueWithoutUserInput | SchoolAdminUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SchoolAdminUpdateManyWithWhereWithoutUserInput | SchoolAdminUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SchoolAdminScalarWhereInput | SchoolAdminScalarWhereInput[]
  }

  export type TeacherUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput> | TeacherCreateWithoutUserInput[] | TeacherUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput | TeacherCreateOrConnectWithoutUserInput[]
    upsert?: TeacherUpsertWithWhereUniqueWithoutUserInput | TeacherUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeacherCreateManyUserInputEnvelope
    set?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    disconnect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    delete?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    connect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    update?: TeacherUpdateWithWhereUniqueWithoutUserInput | TeacherUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeacherUpdateManyWithWhereWithoutUserInput | TeacherUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeacherScalarWhereInput | TeacherScalarWhereInput[]
  }

  export type StudentUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    upsert?: StudentUpsertWithoutUserInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutUserInput, StudentUpdateWithoutUserInput>, StudentUncheckedUpdateWithoutUserInput>
  }

  export type ParentUpdateOneWithoutUserNestedInput = {
    create?: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParentCreateOrConnectWithoutUserInput
    upsert?: ParentUpsertWithoutUserInput
    disconnect?: ParentWhereInput | boolean
    delete?: ParentWhereInput | boolean
    connect?: ParentWhereUniqueInput
    update?: XOR<XOR<ParentUpdateToOneWithWhereWithoutUserInput, ParentUpdateWithoutUserInput>, ParentUncheckedUpdateWithoutUserInput>
  }

  export type StudentAttendanceUpdateManyWithoutRecordedByNestedInput = {
    create?: XOR<StudentAttendanceCreateWithoutRecordedByInput, StudentAttendanceUncheckedCreateWithoutRecordedByInput> | StudentAttendanceCreateWithoutRecordedByInput[] | StudentAttendanceUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutRecordedByInput | StudentAttendanceCreateOrConnectWithoutRecordedByInput[]
    upsert?: StudentAttendanceUpsertWithWhereUniqueWithoutRecordedByInput | StudentAttendanceUpsertWithWhereUniqueWithoutRecordedByInput[]
    createMany?: StudentAttendanceCreateManyRecordedByInputEnvelope
    set?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    disconnect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    delete?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    update?: StudentAttendanceUpdateWithWhereUniqueWithoutRecordedByInput | StudentAttendanceUpdateWithWhereUniqueWithoutRecordedByInput[]
    updateMany?: StudentAttendanceUpdateManyWithWhereWithoutRecordedByInput | StudentAttendanceUpdateManyWithWhereWithoutRecordedByInput[]
    deleteMany?: StudentAttendanceScalarWhereInput | StudentAttendanceScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutRecordedByNestedInput = {
    create?: XOR<PaymentCreateWithoutRecordedByInput, PaymentUncheckedCreateWithoutRecordedByInput> | PaymentCreateWithoutRecordedByInput[] | PaymentUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutRecordedByInput | PaymentCreateOrConnectWithoutRecordedByInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutRecordedByInput | PaymentUpsertWithWhereUniqueWithoutRecordedByInput[]
    createMany?: PaymentCreateManyRecordedByInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutRecordedByInput | PaymentUpdateWithWhereUniqueWithoutRecordedByInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutRecordedByInput | PaymentUpdateManyWithWhereWithoutRecordedByInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type SuperAdminUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<SuperAdminCreateWithoutUserInput, SuperAdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: SuperAdminCreateOrConnectWithoutUserInput
    upsert?: SuperAdminUpsertWithoutUserInput
    disconnect?: SuperAdminWhereInput | boolean
    delete?: SuperAdminWhereInput | boolean
    connect?: SuperAdminWhereUniqueInput
    update?: XOR<XOR<SuperAdminUpdateToOneWithWhereWithoutUserInput, SuperAdminUpdateWithoutUserInput>, SuperAdminUncheckedUpdateWithoutUserInput>
  }

  export type SchoolAdminUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SchoolAdminCreateWithoutUserInput, SchoolAdminUncheckedCreateWithoutUserInput> | SchoolAdminCreateWithoutUserInput[] | SchoolAdminUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SchoolAdminCreateOrConnectWithoutUserInput | SchoolAdminCreateOrConnectWithoutUserInput[]
    upsert?: SchoolAdminUpsertWithWhereUniqueWithoutUserInput | SchoolAdminUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SchoolAdminCreateManyUserInputEnvelope
    set?: SchoolAdminWhereUniqueInput | SchoolAdminWhereUniqueInput[]
    disconnect?: SchoolAdminWhereUniqueInput | SchoolAdminWhereUniqueInput[]
    delete?: SchoolAdminWhereUniqueInput | SchoolAdminWhereUniqueInput[]
    connect?: SchoolAdminWhereUniqueInput | SchoolAdminWhereUniqueInput[]
    update?: SchoolAdminUpdateWithWhereUniqueWithoutUserInput | SchoolAdminUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SchoolAdminUpdateManyWithWhereWithoutUserInput | SchoolAdminUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SchoolAdminScalarWhereInput | SchoolAdminScalarWhereInput[]
  }

  export type TeacherUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput> | TeacherCreateWithoutUserInput[] | TeacherUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput | TeacherCreateOrConnectWithoutUserInput[]
    upsert?: TeacherUpsertWithWhereUniqueWithoutUserInput | TeacherUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeacherCreateManyUserInputEnvelope
    set?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    disconnect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    delete?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    connect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    update?: TeacherUpdateWithWhereUniqueWithoutUserInput | TeacherUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeacherUpdateManyWithWhereWithoutUserInput | TeacherUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeacherScalarWhereInput | TeacherScalarWhereInput[]
  }

  export type StudentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    upsert?: StudentUpsertWithoutUserInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutUserInput, StudentUpdateWithoutUserInput>, StudentUncheckedUpdateWithoutUserInput>
  }

  export type ParentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParentCreateOrConnectWithoutUserInput
    upsert?: ParentUpsertWithoutUserInput
    disconnect?: ParentWhereInput | boolean
    delete?: ParentWhereInput | boolean
    connect?: ParentWhereUniqueInput
    update?: XOR<XOR<ParentUpdateToOneWithWhereWithoutUserInput, ParentUpdateWithoutUserInput>, ParentUncheckedUpdateWithoutUserInput>
  }

  export type StudentAttendanceUncheckedUpdateManyWithoutRecordedByNestedInput = {
    create?: XOR<StudentAttendanceCreateWithoutRecordedByInput, StudentAttendanceUncheckedCreateWithoutRecordedByInput> | StudentAttendanceCreateWithoutRecordedByInput[] | StudentAttendanceUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutRecordedByInput | StudentAttendanceCreateOrConnectWithoutRecordedByInput[]
    upsert?: StudentAttendanceUpsertWithWhereUniqueWithoutRecordedByInput | StudentAttendanceUpsertWithWhereUniqueWithoutRecordedByInput[]
    createMany?: StudentAttendanceCreateManyRecordedByInputEnvelope
    set?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    disconnect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    delete?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    update?: StudentAttendanceUpdateWithWhereUniqueWithoutRecordedByInput | StudentAttendanceUpdateWithWhereUniqueWithoutRecordedByInput[]
    updateMany?: StudentAttendanceUpdateManyWithWhereWithoutRecordedByInput | StudentAttendanceUpdateManyWithWhereWithoutRecordedByInput[]
    deleteMany?: StudentAttendanceScalarWhereInput | StudentAttendanceScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutRecordedByNestedInput = {
    create?: XOR<PaymentCreateWithoutRecordedByInput, PaymentUncheckedCreateWithoutRecordedByInput> | PaymentCreateWithoutRecordedByInput[] | PaymentUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutRecordedByInput | PaymentCreateOrConnectWithoutRecordedByInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutRecordedByInput | PaymentUpsertWithWhereUniqueWithoutRecordedByInput[]
    createMany?: PaymentCreateManyRecordedByInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutRecordedByInput | PaymentUpdateWithWhereUniqueWithoutRecordedByInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutRecordedByInput | PaymentUpdateManyWithWhereWithoutRecordedByInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutSuperAdminInput = {
    create?: XOR<UserCreateWithoutSuperAdminInput, UserUncheckedCreateWithoutSuperAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutSuperAdminInput
    connect?: UserWhereUniqueInput
  }

  export type SchoolCreateNestedManyWithoutCreatedBySuperAdminInput = {
    create?: XOR<SchoolCreateWithoutCreatedBySuperAdminInput, SchoolUncheckedCreateWithoutCreatedBySuperAdminInput> | SchoolCreateWithoutCreatedBySuperAdminInput[] | SchoolUncheckedCreateWithoutCreatedBySuperAdminInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutCreatedBySuperAdminInput | SchoolCreateOrConnectWithoutCreatedBySuperAdminInput[]
    createMany?: SchoolCreateManyCreatedBySuperAdminInputEnvelope
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
  }

  export type SchoolUncheckedCreateNestedManyWithoutCreatedBySuperAdminInput = {
    create?: XOR<SchoolCreateWithoutCreatedBySuperAdminInput, SchoolUncheckedCreateWithoutCreatedBySuperAdminInput> | SchoolCreateWithoutCreatedBySuperAdminInput[] | SchoolUncheckedCreateWithoutCreatedBySuperAdminInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutCreatedBySuperAdminInput | SchoolCreateOrConnectWithoutCreatedBySuperAdminInput[]
    createMany?: SchoolCreateManyCreatedBySuperAdminInputEnvelope
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutSuperAdminNestedInput = {
    create?: XOR<UserCreateWithoutSuperAdminInput, UserUncheckedCreateWithoutSuperAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutSuperAdminInput
    upsert?: UserUpsertWithoutSuperAdminInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSuperAdminInput, UserUpdateWithoutSuperAdminInput>, UserUncheckedUpdateWithoutSuperAdminInput>
  }

  export type SchoolUpdateManyWithoutCreatedBySuperAdminNestedInput = {
    create?: XOR<SchoolCreateWithoutCreatedBySuperAdminInput, SchoolUncheckedCreateWithoutCreatedBySuperAdminInput> | SchoolCreateWithoutCreatedBySuperAdminInput[] | SchoolUncheckedCreateWithoutCreatedBySuperAdminInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutCreatedBySuperAdminInput | SchoolCreateOrConnectWithoutCreatedBySuperAdminInput[]
    upsert?: SchoolUpsertWithWhereUniqueWithoutCreatedBySuperAdminInput | SchoolUpsertWithWhereUniqueWithoutCreatedBySuperAdminInput[]
    createMany?: SchoolCreateManyCreatedBySuperAdminInputEnvelope
    set?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    disconnect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    delete?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    update?: SchoolUpdateWithWhereUniqueWithoutCreatedBySuperAdminInput | SchoolUpdateWithWhereUniqueWithoutCreatedBySuperAdminInput[]
    updateMany?: SchoolUpdateManyWithWhereWithoutCreatedBySuperAdminInput | SchoolUpdateManyWithWhereWithoutCreatedBySuperAdminInput[]
    deleteMany?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
  }

  export type SchoolUncheckedUpdateManyWithoutCreatedBySuperAdminNestedInput = {
    create?: XOR<SchoolCreateWithoutCreatedBySuperAdminInput, SchoolUncheckedCreateWithoutCreatedBySuperAdminInput> | SchoolCreateWithoutCreatedBySuperAdminInput[] | SchoolUncheckedCreateWithoutCreatedBySuperAdminInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutCreatedBySuperAdminInput | SchoolCreateOrConnectWithoutCreatedBySuperAdminInput[]
    upsert?: SchoolUpsertWithWhereUniqueWithoutCreatedBySuperAdminInput | SchoolUpsertWithWhereUniqueWithoutCreatedBySuperAdminInput[]
    createMany?: SchoolCreateManyCreatedBySuperAdminInputEnvelope
    set?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    disconnect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    delete?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    update?: SchoolUpdateWithWhereUniqueWithoutCreatedBySuperAdminInput | SchoolUpdateWithWhereUniqueWithoutCreatedBySuperAdminInput[]
    updateMany?: SchoolUpdateManyWithWhereWithoutCreatedBySuperAdminInput | SchoolUpdateManyWithWhereWithoutCreatedBySuperAdminInput[]
    deleteMany?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
  }

  export type SuperAdminCreateNestedOneWithoutSchoolsCreatedInput = {
    create?: XOR<SuperAdminCreateWithoutSchoolsCreatedInput, SuperAdminUncheckedCreateWithoutSchoolsCreatedInput>
    connectOrCreate?: SuperAdminCreateOrConnectWithoutSchoolsCreatedInput
    connect?: SuperAdminWhereUniqueInput
  }

  export type SchoolAdminCreateNestedManyWithoutSchoolInput = {
    create?: XOR<SchoolAdminCreateWithoutSchoolInput, SchoolAdminUncheckedCreateWithoutSchoolInput> | SchoolAdminCreateWithoutSchoolInput[] | SchoolAdminUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SchoolAdminCreateOrConnectWithoutSchoolInput | SchoolAdminCreateOrConnectWithoutSchoolInput[]
    createMany?: SchoolAdminCreateManySchoolInputEnvelope
    connect?: SchoolAdminWhereUniqueInput | SchoolAdminWhereUniqueInput[]
  }

  export type TeacherCreateNestedManyWithoutSchoolInput = {
    create?: XOR<TeacherCreateWithoutSchoolInput, TeacherUncheckedCreateWithoutSchoolInput> | TeacherCreateWithoutSchoolInput[] | TeacherUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TeacherCreateOrConnectWithoutSchoolInput | TeacherCreateOrConnectWithoutSchoolInput[]
    createMany?: TeacherCreateManySchoolInputEnvelope
    connect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
  }

  export type StudentCreateNestedManyWithoutSchoolInput = {
    create?: XOR<StudentCreateWithoutSchoolInput, StudentUncheckedCreateWithoutSchoolInput> | StudentCreateWithoutSchoolInput[] | StudentUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutSchoolInput | StudentCreateOrConnectWithoutSchoolInput[]
    createMany?: StudentCreateManySchoolInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type ClassCreateNestedManyWithoutSchoolInput = {
    create?: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput> | ClassCreateWithoutSchoolInput[] | ClassUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSchoolInput | ClassCreateOrConnectWithoutSchoolInput[]
    createMany?: ClassCreateManySchoolInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type SubjectCreateNestedManyWithoutSchoolInput = {
    create?: XOR<SubjectCreateWithoutSchoolInput, SubjectUncheckedCreateWithoutSchoolInput> | SubjectCreateWithoutSchoolInput[] | SubjectUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutSchoolInput | SubjectCreateOrConnectWithoutSchoolInput[]
    createMany?: SubjectCreateManySchoolInputEnvelope
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type FeeStructureCreateNestedManyWithoutSchoolInput = {
    create?: XOR<FeeStructureCreateWithoutSchoolInput, FeeStructureUncheckedCreateWithoutSchoolInput> | FeeStructureCreateWithoutSchoolInput[] | FeeStructureUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: FeeStructureCreateOrConnectWithoutSchoolInput | FeeStructureCreateOrConnectWithoutSchoolInput[]
    createMany?: FeeStructureCreateManySchoolInputEnvelope
    connect?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutSchoolInput = {
    create?: XOR<InvoiceCreateWithoutSchoolInput, InvoiceUncheckedCreateWithoutSchoolInput> | InvoiceCreateWithoutSchoolInput[] | InvoiceUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSchoolInput | InvoiceCreateOrConnectWithoutSchoolInput[]
    createMany?: InvoiceCreateManySchoolInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type TimetableSlotCreateNestedManyWithoutSchoolInput = {
    create?: XOR<TimetableSlotCreateWithoutSchoolInput, TimetableSlotUncheckedCreateWithoutSchoolInput> | TimetableSlotCreateWithoutSchoolInput[] | TimetableSlotUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TimetableSlotCreateOrConnectWithoutSchoolInput | TimetableSlotCreateOrConnectWithoutSchoolInput[]
    createMany?: TimetableSlotCreateManySchoolInputEnvelope
    connect?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
  }

  export type SchoolAnnouncementCreateNestedManyWithoutSchoolInput = {
    create?: XOR<SchoolAnnouncementCreateWithoutSchoolInput, SchoolAnnouncementUncheckedCreateWithoutSchoolInput> | SchoolAnnouncementCreateWithoutSchoolInput[] | SchoolAnnouncementUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SchoolAnnouncementCreateOrConnectWithoutSchoolInput | SchoolAnnouncementCreateOrConnectWithoutSchoolInput[]
    createMany?: SchoolAnnouncementCreateManySchoolInputEnvelope
    connect?: SchoolAnnouncementWhereUniqueInput | SchoolAnnouncementWhereUniqueInput[]
  }

  export type ClassAnnouncementCreateNestedManyWithoutSchoolInput = {
    create?: XOR<ClassAnnouncementCreateWithoutSchoolInput, ClassAnnouncementUncheckedCreateWithoutSchoolInput> | ClassAnnouncementCreateWithoutSchoolInput[] | ClassAnnouncementUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ClassAnnouncementCreateOrConnectWithoutSchoolInput | ClassAnnouncementCreateOrConnectWithoutSchoolInput[]
    createMany?: ClassAnnouncementCreateManySchoolInputEnvelope
    connect?: ClassAnnouncementWhereUniqueInput | ClassAnnouncementWhereUniqueInput[]
  }

  export type SchoolAdminUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<SchoolAdminCreateWithoutSchoolInput, SchoolAdminUncheckedCreateWithoutSchoolInput> | SchoolAdminCreateWithoutSchoolInput[] | SchoolAdminUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SchoolAdminCreateOrConnectWithoutSchoolInput | SchoolAdminCreateOrConnectWithoutSchoolInput[]
    createMany?: SchoolAdminCreateManySchoolInputEnvelope
    connect?: SchoolAdminWhereUniqueInput | SchoolAdminWhereUniqueInput[]
  }

  export type TeacherUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<TeacherCreateWithoutSchoolInput, TeacherUncheckedCreateWithoutSchoolInput> | TeacherCreateWithoutSchoolInput[] | TeacherUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TeacherCreateOrConnectWithoutSchoolInput | TeacherCreateOrConnectWithoutSchoolInput[]
    createMany?: TeacherCreateManySchoolInputEnvelope
    connect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<StudentCreateWithoutSchoolInput, StudentUncheckedCreateWithoutSchoolInput> | StudentCreateWithoutSchoolInput[] | StudentUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutSchoolInput | StudentCreateOrConnectWithoutSchoolInput[]
    createMany?: StudentCreateManySchoolInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type ClassUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput> | ClassCreateWithoutSchoolInput[] | ClassUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSchoolInput | ClassCreateOrConnectWithoutSchoolInput[]
    createMany?: ClassCreateManySchoolInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type SubjectUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<SubjectCreateWithoutSchoolInput, SubjectUncheckedCreateWithoutSchoolInput> | SubjectCreateWithoutSchoolInput[] | SubjectUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutSchoolInput | SubjectCreateOrConnectWithoutSchoolInput[]
    createMany?: SubjectCreateManySchoolInputEnvelope
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type FeeStructureUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<FeeStructureCreateWithoutSchoolInput, FeeStructureUncheckedCreateWithoutSchoolInput> | FeeStructureCreateWithoutSchoolInput[] | FeeStructureUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: FeeStructureCreateOrConnectWithoutSchoolInput | FeeStructureCreateOrConnectWithoutSchoolInput[]
    createMany?: FeeStructureCreateManySchoolInputEnvelope
    connect?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<InvoiceCreateWithoutSchoolInput, InvoiceUncheckedCreateWithoutSchoolInput> | InvoiceCreateWithoutSchoolInput[] | InvoiceUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSchoolInput | InvoiceCreateOrConnectWithoutSchoolInput[]
    createMany?: InvoiceCreateManySchoolInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type TimetableSlotUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<TimetableSlotCreateWithoutSchoolInput, TimetableSlotUncheckedCreateWithoutSchoolInput> | TimetableSlotCreateWithoutSchoolInput[] | TimetableSlotUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TimetableSlotCreateOrConnectWithoutSchoolInput | TimetableSlotCreateOrConnectWithoutSchoolInput[]
    createMany?: TimetableSlotCreateManySchoolInputEnvelope
    connect?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
  }

  export type SchoolAnnouncementUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<SchoolAnnouncementCreateWithoutSchoolInput, SchoolAnnouncementUncheckedCreateWithoutSchoolInput> | SchoolAnnouncementCreateWithoutSchoolInput[] | SchoolAnnouncementUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SchoolAnnouncementCreateOrConnectWithoutSchoolInput | SchoolAnnouncementCreateOrConnectWithoutSchoolInput[]
    createMany?: SchoolAnnouncementCreateManySchoolInputEnvelope
    connect?: SchoolAnnouncementWhereUniqueInput | SchoolAnnouncementWhereUniqueInput[]
  }

  export type ClassAnnouncementUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<ClassAnnouncementCreateWithoutSchoolInput, ClassAnnouncementUncheckedCreateWithoutSchoolInput> | ClassAnnouncementCreateWithoutSchoolInput[] | ClassAnnouncementUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ClassAnnouncementCreateOrConnectWithoutSchoolInput | ClassAnnouncementCreateOrConnectWithoutSchoolInput[]
    createMany?: ClassAnnouncementCreateManySchoolInputEnvelope
    connect?: ClassAnnouncementWhereUniqueInput | ClassAnnouncementWhereUniqueInput[]
  }

  export type NullableEnumTermPeriodFieldUpdateOperationsInput = {
    set?: $Enums.TermPeriod | null
  }

  export type SuperAdminUpdateOneWithoutSchoolsCreatedNestedInput = {
    create?: XOR<SuperAdminCreateWithoutSchoolsCreatedInput, SuperAdminUncheckedCreateWithoutSchoolsCreatedInput>
    connectOrCreate?: SuperAdminCreateOrConnectWithoutSchoolsCreatedInput
    upsert?: SuperAdminUpsertWithoutSchoolsCreatedInput
    disconnect?: SuperAdminWhereInput | boolean
    delete?: SuperAdminWhereInput | boolean
    connect?: SuperAdminWhereUniqueInput
    update?: XOR<XOR<SuperAdminUpdateToOneWithWhereWithoutSchoolsCreatedInput, SuperAdminUpdateWithoutSchoolsCreatedInput>, SuperAdminUncheckedUpdateWithoutSchoolsCreatedInput>
  }

  export type SchoolAdminUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<SchoolAdminCreateWithoutSchoolInput, SchoolAdminUncheckedCreateWithoutSchoolInput> | SchoolAdminCreateWithoutSchoolInput[] | SchoolAdminUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SchoolAdminCreateOrConnectWithoutSchoolInput | SchoolAdminCreateOrConnectWithoutSchoolInput[]
    upsert?: SchoolAdminUpsertWithWhereUniqueWithoutSchoolInput | SchoolAdminUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: SchoolAdminCreateManySchoolInputEnvelope
    set?: SchoolAdminWhereUniqueInput | SchoolAdminWhereUniqueInput[]
    disconnect?: SchoolAdminWhereUniqueInput | SchoolAdminWhereUniqueInput[]
    delete?: SchoolAdminWhereUniqueInput | SchoolAdminWhereUniqueInput[]
    connect?: SchoolAdminWhereUniqueInput | SchoolAdminWhereUniqueInput[]
    update?: SchoolAdminUpdateWithWhereUniqueWithoutSchoolInput | SchoolAdminUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: SchoolAdminUpdateManyWithWhereWithoutSchoolInput | SchoolAdminUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: SchoolAdminScalarWhereInput | SchoolAdminScalarWhereInput[]
  }

  export type TeacherUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<TeacherCreateWithoutSchoolInput, TeacherUncheckedCreateWithoutSchoolInput> | TeacherCreateWithoutSchoolInput[] | TeacherUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TeacherCreateOrConnectWithoutSchoolInput | TeacherCreateOrConnectWithoutSchoolInput[]
    upsert?: TeacherUpsertWithWhereUniqueWithoutSchoolInput | TeacherUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: TeacherCreateManySchoolInputEnvelope
    set?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    disconnect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    delete?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    connect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    update?: TeacherUpdateWithWhereUniqueWithoutSchoolInput | TeacherUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: TeacherUpdateManyWithWhereWithoutSchoolInput | TeacherUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: TeacherScalarWhereInput | TeacherScalarWhereInput[]
  }

  export type StudentUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<StudentCreateWithoutSchoolInput, StudentUncheckedCreateWithoutSchoolInput> | StudentCreateWithoutSchoolInput[] | StudentUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutSchoolInput | StudentCreateOrConnectWithoutSchoolInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutSchoolInput | StudentUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: StudentCreateManySchoolInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutSchoolInput | StudentUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutSchoolInput | StudentUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type ClassUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput> | ClassCreateWithoutSchoolInput[] | ClassUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSchoolInput | ClassCreateOrConnectWithoutSchoolInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutSchoolInput | ClassUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: ClassCreateManySchoolInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutSchoolInput | ClassUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutSchoolInput | ClassUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type SubjectUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<SubjectCreateWithoutSchoolInput, SubjectUncheckedCreateWithoutSchoolInput> | SubjectCreateWithoutSchoolInput[] | SubjectUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutSchoolInput | SubjectCreateOrConnectWithoutSchoolInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutSchoolInput | SubjectUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: SubjectCreateManySchoolInputEnvelope
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutSchoolInput | SubjectUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutSchoolInput | SubjectUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type FeeStructureUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<FeeStructureCreateWithoutSchoolInput, FeeStructureUncheckedCreateWithoutSchoolInput> | FeeStructureCreateWithoutSchoolInput[] | FeeStructureUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: FeeStructureCreateOrConnectWithoutSchoolInput | FeeStructureCreateOrConnectWithoutSchoolInput[]
    upsert?: FeeStructureUpsertWithWhereUniqueWithoutSchoolInput | FeeStructureUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: FeeStructureCreateManySchoolInputEnvelope
    set?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    disconnect?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    delete?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    connect?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    update?: FeeStructureUpdateWithWhereUniqueWithoutSchoolInput | FeeStructureUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: FeeStructureUpdateManyWithWhereWithoutSchoolInput | FeeStructureUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: FeeStructureScalarWhereInput | FeeStructureScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<InvoiceCreateWithoutSchoolInput, InvoiceUncheckedCreateWithoutSchoolInput> | InvoiceCreateWithoutSchoolInput[] | InvoiceUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSchoolInput | InvoiceCreateOrConnectWithoutSchoolInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutSchoolInput | InvoiceUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: InvoiceCreateManySchoolInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutSchoolInput | InvoiceUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutSchoolInput | InvoiceUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type TimetableSlotUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<TimetableSlotCreateWithoutSchoolInput, TimetableSlotUncheckedCreateWithoutSchoolInput> | TimetableSlotCreateWithoutSchoolInput[] | TimetableSlotUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TimetableSlotCreateOrConnectWithoutSchoolInput | TimetableSlotCreateOrConnectWithoutSchoolInput[]
    upsert?: TimetableSlotUpsertWithWhereUniqueWithoutSchoolInput | TimetableSlotUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: TimetableSlotCreateManySchoolInputEnvelope
    set?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
    disconnect?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
    delete?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
    connect?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
    update?: TimetableSlotUpdateWithWhereUniqueWithoutSchoolInput | TimetableSlotUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: TimetableSlotUpdateManyWithWhereWithoutSchoolInput | TimetableSlotUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: TimetableSlotScalarWhereInput | TimetableSlotScalarWhereInput[]
  }

  export type SchoolAnnouncementUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<SchoolAnnouncementCreateWithoutSchoolInput, SchoolAnnouncementUncheckedCreateWithoutSchoolInput> | SchoolAnnouncementCreateWithoutSchoolInput[] | SchoolAnnouncementUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SchoolAnnouncementCreateOrConnectWithoutSchoolInput | SchoolAnnouncementCreateOrConnectWithoutSchoolInput[]
    upsert?: SchoolAnnouncementUpsertWithWhereUniqueWithoutSchoolInput | SchoolAnnouncementUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: SchoolAnnouncementCreateManySchoolInputEnvelope
    set?: SchoolAnnouncementWhereUniqueInput | SchoolAnnouncementWhereUniqueInput[]
    disconnect?: SchoolAnnouncementWhereUniqueInput | SchoolAnnouncementWhereUniqueInput[]
    delete?: SchoolAnnouncementWhereUniqueInput | SchoolAnnouncementWhereUniqueInput[]
    connect?: SchoolAnnouncementWhereUniqueInput | SchoolAnnouncementWhereUniqueInput[]
    update?: SchoolAnnouncementUpdateWithWhereUniqueWithoutSchoolInput | SchoolAnnouncementUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: SchoolAnnouncementUpdateManyWithWhereWithoutSchoolInput | SchoolAnnouncementUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: SchoolAnnouncementScalarWhereInput | SchoolAnnouncementScalarWhereInput[]
  }

  export type ClassAnnouncementUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<ClassAnnouncementCreateWithoutSchoolInput, ClassAnnouncementUncheckedCreateWithoutSchoolInput> | ClassAnnouncementCreateWithoutSchoolInput[] | ClassAnnouncementUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ClassAnnouncementCreateOrConnectWithoutSchoolInput | ClassAnnouncementCreateOrConnectWithoutSchoolInput[]
    upsert?: ClassAnnouncementUpsertWithWhereUniqueWithoutSchoolInput | ClassAnnouncementUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: ClassAnnouncementCreateManySchoolInputEnvelope
    set?: ClassAnnouncementWhereUniqueInput | ClassAnnouncementWhereUniqueInput[]
    disconnect?: ClassAnnouncementWhereUniqueInput | ClassAnnouncementWhereUniqueInput[]
    delete?: ClassAnnouncementWhereUniqueInput | ClassAnnouncementWhereUniqueInput[]
    connect?: ClassAnnouncementWhereUniqueInput | ClassAnnouncementWhereUniqueInput[]
    update?: ClassAnnouncementUpdateWithWhereUniqueWithoutSchoolInput | ClassAnnouncementUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: ClassAnnouncementUpdateManyWithWhereWithoutSchoolInput | ClassAnnouncementUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: ClassAnnouncementScalarWhereInput | ClassAnnouncementScalarWhereInput[]
  }

  export type SchoolAdminUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<SchoolAdminCreateWithoutSchoolInput, SchoolAdminUncheckedCreateWithoutSchoolInput> | SchoolAdminCreateWithoutSchoolInput[] | SchoolAdminUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SchoolAdminCreateOrConnectWithoutSchoolInput | SchoolAdminCreateOrConnectWithoutSchoolInput[]
    upsert?: SchoolAdminUpsertWithWhereUniqueWithoutSchoolInput | SchoolAdminUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: SchoolAdminCreateManySchoolInputEnvelope
    set?: SchoolAdminWhereUniqueInput | SchoolAdminWhereUniqueInput[]
    disconnect?: SchoolAdminWhereUniqueInput | SchoolAdminWhereUniqueInput[]
    delete?: SchoolAdminWhereUniqueInput | SchoolAdminWhereUniqueInput[]
    connect?: SchoolAdminWhereUniqueInput | SchoolAdminWhereUniqueInput[]
    update?: SchoolAdminUpdateWithWhereUniqueWithoutSchoolInput | SchoolAdminUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: SchoolAdminUpdateManyWithWhereWithoutSchoolInput | SchoolAdminUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: SchoolAdminScalarWhereInput | SchoolAdminScalarWhereInput[]
  }

  export type TeacherUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<TeacherCreateWithoutSchoolInput, TeacherUncheckedCreateWithoutSchoolInput> | TeacherCreateWithoutSchoolInput[] | TeacherUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TeacherCreateOrConnectWithoutSchoolInput | TeacherCreateOrConnectWithoutSchoolInput[]
    upsert?: TeacherUpsertWithWhereUniqueWithoutSchoolInput | TeacherUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: TeacherCreateManySchoolInputEnvelope
    set?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    disconnect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    delete?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    connect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    update?: TeacherUpdateWithWhereUniqueWithoutSchoolInput | TeacherUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: TeacherUpdateManyWithWhereWithoutSchoolInput | TeacherUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: TeacherScalarWhereInput | TeacherScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<StudentCreateWithoutSchoolInput, StudentUncheckedCreateWithoutSchoolInput> | StudentCreateWithoutSchoolInput[] | StudentUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutSchoolInput | StudentCreateOrConnectWithoutSchoolInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutSchoolInput | StudentUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: StudentCreateManySchoolInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutSchoolInput | StudentUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutSchoolInput | StudentUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type ClassUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput> | ClassCreateWithoutSchoolInput[] | ClassUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSchoolInput | ClassCreateOrConnectWithoutSchoolInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutSchoolInput | ClassUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: ClassCreateManySchoolInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutSchoolInput | ClassUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutSchoolInput | ClassUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type SubjectUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<SubjectCreateWithoutSchoolInput, SubjectUncheckedCreateWithoutSchoolInput> | SubjectCreateWithoutSchoolInput[] | SubjectUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutSchoolInput | SubjectCreateOrConnectWithoutSchoolInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutSchoolInput | SubjectUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: SubjectCreateManySchoolInputEnvelope
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutSchoolInput | SubjectUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutSchoolInput | SubjectUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type FeeStructureUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<FeeStructureCreateWithoutSchoolInput, FeeStructureUncheckedCreateWithoutSchoolInput> | FeeStructureCreateWithoutSchoolInput[] | FeeStructureUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: FeeStructureCreateOrConnectWithoutSchoolInput | FeeStructureCreateOrConnectWithoutSchoolInput[]
    upsert?: FeeStructureUpsertWithWhereUniqueWithoutSchoolInput | FeeStructureUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: FeeStructureCreateManySchoolInputEnvelope
    set?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    disconnect?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    delete?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    connect?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    update?: FeeStructureUpdateWithWhereUniqueWithoutSchoolInput | FeeStructureUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: FeeStructureUpdateManyWithWhereWithoutSchoolInput | FeeStructureUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: FeeStructureScalarWhereInput | FeeStructureScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<InvoiceCreateWithoutSchoolInput, InvoiceUncheckedCreateWithoutSchoolInput> | InvoiceCreateWithoutSchoolInput[] | InvoiceUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSchoolInput | InvoiceCreateOrConnectWithoutSchoolInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutSchoolInput | InvoiceUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: InvoiceCreateManySchoolInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutSchoolInput | InvoiceUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutSchoolInput | InvoiceUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type TimetableSlotUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<TimetableSlotCreateWithoutSchoolInput, TimetableSlotUncheckedCreateWithoutSchoolInput> | TimetableSlotCreateWithoutSchoolInput[] | TimetableSlotUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TimetableSlotCreateOrConnectWithoutSchoolInput | TimetableSlotCreateOrConnectWithoutSchoolInput[]
    upsert?: TimetableSlotUpsertWithWhereUniqueWithoutSchoolInput | TimetableSlotUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: TimetableSlotCreateManySchoolInputEnvelope
    set?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
    disconnect?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
    delete?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
    connect?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
    update?: TimetableSlotUpdateWithWhereUniqueWithoutSchoolInput | TimetableSlotUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: TimetableSlotUpdateManyWithWhereWithoutSchoolInput | TimetableSlotUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: TimetableSlotScalarWhereInput | TimetableSlotScalarWhereInput[]
  }

  export type SchoolAnnouncementUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<SchoolAnnouncementCreateWithoutSchoolInput, SchoolAnnouncementUncheckedCreateWithoutSchoolInput> | SchoolAnnouncementCreateWithoutSchoolInput[] | SchoolAnnouncementUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SchoolAnnouncementCreateOrConnectWithoutSchoolInput | SchoolAnnouncementCreateOrConnectWithoutSchoolInput[]
    upsert?: SchoolAnnouncementUpsertWithWhereUniqueWithoutSchoolInput | SchoolAnnouncementUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: SchoolAnnouncementCreateManySchoolInputEnvelope
    set?: SchoolAnnouncementWhereUniqueInput | SchoolAnnouncementWhereUniqueInput[]
    disconnect?: SchoolAnnouncementWhereUniqueInput | SchoolAnnouncementWhereUniqueInput[]
    delete?: SchoolAnnouncementWhereUniqueInput | SchoolAnnouncementWhereUniqueInput[]
    connect?: SchoolAnnouncementWhereUniqueInput | SchoolAnnouncementWhereUniqueInput[]
    update?: SchoolAnnouncementUpdateWithWhereUniqueWithoutSchoolInput | SchoolAnnouncementUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: SchoolAnnouncementUpdateManyWithWhereWithoutSchoolInput | SchoolAnnouncementUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: SchoolAnnouncementScalarWhereInput | SchoolAnnouncementScalarWhereInput[]
  }

  export type ClassAnnouncementUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<ClassAnnouncementCreateWithoutSchoolInput, ClassAnnouncementUncheckedCreateWithoutSchoolInput> | ClassAnnouncementCreateWithoutSchoolInput[] | ClassAnnouncementUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ClassAnnouncementCreateOrConnectWithoutSchoolInput | ClassAnnouncementCreateOrConnectWithoutSchoolInput[]
    upsert?: ClassAnnouncementUpsertWithWhereUniqueWithoutSchoolInput | ClassAnnouncementUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: ClassAnnouncementCreateManySchoolInputEnvelope
    set?: ClassAnnouncementWhereUniqueInput | ClassAnnouncementWhereUniqueInput[]
    disconnect?: ClassAnnouncementWhereUniqueInput | ClassAnnouncementWhereUniqueInput[]
    delete?: ClassAnnouncementWhereUniqueInput | ClassAnnouncementWhereUniqueInput[]
    connect?: ClassAnnouncementWhereUniqueInput | ClassAnnouncementWhereUniqueInput[]
    update?: ClassAnnouncementUpdateWithWhereUniqueWithoutSchoolInput | ClassAnnouncementUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: ClassAnnouncementUpdateManyWithWhereWithoutSchoolInput | ClassAnnouncementUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: ClassAnnouncementScalarWhereInput | ClassAnnouncementScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSchoolAdminsInput = {
    create?: XOR<UserCreateWithoutSchoolAdminsInput, UserUncheckedCreateWithoutSchoolAdminsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSchoolAdminsInput
    connect?: UserWhereUniqueInput
  }

  export type SchoolCreateNestedOneWithoutAdminsInput = {
    create?: XOR<SchoolCreateWithoutAdminsInput, SchoolUncheckedCreateWithoutAdminsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutAdminsInput
    connect?: SchoolWhereUniqueInput
  }

  export type SchoolAnnouncementCreateNestedManyWithoutCreatedByAdminInput = {
    create?: XOR<SchoolAnnouncementCreateWithoutCreatedByAdminInput, SchoolAnnouncementUncheckedCreateWithoutCreatedByAdminInput> | SchoolAnnouncementCreateWithoutCreatedByAdminInput[] | SchoolAnnouncementUncheckedCreateWithoutCreatedByAdminInput[]
    connectOrCreate?: SchoolAnnouncementCreateOrConnectWithoutCreatedByAdminInput | SchoolAnnouncementCreateOrConnectWithoutCreatedByAdminInput[]
    createMany?: SchoolAnnouncementCreateManyCreatedByAdminInputEnvelope
    connect?: SchoolAnnouncementWhereUniqueInput | SchoolAnnouncementWhereUniqueInput[]
  }

  export type SchoolAnnouncementUncheckedCreateNestedManyWithoutCreatedByAdminInput = {
    create?: XOR<SchoolAnnouncementCreateWithoutCreatedByAdminInput, SchoolAnnouncementUncheckedCreateWithoutCreatedByAdminInput> | SchoolAnnouncementCreateWithoutCreatedByAdminInput[] | SchoolAnnouncementUncheckedCreateWithoutCreatedByAdminInput[]
    connectOrCreate?: SchoolAnnouncementCreateOrConnectWithoutCreatedByAdminInput | SchoolAnnouncementCreateOrConnectWithoutCreatedByAdminInput[]
    createMany?: SchoolAnnouncementCreateManyCreatedByAdminInputEnvelope
    connect?: SchoolAnnouncementWhereUniqueInput | SchoolAnnouncementWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutSchoolAdminsNestedInput = {
    create?: XOR<UserCreateWithoutSchoolAdminsInput, UserUncheckedCreateWithoutSchoolAdminsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSchoolAdminsInput
    upsert?: UserUpsertWithoutSchoolAdminsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSchoolAdminsInput, UserUpdateWithoutSchoolAdminsInput>, UserUncheckedUpdateWithoutSchoolAdminsInput>
  }

  export type SchoolUpdateOneRequiredWithoutAdminsNestedInput = {
    create?: XOR<SchoolCreateWithoutAdminsInput, SchoolUncheckedCreateWithoutAdminsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutAdminsInput
    upsert?: SchoolUpsertWithoutAdminsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutAdminsInput, SchoolUpdateWithoutAdminsInput>, SchoolUncheckedUpdateWithoutAdminsInput>
  }

  export type SchoolAnnouncementUpdateManyWithoutCreatedByAdminNestedInput = {
    create?: XOR<SchoolAnnouncementCreateWithoutCreatedByAdminInput, SchoolAnnouncementUncheckedCreateWithoutCreatedByAdminInput> | SchoolAnnouncementCreateWithoutCreatedByAdminInput[] | SchoolAnnouncementUncheckedCreateWithoutCreatedByAdminInput[]
    connectOrCreate?: SchoolAnnouncementCreateOrConnectWithoutCreatedByAdminInput | SchoolAnnouncementCreateOrConnectWithoutCreatedByAdminInput[]
    upsert?: SchoolAnnouncementUpsertWithWhereUniqueWithoutCreatedByAdminInput | SchoolAnnouncementUpsertWithWhereUniqueWithoutCreatedByAdminInput[]
    createMany?: SchoolAnnouncementCreateManyCreatedByAdminInputEnvelope
    set?: SchoolAnnouncementWhereUniqueInput | SchoolAnnouncementWhereUniqueInput[]
    disconnect?: SchoolAnnouncementWhereUniqueInput | SchoolAnnouncementWhereUniqueInput[]
    delete?: SchoolAnnouncementWhereUniqueInput | SchoolAnnouncementWhereUniqueInput[]
    connect?: SchoolAnnouncementWhereUniqueInput | SchoolAnnouncementWhereUniqueInput[]
    update?: SchoolAnnouncementUpdateWithWhereUniqueWithoutCreatedByAdminInput | SchoolAnnouncementUpdateWithWhereUniqueWithoutCreatedByAdminInput[]
    updateMany?: SchoolAnnouncementUpdateManyWithWhereWithoutCreatedByAdminInput | SchoolAnnouncementUpdateManyWithWhereWithoutCreatedByAdminInput[]
    deleteMany?: SchoolAnnouncementScalarWhereInput | SchoolAnnouncementScalarWhereInput[]
  }

  export type SchoolAnnouncementUncheckedUpdateManyWithoutCreatedByAdminNestedInput = {
    create?: XOR<SchoolAnnouncementCreateWithoutCreatedByAdminInput, SchoolAnnouncementUncheckedCreateWithoutCreatedByAdminInput> | SchoolAnnouncementCreateWithoutCreatedByAdminInput[] | SchoolAnnouncementUncheckedCreateWithoutCreatedByAdminInput[]
    connectOrCreate?: SchoolAnnouncementCreateOrConnectWithoutCreatedByAdminInput | SchoolAnnouncementCreateOrConnectWithoutCreatedByAdminInput[]
    upsert?: SchoolAnnouncementUpsertWithWhereUniqueWithoutCreatedByAdminInput | SchoolAnnouncementUpsertWithWhereUniqueWithoutCreatedByAdminInput[]
    createMany?: SchoolAnnouncementCreateManyCreatedByAdminInputEnvelope
    set?: SchoolAnnouncementWhereUniqueInput | SchoolAnnouncementWhereUniqueInput[]
    disconnect?: SchoolAnnouncementWhereUniqueInput | SchoolAnnouncementWhereUniqueInput[]
    delete?: SchoolAnnouncementWhereUniqueInput | SchoolAnnouncementWhereUniqueInput[]
    connect?: SchoolAnnouncementWhereUniqueInput | SchoolAnnouncementWhereUniqueInput[]
    update?: SchoolAnnouncementUpdateWithWhereUniqueWithoutCreatedByAdminInput | SchoolAnnouncementUpdateWithWhereUniqueWithoutCreatedByAdminInput[]
    updateMany?: SchoolAnnouncementUpdateManyWithWhereWithoutCreatedByAdminInput | SchoolAnnouncementUpdateManyWithWhereWithoutCreatedByAdminInput[]
    deleteMany?: SchoolAnnouncementScalarWhereInput | SchoolAnnouncementScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTeacherLinksInput = {
    create?: XOR<UserCreateWithoutTeacherLinksInput, UserUncheckedCreateWithoutTeacherLinksInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeacherLinksInput
    connect?: UserWhereUniqueInput
  }

  export type SchoolCreateNestedOneWithoutTeachersInput = {
    create?: XOR<SchoolCreateWithoutTeachersInput, SchoolUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutTeachersInput
    connect?: SchoolWhereUniqueInput
  }

  export type ClassCreateNestedManyWithoutHomeroomTeacherInput = {
    create?: XOR<ClassCreateWithoutHomeroomTeacherInput, ClassUncheckedCreateWithoutHomeroomTeacherInput> | ClassCreateWithoutHomeroomTeacherInput[] | ClassUncheckedCreateWithoutHomeroomTeacherInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutHomeroomTeacherInput | ClassCreateOrConnectWithoutHomeroomTeacherInput[]
    createMany?: ClassCreateManyHomeroomTeacherInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type TimetableSlotCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TimetableSlotCreateWithoutTeacherInput, TimetableSlotUncheckedCreateWithoutTeacherInput> | TimetableSlotCreateWithoutTeacherInput[] | TimetableSlotUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TimetableSlotCreateOrConnectWithoutTeacherInput | TimetableSlotCreateOrConnectWithoutTeacherInput[]
    createMany?: TimetableSlotCreateManyTeacherInputEnvelope
    connect?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
  }

  export type StudentGradeCreateNestedManyWithoutTeacherInput = {
    create?: XOR<StudentGradeCreateWithoutTeacherInput, StudentGradeUncheckedCreateWithoutTeacherInput> | StudentGradeCreateWithoutTeacherInput[] | StudentGradeUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: StudentGradeCreateOrConnectWithoutTeacherInput | StudentGradeCreateOrConnectWithoutTeacherInput[]
    createMany?: StudentGradeCreateManyTeacherInputEnvelope
    connect?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
  }

  export type AssignmentCreateNestedManyWithoutTeacherInput = {
    create?: XOR<AssignmentCreateWithoutTeacherInput, AssignmentUncheckedCreateWithoutTeacherInput> | AssignmentCreateWithoutTeacherInput[] | AssignmentUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutTeacherInput | AssignmentCreateOrConnectWithoutTeacherInput[]
    createMany?: AssignmentCreateManyTeacherInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type ClassAnnouncementCreateNestedManyWithoutCreatedByTeacherInput = {
    create?: XOR<ClassAnnouncementCreateWithoutCreatedByTeacherInput, ClassAnnouncementUncheckedCreateWithoutCreatedByTeacherInput> | ClassAnnouncementCreateWithoutCreatedByTeacherInput[] | ClassAnnouncementUncheckedCreateWithoutCreatedByTeacherInput[]
    connectOrCreate?: ClassAnnouncementCreateOrConnectWithoutCreatedByTeacherInput | ClassAnnouncementCreateOrConnectWithoutCreatedByTeacherInput[]
    createMany?: ClassAnnouncementCreateManyCreatedByTeacherInputEnvelope
    connect?: ClassAnnouncementWhereUniqueInput | ClassAnnouncementWhereUniqueInput[]
  }

  export type ClassUncheckedCreateNestedManyWithoutHomeroomTeacherInput = {
    create?: XOR<ClassCreateWithoutHomeroomTeacherInput, ClassUncheckedCreateWithoutHomeroomTeacherInput> | ClassCreateWithoutHomeroomTeacherInput[] | ClassUncheckedCreateWithoutHomeroomTeacherInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutHomeroomTeacherInput | ClassCreateOrConnectWithoutHomeroomTeacherInput[]
    createMany?: ClassCreateManyHomeroomTeacherInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type TimetableSlotUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TimetableSlotCreateWithoutTeacherInput, TimetableSlotUncheckedCreateWithoutTeacherInput> | TimetableSlotCreateWithoutTeacherInput[] | TimetableSlotUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TimetableSlotCreateOrConnectWithoutTeacherInput | TimetableSlotCreateOrConnectWithoutTeacherInput[]
    createMany?: TimetableSlotCreateManyTeacherInputEnvelope
    connect?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
  }

  export type StudentGradeUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<StudentGradeCreateWithoutTeacherInput, StudentGradeUncheckedCreateWithoutTeacherInput> | StudentGradeCreateWithoutTeacherInput[] | StudentGradeUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: StudentGradeCreateOrConnectWithoutTeacherInput | StudentGradeCreateOrConnectWithoutTeacherInput[]
    createMany?: StudentGradeCreateManyTeacherInputEnvelope
    connect?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
  }

  export type AssignmentUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<AssignmentCreateWithoutTeacherInput, AssignmentUncheckedCreateWithoutTeacherInput> | AssignmentCreateWithoutTeacherInput[] | AssignmentUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutTeacherInput | AssignmentCreateOrConnectWithoutTeacherInput[]
    createMany?: AssignmentCreateManyTeacherInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type ClassAnnouncementUncheckedCreateNestedManyWithoutCreatedByTeacherInput = {
    create?: XOR<ClassAnnouncementCreateWithoutCreatedByTeacherInput, ClassAnnouncementUncheckedCreateWithoutCreatedByTeacherInput> | ClassAnnouncementCreateWithoutCreatedByTeacherInput[] | ClassAnnouncementUncheckedCreateWithoutCreatedByTeacherInput[]
    connectOrCreate?: ClassAnnouncementCreateOrConnectWithoutCreatedByTeacherInput | ClassAnnouncementCreateOrConnectWithoutCreatedByTeacherInput[]
    createMany?: ClassAnnouncementCreateManyCreatedByTeacherInputEnvelope
    connect?: ClassAnnouncementWhereUniqueInput | ClassAnnouncementWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutTeacherLinksNestedInput = {
    create?: XOR<UserCreateWithoutTeacherLinksInput, UserUncheckedCreateWithoutTeacherLinksInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeacherLinksInput
    upsert?: UserUpsertWithoutTeacherLinksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeacherLinksInput, UserUpdateWithoutTeacherLinksInput>, UserUncheckedUpdateWithoutTeacherLinksInput>
  }

  export type SchoolUpdateOneRequiredWithoutTeachersNestedInput = {
    create?: XOR<SchoolCreateWithoutTeachersInput, SchoolUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutTeachersInput
    upsert?: SchoolUpsertWithoutTeachersInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutTeachersInput, SchoolUpdateWithoutTeachersInput>, SchoolUncheckedUpdateWithoutTeachersInput>
  }

  export type ClassUpdateManyWithoutHomeroomTeacherNestedInput = {
    create?: XOR<ClassCreateWithoutHomeroomTeacherInput, ClassUncheckedCreateWithoutHomeroomTeacherInput> | ClassCreateWithoutHomeroomTeacherInput[] | ClassUncheckedCreateWithoutHomeroomTeacherInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutHomeroomTeacherInput | ClassCreateOrConnectWithoutHomeroomTeacherInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutHomeroomTeacherInput | ClassUpsertWithWhereUniqueWithoutHomeroomTeacherInput[]
    createMany?: ClassCreateManyHomeroomTeacherInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutHomeroomTeacherInput | ClassUpdateWithWhereUniqueWithoutHomeroomTeacherInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutHomeroomTeacherInput | ClassUpdateManyWithWhereWithoutHomeroomTeacherInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type TimetableSlotUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TimetableSlotCreateWithoutTeacherInput, TimetableSlotUncheckedCreateWithoutTeacherInput> | TimetableSlotCreateWithoutTeacherInput[] | TimetableSlotUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TimetableSlotCreateOrConnectWithoutTeacherInput | TimetableSlotCreateOrConnectWithoutTeacherInput[]
    upsert?: TimetableSlotUpsertWithWhereUniqueWithoutTeacherInput | TimetableSlotUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TimetableSlotCreateManyTeacherInputEnvelope
    set?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
    disconnect?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
    delete?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
    connect?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
    update?: TimetableSlotUpdateWithWhereUniqueWithoutTeacherInput | TimetableSlotUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TimetableSlotUpdateManyWithWhereWithoutTeacherInput | TimetableSlotUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TimetableSlotScalarWhereInput | TimetableSlotScalarWhereInput[]
  }

  export type StudentGradeUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<StudentGradeCreateWithoutTeacherInput, StudentGradeUncheckedCreateWithoutTeacherInput> | StudentGradeCreateWithoutTeacherInput[] | StudentGradeUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: StudentGradeCreateOrConnectWithoutTeacherInput | StudentGradeCreateOrConnectWithoutTeacherInput[]
    upsert?: StudentGradeUpsertWithWhereUniqueWithoutTeacherInput | StudentGradeUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: StudentGradeCreateManyTeacherInputEnvelope
    set?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
    disconnect?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
    delete?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
    connect?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
    update?: StudentGradeUpdateWithWhereUniqueWithoutTeacherInput | StudentGradeUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: StudentGradeUpdateManyWithWhereWithoutTeacherInput | StudentGradeUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: StudentGradeScalarWhereInput | StudentGradeScalarWhereInput[]
  }

  export type AssignmentUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<AssignmentCreateWithoutTeacherInput, AssignmentUncheckedCreateWithoutTeacherInput> | AssignmentCreateWithoutTeacherInput[] | AssignmentUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutTeacherInput | AssignmentCreateOrConnectWithoutTeacherInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutTeacherInput | AssignmentUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: AssignmentCreateManyTeacherInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutTeacherInput | AssignmentUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutTeacherInput | AssignmentUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type ClassAnnouncementUpdateManyWithoutCreatedByTeacherNestedInput = {
    create?: XOR<ClassAnnouncementCreateWithoutCreatedByTeacherInput, ClassAnnouncementUncheckedCreateWithoutCreatedByTeacherInput> | ClassAnnouncementCreateWithoutCreatedByTeacherInput[] | ClassAnnouncementUncheckedCreateWithoutCreatedByTeacherInput[]
    connectOrCreate?: ClassAnnouncementCreateOrConnectWithoutCreatedByTeacherInput | ClassAnnouncementCreateOrConnectWithoutCreatedByTeacherInput[]
    upsert?: ClassAnnouncementUpsertWithWhereUniqueWithoutCreatedByTeacherInput | ClassAnnouncementUpsertWithWhereUniqueWithoutCreatedByTeacherInput[]
    createMany?: ClassAnnouncementCreateManyCreatedByTeacherInputEnvelope
    set?: ClassAnnouncementWhereUniqueInput | ClassAnnouncementWhereUniqueInput[]
    disconnect?: ClassAnnouncementWhereUniqueInput | ClassAnnouncementWhereUniqueInput[]
    delete?: ClassAnnouncementWhereUniqueInput | ClassAnnouncementWhereUniqueInput[]
    connect?: ClassAnnouncementWhereUniqueInput | ClassAnnouncementWhereUniqueInput[]
    update?: ClassAnnouncementUpdateWithWhereUniqueWithoutCreatedByTeacherInput | ClassAnnouncementUpdateWithWhereUniqueWithoutCreatedByTeacherInput[]
    updateMany?: ClassAnnouncementUpdateManyWithWhereWithoutCreatedByTeacherInput | ClassAnnouncementUpdateManyWithWhereWithoutCreatedByTeacherInput[]
    deleteMany?: ClassAnnouncementScalarWhereInput | ClassAnnouncementScalarWhereInput[]
  }

  export type ClassUncheckedUpdateManyWithoutHomeroomTeacherNestedInput = {
    create?: XOR<ClassCreateWithoutHomeroomTeacherInput, ClassUncheckedCreateWithoutHomeroomTeacherInput> | ClassCreateWithoutHomeroomTeacherInput[] | ClassUncheckedCreateWithoutHomeroomTeacherInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutHomeroomTeacherInput | ClassCreateOrConnectWithoutHomeroomTeacherInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutHomeroomTeacherInput | ClassUpsertWithWhereUniqueWithoutHomeroomTeacherInput[]
    createMany?: ClassCreateManyHomeroomTeacherInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutHomeroomTeacherInput | ClassUpdateWithWhereUniqueWithoutHomeroomTeacherInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutHomeroomTeacherInput | ClassUpdateManyWithWhereWithoutHomeroomTeacherInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type TimetableSlotUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TimetableSlotCreateWithoutTeacherInput, TimetableSlotUncheckedCreateWithoutTeacherInput> | TimetableSlotCreateWithoutTeacherInput[] | TimetableSlotUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TimetableSlotCreateOrConnectWithoutTeacherInput | TimetableSlotCreateOrConnectWithoutTeacherInput[]
    upsert?: TimetableSlotUpsertWithWhereUniqueWithoutTeacherInput | TimetableSlotUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TimetableSlotCreateManyTeacherInputEnvelope
    set?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
    disconnect?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
    delete?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
    connect?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
    update?: TimetableSlotUpdateWithWhereUniqueWithoutTeacherInput | TimetableSlotUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TimetableSlotUpdateManyWithWhereWithoutTeacherInput | TimetableSlotUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TimetableSlotScalarWhereInput | TimetableSlotScalarWhereInput[]
  }

  export type StudentGradeUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<StudentGradeCreateWithoutTeacherInput, StudentGradeUncheckedCreateWithoutTeacherInput> | StudentGradeCreateWithoutTeacherInput[] | StudentGradeUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: StudentGradeCreateOrConnectWithoutTeacherInput | StudentGradeCreateOrConnectWithoutTeacherInput[]
    upsert?: StudentGradeUpsertWithWhereUniqueWithoutTeacherInput | StudentGradeUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: StudentGradeCreateManyTeacherInputEnvelope
    set?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
    disconnect?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
    delete?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
    connect?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
    update?: StudentGradeUpdateWithWhereUniqueWithoutTeacherInput | StudentGradeUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: StudentGradeUpdateManyWithWhereWithoutTeacherInput | StudentGradeUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: StudentGradeScalarWhereInput | StudentGradeScalarWhereInput[]
  }

  export type AssignmentUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<AssignmentCreateWithoutTeacherInput, AssignmentUncheckedCreateWithoutTeacherInput> | AssignmentCreateWithoutTeacherInput[] | AssignmentUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutTeacherInput | AssignmentCreateOrConnectWithoutTeacherInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutTeacherInput | AssignmentUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: AssignmentCreateManyTeacherInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutTeacherInput | AssignmentUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutTeacherInput | AssignmentUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type ClassAnnouncementUncheckedUpdateManyWithoutCreatedByTeacherNestedInput = {
    create?: XOR<ClassAnnouncementCreateWithoutCreatedByTeacherInput, ClassAnnouncementUncheckedCreateWithoutCreatedByTeacherInput> | ClassAnnouncementCreateWithoutCreatedByTeacherInput[] | ClassAnnouncementUncheckedCreateWithoutCreatedByTeacherInput[]
    connectOrCreate?: ClassAnnouncementCreateOrConnectWithoutCreatedByTeacherInput | ClassAnnouncementCreateOrConnectWithoutCreatedByTeacherInput[]
    upsert?: ClassAnnouncementUpsertWithWhereUniqueWithoutCreatedByTeacherInput | ClassAnnouncementUpsertWithWhereUniqueWithoutCreatedByTeacherInput[]
    createMany?: ClassAnnouncementCreateManyCreatedByTeacherInputEnvelope
    set?: ClassAnnouncementWhereUniqueInput | ClassAnnouncementWhereUniqueInput[]
    disconnect?: ClassAnnouncementWhereUniqueInput | ClassAnnouncementWhereUniqueInput[]
    delete?: ClassAnnouncementWhereUniqueInput | ClassAnnouncementWhereUniqueInput[]
    connect?: ClassAnnouncementWhereUniqueInput | ClassAnnouncementWhereUniqueInput[]
    update?: ClassAnnouncementUpdateWithWhereUniqueWithoutCreatedByTeacherInput | ClassAnnouncementUpdateWithWhereUniqueWithoutCreatedByTeacherInput[]
    updateMany?: ClassAnnouncementUpdateManyWithWhereWithoutCreatedByTeacherInput | ClassAnnouncementUpdateManyWithWhereWithoutCreatedByTeacherInput[]
    deleteMany?: ClassAnnouncementScalarWhereInput | ClassAnnouncementScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutStudentLinkInput = {
    create?: XOR<UserCreateWithoutStudentLinkInput, UserUncheckedCreateWithoutStudentLinkInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentLinkInput
    connect?: UserWhereUniqueInput
  }

  export type SchoolCreateNestedOneWithoutStudentsInput = {
    create?: XOR<SchoolCreateWithoutStudentsInput, SchoolUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutStudentsInput
    connect?: SchoolWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutCurrentStudentsInput = {
    create?: XOR<ClassCreateWithoutCurrentStudentsInput, ClassUncheckedCreateWithoutCurrentStudentsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutCurrentStudentsInput
    connect?: ClassWhereUniqueInput
  }

  export type StudentParentLinkCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentParentLinkCreateWithoutStudentInput, StudentParentLinkUncheckedCreateWithoutStudentInput> | StudentParentLinkCreateWithoutStudentInput[] | StudentParentLinkUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentParentLinkCreateOrConnectWithoutStudentInput | StudentParentLinkCreateOrConnectWithoutStudentInput[]
    createMany?: StudentParentLinkCreateManyStudentInputEnvelope
    connect?: StudentParentLinkWhereUniqueInput | StudentParentLinkWhereUniqueInput[]
  }

  export type StudentClassEnrollmentCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentClassEnrollmentCreateWithoutStudentInput, StudentClassEnrollmentUncheckedCreateWithoutStudentInput> | StudentClassEnrollmentCreateWithoutStudentInput[] | StudentClassEnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentClassEnrollmentCreateOrConnectWithoutStudentInput | StudentClassEnrollmentCreateOrConnectWithoutStudentInput[]
    createMany?: StudentClassEnrollmentCreateManyStudentInputEnvelope
    connect?: StudentClassEnrollmentWhereUniqueInput | StudentClassEnrollmentWhereUniqueInput[]
  }

  export type StudentAttendanceCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentAttendanceCreateWithoutStudentInput, StudentAttendanceUncheckedCreateWithoutStudentInput> | StudentAttendanceCreateWithoutStudentInput[] | StudentAttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutStudentInput | StudentAttendanceCreateOrConnectWithoutStudentInput[]
    createMany?: StudentAttendanceCreateManyStudentInputEnvelope
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
  }

  export type StudentGradeCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentGradeCreateWithoutStudentInput, StudentGradeUncheckedCreateWithoutStudentInput> | StudentGradeCreateWithoutStudentInput[] | StudentGradeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentGradeCreateOrConnectWithoutStudentInput | StudentGradeCreateOrConnectWithoutStudentInput[]
    createMany?: StudentGradeCreateManyStudentInputEnvelope
    connect?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
  }

  export type InvoiceLineItemCreateNestedManyWithoutStudentInput = {
    create?: XOR<InvoiceLineItemCreateWithoutStudentInput, InvoiceLineItemUncheckedCreateWithoutStudentInput> | InvoiceLineItemCreateWithoutStudentInput[] | InvoiceLineItemUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: InvoiceLineItemCreateOrConnectWithoutStudentInput | InvoiceLineItemCreateOrConnectWithoutStudentInput[]
    createMany?: InvoiceLineItemCreateManyStudentInputEnvelope
    connect?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutStudentInput = {
    create?: XOR<InvoiceCreateWithoutStudentInput, InvoiceUncheckedCreateWithoutStudentInput> | InvoiceCreateWithoutStudentInput[] | InvoiceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutStudentInput | InvoiceCreateOrConnectWithoutStudentInput[]
    createMany?: InvoiceCreateManyStudentInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type StudentParentLinkUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentParentLinkCreateWithoutStudentInput, StudentParentLinkUncheckedCreateWithoutStudentInput> | StudentParentLinkCreateWithoutStudentInput[] | StudentParentLinkUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentParentLinkCreateOrConnectWithoutStudentInput | StudentParentLinkCreateOrConnectWithoutStudentInput[]
    createMany?: StudentParentLinkCreateManyStudentInputEnvelope
    connect?: StudentParentLinkWhereUniqueInput | StudentParentLinkWhereUniqueInput[]
  }

  export type StudentClassEnrollmentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentClassEnrollmentCreateWithoutStudentInput, StudentClassEnrollmentUncheckedCreateWithoutStudentInput> | StudentClassEnrollmentCreateWithoutStudentInput[] | StudentClassEnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentClassEnrollmentCreateOrConnectWithoutStudentInput | StudentClassEnrollmentCreateOrConnectWithoutStudentInput[]
    createMany?: StudentClassEnrollmentCreateManyStudentInputEnvelope
    connect?: StudentClassEnrollmentWhereUniqueInput | StudentClassEnrollmentWhereUniqueInput[]
  }

  export type StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentAttendanceCreateWithoutStudentInput, StudentAttendanceUncheckedCreateWithoutStudentInput> | StudentAttendanceCreateWithoutStudentInput[] | StudentAttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutStudentInput | StudentAttendanceCreateOrConnectWithoutStudentInput[]
    createMany?: StudentAttendanceCreateManyStudentInputEnvelope
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
  }

  export type StudentGradeUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentGradeCreateWithoutStudentInput, StudentGradeUncheckedCreateWithoutStudentInput> | StudentGradeCreateWithoutStudentInput[] | StudentGradeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentGradeCreateOrConnectWithoutStudentInput | StudentGradeCreateOrConnectWithoutStudentInput[]
    createMany?: StudentGradeCreateManyStudentInputEnvelope
    connect?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
  }

  export type InvoiceLineItemUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<InvoiceLineItemCreateWithoutStudentInput, InvoiceLineItemUncheckedCreateWithoutStudentInput> | InvoiceLineItemCreateWithoutStudentInput[] | InvoiceLineItemUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: InvoiceLineItemCreateOrConnectWithoutStudentInput | InvoiceLineItemCreateOrConnectWithoutStudentInput[]
    createMany?: InvoiceLineItemCreateManyStudentInputEnvelope
    connect?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<InvoiceCreateWithoutStudentInput, InvoiceUncheckedCreateWithoutStudentInput> | InvoiceCreateWithoutStudentInput[] | InvoiceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutStudentInput | InvoiceCreateOrConnectWithoutStudentInput[]
    createMany?: InvoiceCreateManyStudentInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type EnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender
  }

  export type UserUpdateOneWithoutStudentLinkNestedInput = {
    create?: XOR<UserCreateWithoutStudentLinkInput, UserUncheckedCreateWithoutStudentLinkInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentLinkInput
    upsert?: UserUpsertWithoutStudentLinkInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStudentLinkInput, UserUpdateWithoutStudentLinkInput>, UserUncheckedUpdateWithoutStudentLinkInput>
  }

  export type SchoolUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<SchoolCreateWithoutStudentsInput, SchoolUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutStudentsInput
    upsert?: SchoolUpsertWithoutStudentsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutStudentsInput, SchoolUpdateWithoutStudentsInput>, SchoolUncheckedUpdateWithoutStudentsInput>
  }

  export type ClassUpdateOneWithoutCurrentStudentsNestedInput = {
    create?: XOR<ClassCreateWithoutCurrentStudentsInput, ClassUncheckedCreateWithoutCurrentStudentsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutCurrentStudentsInput
    upsert?: ClassUpsertWithoutCurrentStudentsInput
    disconnect?: ClassWhereInput | boolean
    delete?: ClassWhereInput | boolean
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutCurrentStudentsInput, ClassUpdateWithoutCurrentStudentsInput>, ClassUncheckedUpdateWithoutCurrentStudentsInput>
  }

  export type StudentParentLinkUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentParentLinkCreateWithoutStudentInput, StudentParentLinkUncheckedCreateWithoutStudentInput> | StudentParentLinkCreateWithoutStudentInput[] | StudentParentLinkUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentParentLinkCreateOrConnectWithoutStudentInput | StudentParentLinkCreateOrConnectWithoutStudentInput[]
    upsert?: StudentParentLinkUpsertWithWhereUniqueWithoutStudentInput | StudentParentLinkUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentParentLinkCreateManyStudentInputEnvelope
    set?: StudentParentLinkWhereUniqueInput | StudentParentLinkWhereUniqueInput[]
    disconnect?: StudentParentLinkWhereUniqueInput | StudentParentLinkWhereUniqueInput[]
    delete?: StudentParentLinkWhereUniqueInput | StudentParentLinkWhereUniqueInput[]
    connect?: StudentParentLinkWhereUniqueInput | StudentParentLinkWhereUniqueInput[]
    update?: StudentParentLinkUpdateWithWhereUniqueWithoutStudentInput | StudentParentLinkUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentParentLinkUpdateManyWithWhereWithoutStudentInput | StudentParentLinkUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentParentLinkScalarWhereInput | StudentParentLinkScalarWhereInput[]
  }

  export type StudentClassEnrollmentUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentClassEnrollmentCreateWithoutStudentInput, StudentClassEnrollmentUncheckedCreateWithoutStudentInput> | StudentClassEnrollmentCreateWithoutStudentInput[] | StudentClassEnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentClassEnrollmentCreateOrConnectWithoutStudentInput | StudentClassEnrollmentCreateOrConnectWithoutStudentInput[]
    upsert?: StudentClassEnrollmentUpsertWithWhereUniqueWithoutStudentInput | StudentClassEnrollmentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentClassEnrollmentCreateManyStudentInputEnvelope
    set?: StudentClassEnrollmentWhereUniqueInput | StudentClassEnrollmentWhereUniqueInput[]
    disconnect?: StudentClassEnrollmentWhereUniqueInput | StudentClassEnrollmentWhereUniqueInput[]
    delete?: StudentClassEnrollmentWhereUniqueInput | StudentClassEnrollmentWhereUniqueInput[]
    connect?: StudentClassEnrollmentWhereUniqueInput | StudentClassEnrollmentWhereUniqueInput[]
    update?: StudentClassEnrollmentUpdateWithWhereUniqueWithoutStudentInput | StudentClassEnrollmentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentClassEnrollmentUpdateManyWithWhereWithoutStudentInput | StudentClassEnrollmentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentClassEnrollmentScalarWhereInput | StudentClassEnrollmentScalarWhereInput[]
  }

  export type StudentAttendanceUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentAttendanceCreateWithoutStudentInput, StudentAttendanceUncheckedCreateWithoutStudentInput> | StudentAttendanceCreateWithoutStudentInput[] | StudentAttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutStudentInput | StudentAttendanceCreateOrConnectWithoutStudentInput[]
    upsert?: StudentAttendanceUpsertWithWhereUniqueWithoutStudentInput | StudentAttendanceUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentAttendanceCreateManyStudentInputEnvelope
    set?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    disconnect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    delete?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    update?: StudentAttendanceUpdateWithWhereUniqueWithoutStudentInput | StudentAttendanceUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentAttendanceUpdateManyWithWhereWithoutStudentInput | StudentAttendanceUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentAttendanceScalarWhereInput | StudentAttendanceScalarWhereInput[]
  }

  export type StudentGradeUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentGradeCreateWithoutStudentInput, StudentGradeUncheckedCreateWithoutStudentInput> | StudentGradeCreateWithoutStudentInput[] | StudentGradeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentGradeCreateOrConnectWithoutStudentInput | StudentGradeCreateOrConnectWithoutStudentInput[]
    upsert?: StudentGradeUpsertWithWhereUniqueWithoutStudentInput | StudentGradeUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentGradeCreateManyStudentInputEnvelope
    set?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
    disconnect?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
    delete?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
    connect?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
    update?: StudentGradeUpdateWithWhereUniqueWithoutStudentInput | StudentGradeUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentGradeUpdateManyWithWhereWithoutStudentInput | StudentGradeUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentGradeScalarWhereInput | StudentGradeScalarWhereInput[]
  }

  export type InvoiceLineItemUpdateManyWithoutStudentNestedInput = {
    create?: XOR<InvoiceLineItemCreateWithoutStudentInput, InvoiceLineItemUncheckedCreateWithoutStudentInput> | InvoiceLineItemCreateWithoutStudentInput[] | InvoiceLineItemUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: InvoiceLineItemCreateOrConnectWithoutStudentInput | InvoiceLineItemCreateOrConnectWithoutStudentInput[]
    upsert?: InvoiceLineItemUpsertWithWhereUniqueWithoutStudentInput | InvoiceLineItemUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: InvoiceLineItemCreateManyStudentInputEnvelope
    set?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
    disconnect?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
    delete?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
    connect?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
    update?: InvoiceLineItemUpdateWithWhereUniqueWithoutStudentInput | InvoiceLineItemUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: InvoiceLineItemUpdateManyWithWhereWithoutStudentInput | InvoiceLineItemUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: InvoiceLineItemScalarWhereInput | InvoiceLineItemScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutStudentNestedInput = {
    create?: XOR<InvoiceCreateWithoutStudentInput, InvoiceUncheckedCreateWithoutStudentInput> | InvoiceCreateWithoutStudentInput[] | InvoiceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutStudentInput | InvoiceCreateOrConnectWithoutStudentInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutStudentInput | InvoiceUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: InvoiceCreateManyStudentInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutStudentInput | InvoiceUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutStudentInput | InvoiceUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type StudentParentLinkUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentParentLinkCreateWithoutStudentInput, StudentParentLinkUncheckedCreateWithoutStudentInput> | StudentParentLinkCreateWithoutStudentInput[] | StudentParentLinkUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentParentLinkCreateOrConnectWithoutStudentInput | StudentParentLinkCreateOrConnectWithoutStudentInput[]
    upsert?: StudentParentLinkUpsertWithWhereUniqueWithoutStudentInput | StudentParentLinkUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentParentLinkCreateManyStudentInputEnvelope
    set?: StudentParentLinkWhereUniqueInput | StudentParentLinkWhereUniqueInput[]
    disconnect?: StudentParentLinkWhereUniqueInput | StudentParentLinkWhereUniqueInput[]
    delete?: StudentParentLinkWhereUniqueInput | StudentParentLinkWhereUniqueInput[]
    connect?: StudentParentLinkWhereUniqueInput | StudentParentLinkWhereUniqueInput[]
    update?: StudentParentLinkUpdateWithWhereUniqueWithoutStudentInput | StudentParentLinkUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentParentLinkUpdateManyWithWhereWithoutStudentInput | StudentParentLinkUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentParentLinkScalarWhereInput | StudentParentLinkScalarWhereInput[]
  }

  export type StudentClassEnrollmentUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentClassEnrollmentCreateWithoutStudentInput, StudentClassEnrollmentUncheckedCreateWithoutStudentInput> | StudentClassEnrollmentCreateWithoutStudentInput[] | StudentClassEnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentClassEnrollmentCreateOrConnectWithoutStudentInput | StudentClassEnrollmentCreateOrConnectWithoutStudentInput[]
    upsert?: StudentClassEnrollmentUpsertWithWhereUniqueWithoutStudentInput | StudentClassEnrollmentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentClassEnrollmentCreateManyStudentInputEnvelope
    set?: StudentClassEnrollmentWhereUniqueInput | StudentClassEnrollmentWhereUniqueInput[]
    disconnect?: StudentClassEnrollmentWhereUniqueInput | StudentClassEnrollmentWhereUniqueInput[]
    delete?: StudentClassEnrollmentWhereUniqueInput | StudentClassEnrollmentWhereUniqueInput[]
    connect?: StudentClassEnrollmentWhereUniqueInput | StudentClassEnrollmentWhereUniqueInput[]
    update?: StudentClassEnrollmentUpdateWithWhereUniqueWithoutStudentInput | StudentClassEnrollmentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentClassEnrollmentUpdateManyWithWhereWithoutStudentInput | StudentClassEnrollmentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentClassEnrollmentScalarWhereInput | StudentClassEnrollmentScalarWhereInput[]
  }

  export type StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentAttendanceCreateWithoutStudentInput, StudentAttendanceUncheckedCreateWithoutStudentInput> | StudentAttendanceCreateWithoutStudentInput[] | StudentAttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutStudentInput | StudentAttendanceCreateOrConnectWithoutStudentInput[]
    upsert?: StudentAttendanceUpsertWithWhereUniqueWithoutStudentInput | StudentAttendanceUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentAttendanceCreateManyStudentInputEnvelope
    set?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    disconnect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    delete?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    update?: StudentAttendanceUpdateWithWhereUniqueWithoutStudentInput | StudentAttendanceUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentAttendanceUpdateManyWithWhereWithoutStudentInput | StudentAttendanceUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentAttendanceScalarWhereInput | StudentAttendanceScalarWhereInput[]
  }

  export type StudentGradeUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentGradeCreateWithoutStudentInput, StudentGradeUncheckedCreateWithoutStudentInput> | StudentGradeCreateWithoutStudentInput[] | StudentGradeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentGradeCreateOrConnectWithoutStudentInput | StudentGradeCreateOrConnectWithoutStudentInput[]
    upsert?: StudentGradeUpsertWithWhereUniqueWithoutStudentInput | StudentGradeUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentGradeCreateManyStudentInputEnvelope
    set?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
    disconnect?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
    delete?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
    connect?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
    update?: StudentGradeUpdateWithWhereUniqueWithoutStudentInput | StudentGradeUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentGradeUpdateManyWithWhereWithoutStudentInput | StudentGradeUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentGradeScalarWhereInput | StudentGradeScalarWhereInput[]
  }

  export type InvoiceLineItemUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<InvoiceLineItemCreateWithoutStudentInput, InvoiceLineItemUncheckedCreateWithoutStudentInput> | InvoiceLineItemCreateWithoutStudentInput[] | InvoiceLineItemUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: InvoiceLineItemCreateOrConnectWithoutStudentInput | InvoiceLineItemCreateOrConnectWithoutStudentInput[]
    upsert?: InvoiceLineItemUpsertWithWhereUniqueWithoutStudentInput | InvoiceLineItemUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: InvoiceLineItemCreateManyStudentInputEnvelope
    set?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
    disconnect?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
    delete?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
    connect?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
    update?: InvoiceLineItemUpdateWithWhereUniqueWithoutStudentInput | InvoiceLineItemUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: InvoiceLineItemUpdateManyWithWhereWithoutStudentInput | InvoiceLineItemUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: InvoiceLineItemScalarWhereInput | InvoiceLineItemScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<InvoiceCreateWithoutStudentInput, InvoiceUncheckedCreateWithoutStudentInput> | InvoiceCreateWithoutStudentInput[] | InvoiceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutStudentInput | InvoiceCreateOrConnectWithoutStudentInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutStudentInput | InvoiceUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: InvoiceCreateManyStudentInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutStudentInput | InvoiceUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutStudentInput | InvoiceUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutParentLinkInput = {
    create?: XOR<UserCreateWithoutParentLinkInput, UserUncheckedCreateWithoutParentLinkInput>
    connectOrCreate?: UserCreateOrConnectWithoutParentLinkInput
    connect?: UserWhereUniqueInput
  }

  export type StudentParentLinkCreateNestedManyWithoutParentInput = {
    create?: XOR<StudentParentLinkCreateWithoutParentInput, StudentParentLinkUncheckedCreateWithoutParentInput> | StudentParentLinkCreateWithoutParentInput[] | StudentParentLinkUncheckedCreateWithoutParentInput[]
    connectOrCreate?: StudentParentLinkCreateOrConnectWithoutParentInput | StudentParentLinkCreateOrConnectWithoutParentInput[]
    createMany?: StudentParentLinkCreateManyParentInputEnvelope
    connect?: StudentParentLinkWhereUniqueInput | StudentParentLinkWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutParentToBillInput = {
    create?: XOR<InvoiceCreateWithoutParentToBillInput, InvoiceUncheckedCreateWithoutParentToBillInput> | InvoiceCreateWithoutParentToBillInput[] | InvoiceUncheckedCreateWithoutParentToBillInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutParentToBillInput | InvoiceCreateOrConnectWithoutParentToBillInput[]
    createMany?: InvoiceCreateManyParentToBillInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type StudentParentLinkUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<StudentParentLinkCreateWithoutParentInput, StudentParentLinkUncheckedCreateWithoutParentInput> | StudentParentLinkCreateWithoutParentInput[] | StudentParentLinkUncheckedCreateWithoutParentInput[]
    connectOrCreate?: StudentParentLinkCreateOrConnectWithoutParentInput | StudentParentLinkCreateOrConnectWithoutParentInput[]
    createMany?: StudentParentLinkCreateManyParentInputEnvelope
    connect?: StudentParentLinkWhereUniqueInput | StudentParentLinkWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutParentToBillInput = {
    create?: XOR<InvoiceCreateWithoutParentToBillInput, InvoiceUncheckedCreateWithoutParentToBillInput> | InvoiceCreateWithoutParentToBillInput[] | InvoiceUncheckedCreateWithoutParentToBillInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutParentToBillInput | InvoiceCreateOrConnectWithoutParentToBillInput[]
    createMany?: InvoiceCreateManyParentToBillInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutParentLinkNestedInput = {
    create?: XOR<UserCreateWithoutParentLinkInput, UserUncheckedCreateWithoutParentLinkInput>
    connectOrCreate?: UserCreateOrConnectWithoutParentLinkInput
    upsert?: UserUpsertWithoutParentLinkInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutParentLinkInput, UserUpdateWithoutParentLinkInput>, UserUncheckedUpdateWithoutParentLinkInput>
  }

  export type StudentParentLinkUpdateManyWithoutParentNestedInput = {
    create?: XOR<StudentParentLinkCreateWithoutParentInput, StudentParentLinkUncheckedCreateWithoutParentInput> | StudentParentLinkCreateWithoutParentInput[] | StudentParentLinkUncheckedCreateWithoutParentInput[]
    connectOrCreate?: StudentParentLinkCreateOrConnectWithoutParentInput | StudentParentLinkCreateOrConnectWithoutParentInput[]
    upsert?: StudentParentLinkUpsertWithWhereUniqueWithoutParentInput | StudentParentLinkUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: StudentParentLinkCreateManyParentInputEnvelope
    set?: StudentParentLinkWhereUniqueInput | StudentParentLinkWhereUniqueInput[]
    disconnect?: StudentParentLinkWhereUniqueInput | StudentParentLinkWhereUniqueInput[]
    delete?: StudentParentLinkWhereUniqueInput | StudentParentLinkWhereUniqueInput[]
    connect?: StudentParentLinkWhereUniqueInput | StudentParentLinkWhereUniqueInput[]
    update?: StudentParentLinkUpdateWithWhereUniqueWithoutParentInput | StudentParentLinkUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: StudentParentLinkUpdateManyWithWhereWithoutParentInput | StudentParentLinkUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: StudentParentLinkScalarWhereInput | StudentParentLinkScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutParentToBillNestedInput = {
    create?: XOR<InvoiceCreateWithoutParentToBillInput, InvoiceUncheckedCreateWithoutParentToBillInput> | InvoiceCreateWithoutParentToBillInput[] | InvoiceUncheckedCreateWithoutParentToBillInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutParentToBillInput | InvoiceCreateOrConnectWithoutParentToBillInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutParentToBillInput | InvoiceUpsertWithWhereUniqueWithoutParentToBillInput[]
    createMany?: InvoiceCreateManyParentToBillInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutParentToBillInput | InvoiceUpdateWithWhereUniqueWithoutParentToBillInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutParentToBillInput | InvoiceUpdateManyWithWhereWithoutParentToBillInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type StudentParentLinkUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<StudentParentLinkCreateWithoutParentInput, StudentParentLinkUncheckedCreateWithoutParentInput> | StudentParentLinkCreateWithoutParentInput[] | StudentParentLinkUncheckedCreateWithoutParentInput[]
    connectOrCreate?: StudentParentLinkCreateOrConnectWithoutParentInput | StudentParentLinkCreateOrConnectWithoutParentInput[]
    upsert?: StudentParentLinkUpsertWithWhereUniqueWithoutParentInput | StudentParentLinkUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: StudentParentLinkCreateManyParentInputEnvelope
    set?: StudentParentLinkWhereUniqueInput | StudentParentLinkWhereUniqueInput[]
    disconnect?: StudentParentLinkWhereUniqueInput | StudentParentLinkWhereUniqueInput[]
    delete?: StudentParentLinkWhereUniqueInput | StudentParentLinkWhereUniqueInput[]
    connect?: StudentParentLinkWhereUniqueInput | StudentParentLinkWhereUniqueInput[]
    update?: StudentParentLinkUpdateWithWhereUniqueWithoutParentInput | StudentParentLinkUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: StudentParentLinkUpdateManyWithWhereWithoutParentInput | StudentParentLinkUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: StudentParentLinkScalarWhereInput | StudentParentLinkScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutParentToBillNestedInput = {
    create?: XOR<InvoiceCreateWithoutParentToBillInput, InvoiceUncheckedCreateWithoutParentToBillInput> | InvoiceCreateWithoutParentToBillInput[] | InvoiceUncheckedCreateWithoutParentToBillInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutParentToBillInput | InvoiceCreateOrConnectWithoutParentToBillInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutParentToBillInput | InvoiceUpsertWithWhereUniqueWithoutParentToBillInput[]
    createMany?: InvoiceCreateManyParentToBillInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutParentToBillInput | InvoiceUpdateWithWhereUniqueWithoutParentToBillInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutParentToBillInput | InvoiceUpdateManyWithWhereWithoutParentToBillInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutParentsInput = {
    create?: XOR<StudentCreateWithoutParentsInput, StudentUncheckedCreateWithoutParentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutParentsInput
    connect?: StudentWhereUniqueInput
  }

  export type ParentCreateNestedOneWithoutChildrenInput = {
    create?: XOR<ParentCreateWithoutChildrenInput, ParentUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ParentCreateOrConnectWithoutChildrenInput
    connect?: ParentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutParentsNestedInput = {
    create?: XOR<StudentCreateWithoutParentsInput, StudentUncheckedCreateWithoutParentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutParentsInput
    upsert?: StudentUpsertWithoutParentsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutParentsInput, StudentUpdateWithoutParentsInput>, StudentUncheckedUpdateWithoutParentsInput>
  }

  export type ParentUpdateOneRequiredWithoutChildrenNestedInput = {
    create?: XOR<ParentCreateWithoutChildrenInput, ParentUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ParentCreateOrConnectWithoutChildrenInput
    upsert?: ParentUpsertWithoutChildrenInput
    connect?: ParentWhereUniqueInput
    update?: XOR<XOR<ParentUpdateToOneWithWhereWithoutChildrenInput, ParentUpdateWithoutChildrenInput>, ParentUncheckedUpdateWithoutChildrenInput>
  }

  export type SchoolCreateNestedOneWithoutClassesInput = {
    create?: XOR<SchoolCreateWithoutClassesInput, SchoolUncheckedCreateWithoutClassesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutClassesInput
    connect?: SchoolWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutClassTeacherOfInput = {
    create?: XOR<TeacherCreateWithoutClassTeacherOfInput, TeacherUncheckedCreateWithoutClassTeacherOfInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutClassTeacherOfInput
    connect?: TeacherWhereUniqueInput
  }

  export type StudentClassEnrollmentCreateNestedManyWithoutClassInput = {
    create?: XOR<StudentClassEnrollmentCreateWithoutClassInput, StudentClassEnrollmentUncheckedCreateWithoutClassInput> | StudentClassEnrollmentCreateWithoutClassInput[] | StudentClassEnrollmentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentClassEnrollmentCreateOrConnectWithoutClassInput | StudentClassEnrollmentCreateOrConnectWithoutClassInput[]
    createMany?: StudentClassEnrollmentCreateManyClassInputEnvelope
    connect?: StudentClassEnrollmentWhereUniqueInput | StudentClassEnrollmentWhereUniqueInput[]
  }

  export type StudentCreateNestedManyWithoutCurrentClassInput = {
    create?: XOR<StudentCreateWithoutCurrentClassInput, StudentUncheckedCreateWithoutCurrentClassInput> | StudentCreateWithoutCurrentClassInput[] | StudentUncheckedCreateWithoutCurrentClassInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutCurrentClassInput | StudentCreateOrConnectWithoutCurrentClassInput[]
    createMany?: StudentCreateManyCurrentClassInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type TimetableSlotCreateNestedManyWithoutClassInput = {
    create?: XOR<TimetableSlotCreateWithoutClassInput, TimetableSlotUncheckedCreateWithoutClassInput> | TimetableSlotCreateWithoutClassInput[] | TimetableSlotUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TimetableSlotCreateOrConnectWithoutClassInput | TimetableSlotCreateOrConnectWithoutClassInput[]
    createMany?: TimetableSlotCreateManyClassInputEnvelope
    connect?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
  }

  export type AssignmentCreateNestedManyWithoutClassInput = {
    create?: XOR<AssignmentCreateWithoutClassInput, AssignmentUncheckedCreateWithoutClassInput> | AssignmentCreateWithoutClassInput[] | AssignmentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutClassInput | AssignmentCreateOrConnectWithoutClassInput[]
    createMany?: AssignmentCreateManyClassInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type ClassAnnouncementCreateNestedManyWithoutClassInput = {
    create?: XOR<ClassAnnouncementCreateWithoutClassInput, ClassAnnouncementUncheckedCreateWithoutClassInput> | ClassAnnouncementCreateWithoutClassInput[] | ClassAnnouncementUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassAnnouncementCreateOrConnectWithoutClassInput | ClassAnnouncementCreateOrConnectWithoutClassInput[]
    createMany?: ClassAnnouncementCreateManyClassInputEnvelope
    connect?: ClassAnnouncementWhereUniqueInput | ClassAnnouncementWhereUniqueInput[]
  }

  export type StudentClassEnrollmentUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<StudentClassEnrollmentCreateWithoutClassInput, StudentClassEnrollmentUncheckedCreateWithoutClassInput> | StudentClassEnrollmentCreateWithoutClassInput[] | StudentClassEnrollmentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentClassEnrollmentCreateOrConnectWithoutClassInput | StudentClassEnrollmentCreateOrConnectWithoutClassInput[]
    createMany?: StudentClassEnrollmentCreateManyClassInputEnvelope
    connect?: StudentClassEnrollmentWhereUniqueInput | StudentClassEnrollmentWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutCurrentClassInput = {
    create?: XOR<StudentCreateWithoutCurrentClassInput, StudentUncheckedCreateWithoutCurrentClassInput> | StudentCreateWithoutCurrentClassInput[] | StudentUncheckedCreateWithoutCurrentClassInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutCurrentClassInput | StudentCreateOrConnectWithoutCurrentClassInput[]
    createMany?: StudentCreateManyCurrentClassInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type TimetableSlotUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<TimetableSlotCreateWithoutClassInput, TimetableSlotUncheckedCreateWithoutClassInput> | TimetableSlotCreateWithoutClassInput[] | TimetableSlotUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TimetableSlotCreateOrConnectWithoutClassInput | TimetableSlotCreateOrConnectWithoutClassInput[]
    createMany?: TimetableSlotCreateManyClassInputEnvelope
    connect?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
  }

  export type AssignmentUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<AssignmentCreateWithoutClassInput, AssignmentUncheckedCreateWithoutClassInput> | AssignmentCreateWithoutClassInput[] | AssignmentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutClassInput | AssignmentCreateOrConnectWithoutClassInput[]
    createMany?: AssignmentCreateManyClassInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type ClassAnnouncementUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<ClassAnnouncementCreateWithoutClassInput, ClassAnnouncementUncheckedCreateWithoutClassInput> | ClassAnnouncementCreateWithoutClassInput[] | ClassAnnouncementUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassAnnouncementCreateOrConnectWithoutClassInput | ClassAnnouncementCreateOrConnectWithoutClassInput[]
    createMany?: ClassAnnouncementCreateManyClassInputEnvelope
    connect?: ClassAnnouncementWhereUniqueInput | ClassAnnouncementWhereUniqueInput[]
  }

  export type SchoolUpdateOneRequiredWithoutClassesNestedInput = {
    create?: XOR<SchoolCreateWithoutClassesInput, SchoolUncheckedCreateWithoutClassesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutClassesInput
    upsert?: SchoolUpsertWithoutClassesInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutClassesInput, SchoolUpdateWithoutClassesInput>, SchoolUncheckedUpdateWithoutClassesInput>
  }

  export type TeacherUpdateOneWithoutClassTeacherOfNestedInput = {
    create?: XOR<TeacherCreateWithoutClassTeacherOfInput, TeacherUncheckedCreateWithoutClassTeacherOfInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutClassTeacherOfInput
    upsert?: TeacherUpsertWithoutClassTeacherOfInput
    disconnect?: TeacherWhereInput | boolean
    delete?: TeacherWhereInput | boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutClassTeacherOfInput, TeacherUpdateWithoutClassTeacherOfInput>, TeacherUncheckedUpdateWithoutClassTeacherOfInput>
  }

  export type StudentClassEnrollmentUpdateManyWithoutClassNestedInput = {
    create?: XOR<StudentClassEnrollmentCreateWithoutClassInput, StudentClassEnrollmentUncheckedCreateWithoutClassInput> | StudentClassEnrollmentCreateWithoutClassInput[] | StudentClassEnrollmentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentClassEnrollmentCreateOrConnectWithoutClassInput | StudentClassEnrollmentCreateOrConnectWithoutClassInput[]
    upsert?: StudentClassEnrollmentUpsertWithWhereUniqueWithoutClassInput | StudentClassEnrollmentUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: StudentClassEnrollmentCreateManyClassInputEnvelope
    set?: StudentClassEnrollmentWhereUniqueInput | StudentClassEnrollmentWhereUniqueInput[]
    disconnect?: StudentClassEnrollmentWhereUniqueInput | StudentClassEnrollmentWhereUniqueInput[]
    delete?: StudentClassEnrollmentWhereUniqueInput | StudentClassEnrollmentWhereUniqueInput[]
    connect?: StudentClassEnrollmentWhereUniqueInput | StudentClassEnrollmentWhereUniqueInput[]
    update?: StudentClassEnrollmentUpdateWithWhereUniqueWithoutClassInput | StudentClassEnrollmentUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: StudentClassEnrollmentUpdateManyWithWhereWithoutClassInput | StudentClassEnrollmentUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: StudentClassEnrollmentScalarWhereInput | StudentClassEnrollmentScalarWhereInput[]
  }

  export type StudentUpdateManyWithoutCurrentClassNestedInput = {
    create?: XOR<StudentCreateWithoutCurrentClassInput, StudentUncheckedCreateWithoutCurrentClassInput> | StudentCreateWithoutCurrentClassInput[] | StudentUncheckedCreateWithoutCurrentClassInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutCurrentClassInput | StudentCreateOrConnectWithoutCurrentClassInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutCurrentClassInput | StudentUpsertWithWhereUniqueWithoutCurrentClassInput[]
    createMany?: StudentCreateManyCurrentClassInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutCurrentClassInput | StudentUpdateWithWhereUniqueWithoutCurrentClassInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutCurrentClassInput | StudentUpdateManyWithWhereWithoutCurrentClassInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type TimetableSlotUpdateManyWithoutClassNestedInput = {
    create?: XOR<TimetableSlotCreateWithoutClassInput, TimetableSlotUncheckedCreateWithoutClassInput> | TimetableSlotCreateWithoutClassInput[] | TimetableSlotUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TimetableSlotCreateOrConnectWithoutClassInput | TimetableSlotCreateOrConnectWithoutClassInput[]
    upsert?: TimetableSlotUpsertWithWhereUniqueWithoutClassInput | TimetableSlotUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: TimetableSlotCreateManyClassInputEnvelope
    set?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
    disconnect?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
    delete?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
    connect?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
    update?: TimetableSlotUpdateWithWhereUniqueWithoutClassInput | TimetableSlotUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: TimetableSlotUpdateManyWithWhereWithoutClassInput | TimetableSlotUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: TimetableSlotScalarWhereInput | TimetableSlotScalarWhereInput[]
  }

  export type AssignmentUpdateManyWithoutClassNestedInput = {
    create?: XOR<AssignmentCreateWithoutClassInput, AssignmentUncheckedCreateWithoutClassInput> | AssignmentCreateWithoutClassInput[] | AssignmentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutClassInput | AssignmentCreateOrConnectWithoutClassInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutClassInput | AssignmentUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: AssignmentCreateManyClassInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutClassInput | AssignmentUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutClassInput | AssignmentUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type ClassAnnouncementUpdateManyWithoutClassNestedInput = {
    create?: XOR<ClassAnnouncementCreateWithoutClassInput, ClassAnnouncementUncheckedCreateWithoutClassInput> | ClassAnnouncementCreateWithoutClassInput[] | ClassAnnouncementUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassAnnouncementCreateOrConnectWithoutClassInput | ClassAnnouncementCreateOrConnectWithoutClassInput[]
    upsert?: ClassAnnouncementUpsertWithWhereUniqueWithoutClassInput | ClassAnnouncementUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ClassAnnouncementCreateManyClassInputEnvelope
    set?: ClassAnnouncementWhereUniqueInput | ClassAnnouncementWhereUniqueInput[]
    disconnect?: ClassAnnouncementWhereUniqueInput | ClassAnnouncementWhereUniqueInput[]
    delete?: ClassAnnouncementWhereUniqueInput | ClassAnnouncementWhereUniqueInput[]
    connect?: ClassAnnouncementWhereUniqueInput | ClassAnnouncementWhereUniqueInput[]
    update?: ClassAnnouncementUpdateWithWhereUniqueWithoutClassInput | ClassAnnouncementUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ClassAnnouncementUpdateManyWithWhereWithoutClassInput | ClassAnnouncementUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ClassAnnouncementScalarWhereInput | ClassAnnouncementScalarWhereInput[]
  }

  export type StudentClassEnrollmentUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<StudentClassEnrollmentCreateWithoutClassInput, StudentClassEnrollmentUncheckedCreateWithoutClassInput> | StudentClassEnrollmentCreateWithoutClassInput[] | StudentClassEnrollmentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentClassEnrollmentCreateOrConnectWithoutClassInput | StudentClassEnrollmentCreateOrConnectWithoutClassInput[]
    upsert?: StudentClassEnrollmentUpsertWithWhereUniqueWithoutClassInput | StudentClassEnrollmentUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: StudentClassEnrollmentCreateManyClassInputEnvelope
    set?: StudentClassEnrollmentWhereUniqueInput | StudentClassEnrollmentWhereUniqueInput[]
    disconnect?: StudentClassEnrollmentWhereUniqueInput | StudentClassEnrollmentWhereUniqueInput[]
    delete?: StudentClassEnrollmentWhereUniqueInput | StudentClassEnrollmentWhereUniqueInput[]
    connect?: StudentClassEnrollmentWhereUniqueInput | StudentClassEnrollmentWhereUniqueInput[]
    update?: StudentClassEnrollmentUpdateWithWhereUniqueWithoutClassInput | StudentClassEnrollmentUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: StudentClassEnrollmentUpdateManyWithWhereWithoutClassInput | StudentClassEnrollmentUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: StudentClassEnrollmentScalarWhereInput | StudentClassEnrollmentScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutCurrentClassNestedInput = {
    create?: XOR<StudentCreateWithoutCurrentClassInput, StudentUncheckedCreateWithoutCurrentClassInput> | StudentCreateWithoutCurrentClassInput[] | StudentUncheckedCreateWithoutCurrentClassInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutCurrentClassInput | StudentCreateOrConnectWithoutCurrentClassInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutCurrentClassInput | StudentUpsertWithWhereUniqueWithoutCurrentClassInput[]
    createMany?: StudentCreateManyCurrentClassInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutCurrentClassInput | StudentUpdateWithWhereUniqueWithoutCurrentClassInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutCurrentClassInput | StudentUpdateManyWithWhereWithoutCurrentClassInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type TimetableSlotUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<TimetableSlotCreateWithoutClassInput, TimetableSlotUncheckedCreateWithoutClassInput> | TimetableSlotCreateWithoutClassInput[] | TimetableSlotUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TimetableSlotCreateOrConnectWithoutClassInput | TimetableSlotCreateOrConnectWithoutClassInput[]
    upsert?: TimetableSlotUpsertWithWhereUniqueWithoutClassInput | TimetableSlotUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: TimetableSlotCreateManyClassInputEnvelope
    set?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
    disconnect?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
    delete?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
    connect?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
    update?: TimetableSlotUpdateWithWhereUniqueWithoutClassInput | TimetableSlotUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: TimetableSlotUpdateManyWithWhereWithoutClassInput | TimetableSlotUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: TimetableSlotScalarWhereInput | TimetableSlotScalarWhereInput[]
  }

  export type AssignmentUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<AssignmentCreateWithoutClassInput, AssignmentUncheckedCreateWithoutClassInput> | AssignmentCreateWithoutClassInput[] | AssignmentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutClassInput | AssignmentCreateOrConnectWithoutClassInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutClassInput | AssignmentUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: AssignmentCreateManyClassInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutClassInput | AssignmentUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutClassInput | AssignmentUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type ClassAnnouncementUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<ClassAnnouncementCreateWithoutClassInput, ClassAnnouncementUncheckedCreateWithoutClassInput> | ClassAnnouncementCreateWithoutClassInput[] | ClassAnnouncementUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassAnnouncementCreateOrConnectWithoutClassInput | ClassAnnouncementCreateOrConnectWithoutClassInput[]
    upsert?: ClassAnnouncementUpsertWithWhereUniqueWithoutClassInput | ClassAnnouncementUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ClassAnnouncementCreateManyClassInputEnvelope
    set?: ClassAnnouncementWhereUniqueInput | ClassAnnouncementWhereUniqueInput[]
    disconnect?: ClassAnnouncementWhereUniqueInput | ClassAnnouncementWhereUniqueInput[]
    delete?: ClassAnnouncementWhereUniqueInput | ClassAnnouncementWhereUniqueInput[]
    connect?: ClassAnnouncementWhereUniqueInput | ClassAnnouncementWhereUniqueInput[]
    update?: ClassAnnouncementUpdateWithWhereUniqueWithoutClassInput | ClassAnnouncementUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ClassAnnouncementUpdateManyWithWhereWithoutClassInput | ClassAnnouncementUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ClassAnnouncementScalarWhereInput | ClassAnnouncementScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<StudentCreateWithoutEnrollmentsInput, StudentUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutEnrollmentsInput
    connect?: StudentWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutStudentsEnrolledInput = {
    create?: XOR<ClassCreateWithoutStudentsEnrolledInput, ClassUncheckedCreateWithoutStudentsEnrolledInput>
    connectOrCreate?: ClassCreateOrConnectWithoutStudentsEnrolledInput
    connect?: ClassWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<StudentCreateWithoutEnrollmentsInput, StudentUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutEnrollmentsInput
    upsert?: StudentUpsertWithoutEnrollmentsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutEnrollmentsInput, StudentUpdateWithoutEnrollmentsInput>, StudentUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type ClassUpdateOneRequiredWithoutStudentsEnrolledNestedInput = {
    create?: XOR<ClassCreateWithoutStudentsEnrolledInput, ClassUncheckedCreateWithoutStudentsEnrolledInput>
    connectOrCreate?: ClassCreateOrConnectWithoutStudentsEnrolledInput
    upsert?: ClassUpsertWithoutStudentsEnrolledInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutStudentsEnrolledInput, ClassUpdateWithoutStudentsEnrolledInput>, ClassUncheckedUpdateWithoutStudentsEnrolledInput>
  }

  export type SchoolCreateNestedOneWithoutSubjectsInput = {
    create?: XOR<SchoolCreateWithoutSubjectsInput, SchoolUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutSubjectsInput
    connect?: SchoolWhereUniqueInput
  }

  export type TimetableSlotCreateNestedManyWithoutSubjectInput = {
    create?: XOR<TimetableSlotCreateWithoutSubjectInput, TimetableSlotUncheckedCreateWithoutSubjectInput> | TimetableSlotCreateWithoutSubjectInput[] | TimetableSlotUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: TimetableSlotCreateOrConnectWithoutSubjectInput | TimetableSlotCreateOrConnectWithoutSubjectInput[]
    createMany?: TimetableSlotCreateManySubjectInputEnvelope
    connect?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
  }

  export type AssignmentCreateNestedManyWithoutSubjectInput = {
    create?: XOR<AssignmentCreateWithoutSubjectInput, AssignmentUncheckedCreateWithoutSubjectInput> | AssignmentCreateWithoutSubjectInput[] | AssignmentUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutSubjectInput | AssignmentCreateOrConnectWithoutSubjectInput[]
    createMany?: AssignmentCreateManySubjectInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type StudentGradeCreateNestedManyWithoutSubjectInput = {
    create?: XOR<StudentGradeCreateWithoutSubjectInput, StudentGradeUncheckedCreateWithoutSubjectInput> | StudentGradeCreateWithoutSubjectInput[] | StudentGradeUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: StudentGradeCreateOrConnectWithoutSubjectInput | StudentGradeCreateOrConnectWithoutSubjectInput[]
    createMany?: StudentGradeCreateManySubjectInputEnvelope
    connect?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
  }

  export type TimetableSlotUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<TimetableSlotCreateWithoutSubjectInput, TimetableSlotUncheckedCreateWithoutSubjectInput> | TimetableSlotCreateWithoutSubjectInput[] | TimetableSlotUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: TimetableSlotCreateOrConnectWithoutSubjectInput | TimetableSlotCreateOrConnectWithoutSubjectInput[]
    createMany?: TimetableSlotCreateManySubjectInputEnvelope
    connect?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
  }

  export type AssignmentUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<AssignmentCreateWithoutSubjectInput, AssignmentUncheckedCreateWithoutSubjectInput> | AssignmentCreateWithoutSubjectInput[] | AssignmentUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutSubjectInput | AssignmentCreateOrConnectWithoutSubjectInput[]
    createMany?: AssignmentCreateManySubjectInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type StudentGradeUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<StudentGradeCreateWithoutSubjectInput, StudentGradeUncheckedCreateWithoutSubjectInput> | StudentGradeCreateWithoutSubjectInput[] | StudentGradeUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: StudentGradeCreateOrConnectWithoutSubjectInput | StudentGradeCreateOrConnectWithoutSubjectInput[]
    createMany?: StudentGradeCreateManySubjectInputEnvelope
    connect?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
  }

  export type SchoolUpdateOneRequiredWithoutSubjectsNestedInput = {
    create?: XOR<SchoolCreateWithoutSubjectsInput, SchoolUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutSubjectsInput
    upsert?: SchoolUpsertWithoutSubjectsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutSubjectsInput, SchoolUpdateWithoutSubjectsInput>, SchoolUncheckedUpdateWithoutSubjectsInput>
  }

  export type TimetableSlotUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<TimetableSlotCreateWithoutSubjectInput, TimetableSlotUncheckedCreateWithoutSubjectInput> | TimetableSlotCreateWithoutSubjectInput[] | TimetableSlotUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: TimetableSlotCreateOrConnectWithoutSubjectInput | TimetableSlotCreateOrConnectWithoutSubjectInput[]
    upsert?: TimetableSlotUpsertWithWhereUniqueWithoutSubjectInput | TimetableSlotUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: TimetableSlotCreateManySubjectInputEnvelope
    set?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
    disconnect?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
    delete?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
    connect?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
    update?: TimetableSlotUpdateWithWhereUniqueWithoutSubjectInput | TimetableSlotUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: TimetableSlotUpdateManyWithWhereWithoutSubjectInput | TimetableSlotUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: TimetableSlotScalarWhereInput | TimetableSlotScalarWhereInput[]
  }

  export type AssignmentUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<AssignmentCreateWithoutSubjectInput, AssignmentUncheckedCreateWithoutSubjectInput> | AssignmentCreateWithoutSubjectInput[] | AssignmentUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutSubjectInput | AssignmentCreateOrConnectWithoutSubjectInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutSubjectInput | AssignmentUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: AssignmentCreateManySubjectInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutSubjectInput | AssignmentUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutSubjectInput | AssignmentUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type StudentGradeUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<StudentGradeCreateWithoutSubjectInput, StudentGradeUncheckedCreateWithoutSubjectInput> | StudentGradeCreateWithoutSubjectInput[] | StudentGradeUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: StudentGradeCreateOrConnectWithoutSubjectInput | StudentGradeCreateOrConnectWithoutSubjectInput[]
    upsert?: StudentGradeUpsertWithWhereUniqueWithoutSubjectInput | StudentGradeUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: StudentGradeCreateManySubjectInputEnvelope
    set?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
    disconnect?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
    delete?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
    connect?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
    update?: StudentGradeUpdateWithWhereUniqueWithoutSubjectInput | StudentGradeUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: StudentGradeUpdateManyWithWhereWithoutSubjectInput | StudentGradeUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: StudentGradeScalarWhereInput | StudentGradeScalarWhereInput[]
  }

  export type TimetableSlotUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<TimetableSlotCreateWithoutSubjectInput, TimetableSlotUncheckedCreateWithoutSubjectInput> | TimetableSlotCreateWithoutSubjectInput[] | TimetableSlotUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: TimetableSlotCreateOrConnectWithoutSubjectInput | TimetableSlotCreateOrConnectWithoutSubjectInput[]
    upsert?: TimetableSlotUpsertWithWhereUniqueWithoutSubjectInput | TimetableSlotUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: TimetableSlotCreateManySubjectInputEnvelope
    set?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
    disconnect?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
    delete?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
    connect?: TimetableSlotWhereUniqueInput | TimetableSlotWhereUniqueInput[]
    update?: TimetableSlotUpdateWithWhereUniqueWithoutSubjectInput | TimetableSlotUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: TimetableSlotUpdateManyWithWhereWithoutSubjectInput | TimetableSlotUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: TimetableSlotScalarWhereInput | TimetableSlotScalarWhereInput[]
  }

  export type AssignmentUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<AssignmentCreateWithoutSubjectInput, AssignmentUncheckedCreateWithoutSubjectInput> | AssignmentCreateWithoutSubjectInput[] | AssignmentUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutSubjectInput | AssignmentCreateOrConnectWithoutSubjectInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutSubjectInput | AssignmentUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: AssignmentCreateManySubjectInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutSubjectInput | AssignmentUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutSubjectInput | AssignmentUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type StudentGradeUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<StudentGradeCreateWithoutSubjectInput, StudentGradeUncheckedCreateWithoutSubjectInput> | StudentGradeCreateWithoutSubjectInput[] | StudentGradeUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: StudentGradeCreateOrConnectWithoutSubjectInput | StudentGradeCreateOrConnectWithoutSubjectInput[]
    upsert?: StudentGradeUpsertWithWhereUniqueWithoutSubjectInput | StudentGradeUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: StudentGradeCreateManySubjectInputEnvelope
    set?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
    disconnect?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
    delete?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
    connect?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
    update?: StudentGradeUpdateWithWhereUniqueWithoutSubjectInput | StudentGradeUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: StudentGradeUpdateManyWithWhereWithoutSubjectInput | StudentGradeUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: StudentGradeScalarWhereInput | StudentGradeScalarWhereInput[]
  }

  export type SchoolCreateNestedOneWithoutTimetableSlotsInput = {
    create?: XOR<SchoolCreateWithoutTimetableSlotsInput, SchoolUncheckedCreateWithoutTimetableSlotsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutTimetableSlotsInput
    connect?: SchoolWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutTimetableSlotsInput = {
    create?: XOR<ClassCreateWithoutTimetableSlotsInput, ClassUncheckedCreateWithoutTimetableSlotsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutTimetableSlotsInput
    connect?: ClassWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutTimetableSlotsInput = {
    create?: XOR<SubjectCreateWithoutTimetableSlotsInput, SubjectUncheckedCreateWithoutTimetableSlotsInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutTimetableSlotsInput
    connect?: SubjectWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutTimetableSlotsInput = {
    create?: XOR<TeacherCreateWithoutTimetableSlotsInput, TeacherUncheckedCreateWithoutTimetableSlotsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutTimetableSlotsInput
    connect?: TeacherWhereUniqueInput
  }

  export type StudentAttendanceCreateNestedManyWithoutTimetableSlotInput = {
    create?: XOR<StudentAttendanceCreateWithoutTimetableSlotInput, StudentAttendanceUncheckedCreateWithoutTimetableSlotInput> | StudentAttendanceCreateWithoutTimetableSlotInput[] | StudentAttendanceUncheckedCreateWithoutTimetableSlotInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutTimetableSlotInput | StudentAttendanceCreateOrConnectWithoutTimetableSlotInput[]
    createMany?: StudentAttendanceCreateManyTimetableSlotInputEnvelope
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
  }

  export type StudentAttendanceUncheckedCreateNestedManyWithoutTimetableSlotInput = {
    create?: XOR<StudentAttendanceCreateWithoutTimetableSlotInput, StudentAttendanceUncheckedCreateWithoutTimetableSlotInput> | StudentAttendanceCreateWithoutTimetableSlotInput[] | StudentAttendanceUncheckedCreateWithoutTimetableSlotInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutTimetableSlotInput | StudentAttendanceCreateOrConnectWithoutTimetableSlotInput[]
    createMany?: StudentAttendanceCreateManyTimetableSlotInputEnvelope
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
  }

  export type EnumDayOfWeekFieldUpdateOperationsInput = {
    set?: $Enums.DayOfWeek
  }

  export type SchoolUpdateOneRequiredWithoutTimetableSlotsNestedInput = {
    create?: XOR<SchoolCreateWithoutTimetableSlotsInput, SchoolUncheckedCreateWithoutTimetableSlotsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutTimetableSlotsInput
    upsert?: SchoolUpsertWithoutTimetableSlotsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutTimetableSlotsInput, SchoolUpdateWithoutTimetableSlotsInput>, SchoolUncheckedUpdateWithoutTimetableSlotsInput>
  }

  export type ClassUpdateOneRequiredWithoutTimetableSlotsNestedInput = {
    create?: XOR<ClassCreateWithoutTimetableSlotsInput, ClassUncheckedCreateWithoutTimetableSlotsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutTimetableSlotsInput
    upsert?: ClassUpsertWithoutTimetableSlotsInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutTimetableSlotsInput, ClassUpdateWithoutTimetableSlotsInput>, ClassUncheckedUpdateWithoutTimetableSlotsInput>
  }

  export type SubjectUpdateOneRequiredWithoutTimetableSlotsNestedInput = {
    create?: XOR<SubjectCreateWithoutTimetableSlotsInput, SubjectUncheckedCreateWithoutTimetableSlotsInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutTimetableSlotsInput
    upsert?: SubjectUpsertWithoutTimetableSlotsInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutTimetableSlotsInput, SubjectUpdateWithoutTimetableSlotsInput>, SubjectUncheckedUpdateWithoutTimetableSlotsInput>
  }

  export type TeacherUpdateOneRequiredWithoutTimetableSlotsNestedInput = {
    create?: XOR<TeacherCreateWithoutTimetableSlotsInput, TeacherUncheckedCreateWithoutTimetableSlotsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutTimetableSlotsInput
    upsert?: TeacherUpsertWithoutTimetableSlotsInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutTimetableSlotsInput, TeacherUpdateWithoutTimetableSlotsInput>, TeacherUncheckedUpdateWithoutTimetableSlotsInput>
  }

  export type StudentAttendanceUpdateManyWithoutTimetableSlotNestedInput = {
    create?: XOR<StudentAttendanceCreateWithoutTimetableSlotInput, StudentAttendanceUncheckedCreateWithoutTimetableSlotInput> | StudentAttendanceCreateWithoutTimetableSlotInput[] | StudentAttendanceUncheckedCreateWithoutTimetableSlotInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutTimetableSlotInput | StudentAttendanceCreateOrConnectWithoutTimetableSlotInput[]
    upsert?: StudentAttendanceUpsertWithWhereUniqueWithoutTimetableSlotInput | StudentAttendanceUpsertWithWhereUniqueWithoutTimetableSlotInput[]
    createMany?: StudentAttendanceCreateManyTimetableSlotInputEnvelope
    set?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    disconnect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    delete?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    update?: StudentAttendanceUpdateWithWhereUniqueWithoutTimetableSlotInput | StudentAttendanceUpdateWithWhereUniqueWithoutTimetableSlotInput[]
    updateMany?: StudentAttendanceUpdateManyWithWhereWithoutTimetableSlotInput | StudentAttendanceUpdateManyWithWhereWithoutTimetableSlotInput[]
    deleteMany?: StudentAttendanceScalarWhereInput | StudentAttendanceScalarWhereInput[]
  }

  export type StudentAttendanceUncheckedUpdateManyWithoutTimetableSlotNestedInput = {
    create?: XOR<StudentAttendanceCreateWithoutTimetableSlotInput, StudentAttendanceUncheckedCreateWithoutTimetableSlotInput> | StudentAttendanceCreateWithoutTimetableSlotInput[] | StudentAttendanceUncheckedCreateWithoutTimetableSlotInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutTimetableSlotInput | StudentAttendanceCreateOrConnectWithoutTimetableSlotInput[]
    upsert?: StudentAttendanceUpsertWithWhereUniqueWithoutTimetableSlotInput | StudentAttendanceUpsertWithWhereUniqueWithoutTimetableSlotInput[]
    createMany?: StudentAttendanceCreateManyTimetableSlotInputEnvelope
    set?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    disconnect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    delete?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    update?: StudentAttendanceUpdateWithWhereUniqueWithoutTimetableSlotInput | StudentAttendanceUpdateWithWhereUniqueWithoutTimetableSlotInput[]
    updateMany?: StudentAttendanceUpdateManyWithWhereWithoutTimetableSlotInput | StudentAttendanceUpdateManyWithWhereWithoutTimetableSlotInput[]
    deleteMany?: StudentAttendanceScalarWhereInput | StudentAttendanceScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<StudentCreateWithoutAttendancesInput, StudentUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAttendancesInput
    connect?: StudentWhereUniqueInput
  }

  export type TimetableSlotCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<TimetableSlotCreateWithoutAttendancesInput, TimetableSlotUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: TimetableSlotCreateOrConnectWithoutAttendancesInput
    connect?: TimetableSlotWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRecordedAttendancesInput = {
    create?: XOR<UserCreateWithoutRecordedAttendancesInput, UserUncheckedCreateWithoutRecordedAttendancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecordedAttendancesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAttendanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.AttendanceStatus
  }

  export type EnumTermPeriodFieldUpdateOperationsInput = {
    set?: $Enums.TermPeriod
  }

  export type StudentUpdateOneRequiredWithoutAttendancesNestedInput = {
    create?: XOR<StudentCreateWithoutAttendancesInput, StudentUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAttendancesInput
    upsert?: StudentUpsertWithoutAttendancesInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutAttendancesInput, StudentUpdateWithoutAttendancesInput>, StudentUncheckedUpdateWithoutAttendancesInput>
  }

  export type TimetableSlotUpdateOneWithoutAttendancesNestedInput = {
    create?: XOR<TimetableSlotCreateWithoutAttendancesInput, TimetableSlotUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: TimetableSlotCreateOrConnectWithoutAttendancesInput
    upsert?: TimetableSlotUpsertWithoutAttendancesInput
    disconnect?: TimetableSlotWhereInput | boolean
    delete?: TimetableSlotWhereInput | boolean
    connect?: TimetableSlotWhereUniqueInput
    update?: XOR<XOR<TimetableSlotUpdateToOneWithWhereWithoutAttendancesInput, TimetableSlotUpdateWithoutAttendancesInput>, TimetableSlotUncheckedUpdateWithoutAttendancesInput>
  }

  export type UserUpdateOneWithoutRecordedAttendancesNestedInput = {
    create?: XOR<UserCreateWithoutRecordedAttendancesInput, UserUncheckedCreateWithoutRecordedAttendancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecordedAttendancesInput
    upsert?: UserUpsertWithoutRecordedAttendancesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRecordedAttendancesInput, UserUpdateWithoutRecordedAttendancesInput>, UserUncheckedUpdateWithoutRecordedAttendancesInput>
  }

  export type ClassCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<ClassCreateWithoutAssignmentsInput, ClassUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutAssignmentsInput
    connect?: ClassWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<SubjectCreateWithoutAssignmentsInput, SubjectUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutAssignmentsInput
    connect?: SubjectWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutAssignmentsCreatedInput = {
    create?: XOR<TeacherCreateWithoutAssignmentsCreatedInput, TeacherUncheckedCreateWithoutAssignmentsCreatedInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutAssignmentsCreatedInput
    connect?: TeacherWhereUniqueInput
  }

  export type StudentGradeCreateNestedManyWithoutAssignmentInput = {
    create?: XOR<StudentGradeCreateWithoutAssignmentInput, StudentGradeUncheckedCreateWithoutAssignmentInput> | StudentGradeCreateWithoutAssignmentInput[] | StudentGradeUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: StudentGradeCreateOrConnectWithoutAssignmentInput | StudentGradeCreateOrConnectWithoutAssignmentInput[]
    createMany?: StudentGradeCreateManyAssignmentInputEnvelope
    connect?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
  }

  export type StudentGradeUncheckedCreateNestedManyWithoutAssignmentInput = {
    create?: XOR<StudentGradeCreateWithoutAssignmentInput, StudentGradeUncheckedCreateWithoutAssignmentInput> | StudentGradeCreateWithoutAssignmentInput[] | StudentGradeUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: StudentGradeCreateOrConnectWithoutAssignmentInput | StudentGradeCreateOrConnectWithoutAssignmentInput[]
    createMany?: StudentGradeCreateManyAssignmentInputEnvelope
    connect?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ClassUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<ClassCreateWithoutAssignmentsInput, ClassUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutAssignmentsInput
    upsert?: ClassUpsertWithoutAssignmentsInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutAssignmentsInput, ClassUpdateWithoutAssignmentsInput>, ClassUncheckedUpdateWithoutAssignmentsInput>
  }

  export type SubjectUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<SubjectCreateWithoutAssignmentsInput, SubjectUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutAssignmentsInput
    upsert?: SubjectUpsertWithoutAssignmentsInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutAssignmentsInput, SubjectUpdateWithoutAssignmentsInput>, SubjectUncheckedUpdateWithoutAssignmentsInput>
  }

  export type TeacherUpdateOneRequiredWithoutAssignmentsCreatedNestedInput = {
    create?: XOR<TeacherCreateWithoutAssignmentsCreatedInput, TeacherUncheckedCreateWithoutAssignmentsCreatedInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutAssignmentsCreatedInput
    upsert?: TeacherUpsertWithoutAssignmentsCreatedInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutAssignmentsCreatedInput, TeacherUpdateWithoutAssignmentsCreatedInput>, TeacherUncheckedUpdateWithoutAssignmentsCreatedInput>
  }

  export type StudentGradeUpdateManyWithoutAssignmentNestedInput = {
    create?: XOR<StudentGradeCreateWithoutAssignmentInput, StudentGradeUncheckedCreateWithoutAssignmentInput> | StudentGradeCreateWithoutAssignmentInput[] | StudentGradeUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: StudentGradeCreateOrConnectWithoutAssignmentInput | StudentGradeCreateOrConnectWithoutAssignmentInput[]
    upsert?: StudentGradeUpsertWithWhereUniqueWithoutAssignmentInput | StudentGradeUpsertWithWhereUniqueWithoutAssignmentInput[]
    createMany?: StudentGradeCreateManyAssignmentInputEnvelope
    set?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
    disconnect?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
    delete?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
    connect?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
    update?: StudentGradeUpdateWithWhereUniqueWithoutAssignmentInput | StudentGradeUpdateWithWhereUniqueWithoutAssignmentInput[]
    updateMany?: StudentGradeUpdateManyWithWhereWithoutAssignmentInput | StudentGradeUpdateManyWithWhereWithoutAssignmentInput[]
    deleteMany?: StudentGradeScalarWhereInput | StudentGradeScalarWhereInput[]
  }

  export type StudentGradeUncheckedUpdateManyWithoutAssignmentNestedInput = {
    create?: XOR<StudentGradeCreateWithoutAssignmentInput, StudentGradeUncheckedCreateWithoutAssignmentInput> | StudentGradeCreateWithoutAssignmentInput[] | StudentGradeUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: StudentGradeCreateOrConnectWithoutAssignmentInput | StudentGradeCreateOrConnectWithoutAssignmentInput[]
    upsert?: StudentGradeUpsertWithWhereUniqueWithoutAssignmentInput | StudentGradeUpsertWithWhereUniqueWithoutAssignmentInput[]
    createMany?: StudentGradeCreateManyAssignmentInputEnvelope
    set?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
    disconnect?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
    delete?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
    connect?: StudentGradeWhereUniqueInput | StudentGradeWhereUniqueInput[]
    update?: StudentGradeUpdateWithWhereUniqueWithoutAssignmentInput | StudentGradeUpdateWithWhereUniqueWithoutAssignmentInput[]
    updateMany?: StudentGradeUpdateManyWithWhereWithoutAssignmentInput | StudentGradeUpdateManyWithWhereWithoutAssignmentInput[]
    deleteMany?: StudentGradeScalarWhereInput | StudentGradeScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutGradesInput = {
    create?: XOR<StudentCreateWithoutGradesInput, StudentUncheckedCreateWithoutGradesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutGradesInput
    connect?: StudentWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutGradesInput = {
    create?: XOR<SubjectCreateWithoutGradesInput, SubjectUncheckedCreateWithoutGradesInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutGradesInput
    connect?: SubjectWhereUniqueInput
  }

  export type AssignmentCreateNestedOneWithoutGradesInput = {
    create?: XOR<AssignmentCreateWithoutGradesInput, AssignmentUncheckedCreateWithoutGradesInput>
    connectOrCreate?: AssignmentCreateOrConnectWithoutGradesInput
    connect?: AssignmentWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutGradesGivenInput = {
    create?: XOR<TeacherCreateWithoutGradesGivenInput, TeacherUncheckedCreateWithoutGradesGivenInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutGradesGivenInput
    connect?: TeacherWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutGradesNestedInput = {
    create?: XOR<StudentCreateWithoutGradesInput, StudentUncheckedCreateWithoutGradesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutGradesInput
    upsert?: StudentUpsertWithoutGradesInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutGradesInput, StudentUpdateWithoutGradesInput>, StudentUncheckedUpdateWithoutGradesInput>
  }

  export type SubjectUpdateOneRequiredWithoutGradesNestedInput = {
    create?: XOR<SubjectCreateWithoutGradesInput, SubjectUncheckedCreateWithoutGradesInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutGradesInput
    upsert?: SubjectUpsertWithoutGradesInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutGradesInput, SubjectUpdateWithoutGradesInput>, SubjectUncheckedUpdateWithoutGradesInput>
  }

  export type AssignmentUpdateOneWithoutGradesNestedInput = {
    create?: XOR<AssignmentCreateWithoutGradesInput, AssignmentUncheckedCreateWithoutGradesInput>
    connectOrCreate?: AssignmentCreateOrConnectWithoutGradesInput
    upsert?: AssignmentUpsertWithoutGradesInput
    disconnect?: AssignmentWhereInput | boolean
    delete?: AssignmentWhereInput | boolean
    connect?: AssignmentWhereUniqueInput
    update?: XOR<XOR<AssignmentUpdateToOneWithWhereWithoutGradesInput, AssignmentUpdateWithoutGradesInput>, AssignmentUncheckedUpdateWithoutGradesInput>
  }

  export type TeacherUpdateOneWithoutGradesGivenNestedInput = {
    create?: XOR<TeacherCreateWithoutGradesGivenInput, TeacherUncheckedCreateWithoutGradesGivenInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutGradesGivenInput
    upsert?: TeacherUpsertWithoutGradesGivenInput
    disconnect?: TeacherWhereInput | boolean
    delete?: TeacherWhereInput | boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutGradesGivenInput, TeacherUpdateWithoutGradesGivenInput>, TeacherUncheckedUpdateWithoutGradesGivenInput>
  }

  export type SchoolCreateNestedOneWithoutFeeStructuresInput = {
    create?: XOR<SchoolCreateWithoutFeeStructuresInput, SchoolUncheckedCreateWithoutFeeStructuresInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutFeeStructuresInput
    connect?: SchoolWhereUniqueInput
  }

  export type InvoiceLineItemCreateNestedManyWithoutFeeStructureInput = {
    create?: XOR<InvoiceLineItemCreateWithoutFeeStructureInput, InvoiceLineItemUncheckedCreateWithoutFeeStructureInput> | InvoiceLineItemCreateWithoutFeeStructureInput[] | InvoiceLineItemUncheckedCreateWithoutFeeStructureInput[]
    connectOrCreate?: InvoiceLineItemCreateOrConnectWithoutFeeStructureInput | InvoiceLineItemCreateOrConnectWithoutFeeStructureInput[]
    createMany?: InvoiceLineItemCreateManyFeeStructureInputEnvelope
    connect?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
  }

  export type InvoiceLineItemUncheckedCreateNestedManyWithoutFeeStructureInput = {
    create?: XOR<InvoiceLineItemCreateWithoutFeeStructureInput, InvoiceLineItemUncheckedCreateWithoutFeeStructureInput> | InvoiceLineItemCreateWithoutFeeStructureInput[] | InvoiceLineItemUncheckedCreateWithoutFeeStructureInput[]
    connectOrCreate?: InvoiceLineItemCreateOrConnectWithoutFeeStructureInput | InvoiceLineItemCreateOrConnectWithoutFeeStructureInput[]
    createMany?: InvoiceLineItemCreateManyFeeStructureInputEnvelope
    connect?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type SchoolUpdateOneRequiredWithoutFeeStructuresNestedInput = {
    create?: XOR<SchoolCreateWithoutFeeStructuresInput, SchoolUncheckedCreateWithoutFeeStructuresInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutFeeStructuresInput
    upsert?: SchoolUpsertWithoutFeeStructuresInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutFeeStructuresInput, SchoolUpdateWithoutFeeStructuresInput>, SchoolUncheckedUpdateWithoutFeeStructuresInput>
  }

  export type InvoiceLineItemUpdateManyWithoutFeeStructureNestedInput = {
    create?: XOR<InvoiceLineItemCreateWithoutFeeStructureInput, InvoiceLineItemUncheckedCreateWithoutFeeStructureInput> | InvoiceLineItemCreateWithoutFeeStructureInput[] | InvoiceLineItemUncheckedCreateWithoutFeeStructureInput[]
    connectOrCreate?: InvoiceLineItemCreateOrConnectWithoutFeeStructureInput | InvoiceLineItemCreateOrConnectWithoutFeeStructureInput[]
    upsert?: InvoiceLineItemUpsertWithWhereUniqueWithoutFeeStructureInput | InvoiceLineItemUpsertWithWhereUniqueWithoutFeeStructureInput[]
    createMany?: InvoiceLineItemCreateManyFeeStructureInputEnvelope
    set?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
    disconnect?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
    delete?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
    connect?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
    update?: InvoiceLineItemUpdateWithWhereUniqueWithoutFeeStructureInput | InvoiceLineItemUpdateWithWhereUniqueWithoutFeeStructureInput[]
    updateMany?: InvoiceLineItemUpdateManyWithWhereWithoutFeeStructureInput | InvoiceLineItemUpdateManyWithWhereWithoutFeeStructureInput[]
    deleteMany?: InvoiceLineItemScalarWhereInput | InvoiceLineItemScalarWhereInput[]
  }

  export type InvoiceLineItemUncheckedUpdateManyWithoutFeeStructureNestedInput = {
    create?: XOR<InvoiceLineItemCreateWithoutFeeStructureInput, InvoiceLineItemUncheckedCreateWithoutFeeStructureInput> | InvoiceLineItemCreateWithoutFeeStructureInput[] | InvoiceLineItemUncheckedCreateWithoutFeeStructureInput[]
    connectOrCreate?: InvoiceLineItemCreateOrConnectWithoutFeeStructureInput | InvoiceLineItemCreateOrConnectWithoutFeeStructureInput[]
    upsert?: InvoiceLineItemUpsertWithWhereUniqueWithoutFeeStructureInput | InvoiceLineItemUpsertWithWhereUniqueWithoutFeeStructureInput[]
    createMany?: InvoiceLineItemCreateManyFeeStructureInputEnvelope
    set?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
    disconnect?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
    delete?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
    connect?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
    update?: InvoiceLineItemUpdateWithWhereUniqueWithoutFeeStructureInput | InvoiceLineItemUpdateWithWhereUniqueWithoutFeeStructureInput[]
    updateMany?: InvoiceLineItemUpdateManyWithWhereWithoutFeeStructureInput | InvoiceLineItemUpdateManyWithWhereWithoutFeeStructureInput[]
    deleteMany?: InvoiceLineItemScalarWhereInput | InvoiceLineItemScalarWhereInput[]
  }

  export type SchoolCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<SchoolCreateWithoutInvoicesInput, SchoolUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutInvoicesInput
    connect?: SchoolWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<StudentCreateWithoutInvoicesInput, StudentUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutInvoicesInput
    connect?: StudentWhereUniqueInput
  }

  export type ParentCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<ParentCreateWithoutInvoicesInput, ParentUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: ParentCreateOrConnectWithoutInvoicesInput
    connect?: ParentWhereUniqueInput
  }

  export type InvoiceLineItemCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceLineItemCreateWithoutInvoiceInput, InvoiceLineItemUncheckedCreateWithoutInvoiceInput> | InvoiceLineItemCreateWithoutInvoiceInput[] | InvoiceLineItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceLineItemCreateOrConnectWithoutInvoiceInput | InvoiceLineItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceLineItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type InvoiceLineItemUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceLineItemCreateWithoutInvoiceInput, InvoiceLineItemUncheckedCreateWithoutInvoiceInput> | InvoiceLineItemCreateWithoutInvoiceInput[] | InvoiceLineItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceLineItemCreateOrConnectWithoutInvoiceInput | InvoiceLineItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceLineItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type SchoolUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<SchoolCreateWithoutInvoicesInput, SchoolUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutInvoicesInput
    upsert?: SchoolUpsertWithoutInvoicesInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutInvoicesInput, SchoolUpdateWithoutInvoicesInput>, SchoolUncheckedUpdateWithoutInvoicesInput>
  }

  export type StudentUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<StudentCreateWithoutInvoicesInput, StudentUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutInvoicesInput
    upsert?: StudentUpsertWithoutInvoicesInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutInvoicesInput, StudentUpdateWithoutInvoicesInput>, StudentUncheckedUpdateWithoutInvoicesInput>
  }

  export type ParentUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<ParentCreateWithoutInvoicesInput, ParentUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: ParentCreateOrConnectWithoutInvoicesInput
    upsert?: ParentUpsertWithoutInvoicesInput
    disconnect?: ParentWhereInput | boolean
    delete?: ParentWhereInput | boolean
    connect?: ParentWhereUniqueInput
    update?: XOR<XOR<ParentUpdateToOneWithWhereWithoutInvoicesInput, ParentUpdateWithoutInvoicesInput>, ParentUncheckedUpdateWithoutInvoicesInput>
  }

  export type InvoiceLineItemUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceLineItemCreateWithoutInvoiceInput, InvoiceLineItemUncheckedCreateWithoutInvoiceInput> | InvoiceLineItemCreateWithoutInvoiceInput[] | InvoiceLineItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceLineItemCreateOrConnectWithoutInvoiceInput | InvoiceLineItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceLineItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceLineItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceLineItemCreateManyInvoiceInputEnvelope
    set?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
    disconnect?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
    delete?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
    connect?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
    update?: InvoiceLineItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceLineItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceLineItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceLineItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceLineItemScalarWhereInput | InvoiceLineItemScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type InvoiceLineItemUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceLineItemCreateWithoutInvoiceInput, InvoiceLineItemUncheckedCreateWithoutInvoiceInput> | InvoiceLineItemCreateWithoutInvoiceInput[] | InvoiceLineItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceLineItemCreateOrConnectWithoutInvoiceInput | InvoiceLineItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceLineItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceLineItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceLineItemCreateManyInvoiceInputEnvelope
    set?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
    disconnect?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
    delete?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
    connect?: InvoiceLineItemWhereUniqueInput | InvoiceLineItemWhereUniqueInput[]
    update?: InvoiceLineItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceLineItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceLineItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceLineItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceLineItemScalarWhereInput | InvoiceLineItemScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutLineItemsInput = {
    create?: XOR<InvoiceCreateWithoutLineItemsInput, InvoiceUncheckedCreateWithoutLineItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutLineItemsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type FeeStructureCreateNestedOneWithoutInvoiceLineItemsInput = {
    create?: XOR<FeeStructureCreateWithoutInvoiceLineItemsInput, FeeStructureUncheckedCreateWithoutInvoiceLineItemsInput>
    connectOrCreate?: FeeStructureCreateOrConnectWithoutInvoiceLineItemsInput
    connect?: FeeStructureWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutInvoiceLineItemsInput = {
    create?: XOR<StudentCreateWithoutInvoiceLineItemsInput, StudentUncheckedCreateWithoutInvoiceLineItemsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutInvoiceLineItemsInput
    connect?: StudentWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type InvoiceUpdateOneRequiredWithoutLineItemsNestedInput = {
    create?: XOR<InvoiceCreateWithoutLineItemsInput, InvoiceUncheckedCreateWithoutLineItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutLineItemsInput
    upsert?: InvoiceUpsertWithoutLineItemsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutLineItemsInput, InvoiceUpdateWithoutLineItemsInput>, InvoiceUncheckedUpdateWithoutLineItemsInput>
  }

  export type FeeStructureUpdateOneWithoutInvoiceLineItemsNestedInput = {
    create?: XOR<FeeStructureCreateWithoutInvoiceLineItemsInput, FeeStructureUncheckedCreateWithoutInvoiceLineItemsInput>
    connectOrCreate?: FeeStructureCreateOrConnectWithoutInvoiceLineItemsInput
    upsert?: FeeStructureUpsertWithoutInvoiceLineItemsInput
    disconnect?: FeeStructureWhereInput | boolean
    delete?: FeeStructureWhereInput | boolean
    connect?: FeeStructureWhereUniqueInput
    update?: XOR<XOR<FeeStructureUpdateToOneWithWhereWithoutInvoiceLineItemsInput, FeeStructureUpdateWithoutInvoiceLineItemsInput>, FeeStructureUncheckedUpdateWithoutInvoiceLineItemsInput>
  }

  export type StudentUpdateOneRequiredWithoutInvoiceLineItemsNestedInput = {
    create?: XOR<StudentCreateWithoutInvoiceLineItemsInput, StudentUncheckedCreateWithoutInvoiceLineItemsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutInvoiceLineItemsInput
    upsert?: StudentUpsertWithoutInvoiceLineItemsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutInvoiceLineItemsInput, StudentUpdateWithoutInvoiceLineItemsInput>, StudentUncheckedUpdateWithoutInvoiceLineItemsInput>
  }

  export type InvoiceCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRecordedPaymentsInput = {
    create?: XOR<UserCreateWithoutRecordedPaymentsInput, UserUncheckedCreateWithoutRecordedPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecordedPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type InvoiceUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    upsert?: InvoiceUpsertWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutPaymentsInput, InvoiceUpdateWithoutPaymentsInput>, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateOneWithoutRecordedPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutRecordedPaymentsInput, UserUncheckedCreateWithoutRecordedPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecordedPaymentsInput
    upsert?: UserUpsertWithoutRecordedPaymentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRecordedPaymentsInput, UserUpdateWithoutRecordedPaymentsInput>, UserUncheckedUpdateWithoutRecordedPaymentsInput>
  }

  export type SchoolCreateNestedOneWithoutAnnouncementsInput = {
    create?: XOR<SchoolCreateWithoutAnnouncementsInput, SchoolUncheckedCreateWithoutAnnouncementsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutAnnouncementsInput
    connect?: SchoolWhereUniqueInput
  }

  export type SchoolAdminCreateNestedOneWithoutCreatedSchoolAnnouncementsInput = {
    create?: XOR<SchoolAdminCreateWithoutCreatedSchoolAnnouncementsInput, SchoolAdminUncheckedCreateWithoutCreatedSchoolAnnouncementsInput>
    connectOrCreate?: SchoolAdminCreateOrConnectWithoutCreatedSchoolAnnouncementsInput
    connect?: SchoolAdminWhereUniqueInput
  }

  export type SchoolUpdateOneRequiredWithoutAnnouncementsNestedInput = {
    create?: XOR<SchoolCreateWithoutAnnouncementsInput, SchoolUncheckedCreateWithoutAnnouncementsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutAnnouncementsInput
    upsert?: SchoolUpsertWithoutAnnouncementsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutAnnouncementsInput, SchoolUpdateWithoutAnnouncementsInput>, SchoolUncheckedUpdateWithoutAnnouncementsInput>
  }

  export type SchoolAdminUpdateOneWithoutCreatedSchoolAnnouncementsNestedInput = {
    create?: XOR<SchoolAdminCreateWithoutCreatedSchoolAnnouncementsInput, SchoolAdminUncheckedCreateWithoutCreatedSchoolAnnouncementsInput>
    connectOrCreate?: SchoolAdminCreateOrConnectWithoutCreatedSchoolAnnouncementsInput
    upsert?: SchoolAdminUpsertWithoutCreatedSchoolAnnouncementsInput
    disconnect?: SchoolAdminWhereInput | boolean
    delete?: SchoolAdminWhereInput | boolean
    connect?: SchoolAdminWhereUniqueInput
    update?: XOR<XOR<SchoolAdminUpdateToOneWithWhereWithoutCreatedSchoolAnnouncementsInput, SchoolAdminUpdateWithoutCreatedSchoolAnnouncementsInput>, SchoolAdminUncheckedUpdateWithoutCreatedSchoolAnnouncementsInput>
  }

  export type SchoolCreateNestedOneWithoutClassAnnouncementsInput = {
    create?: XOR<SchoolCreateWithoutClassAnnouncementsInput, SchoolUncheckedCreateWithoutClassAnnouncementsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutClassAnnouncementsInput
    connect?: SchoolWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutAnnouncementsInput = {
    create?: XOR<ClassCreateWithoutAnnouncementsInput, ClassUncheckedCreateWithoutAnnouncementsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutAnnouncementsInput
    connect?: ClassWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutCreatedClassAnnouncementsInput = {
    create?: XOR<TeacherCreateWithoutCreatedClassAnnouncementsInput, TeacherUncheckedCreateWithoutCreatedClassAnnouncementsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutCreatedClassAnnouncementsInput
    connect?: TeacherWhereUniqueInput
  }

  export type SchoolUpdateOneRequiredWithoutClassAnnouncementsNestedInput = {
    create?: XOR<SchoolCreateWithoutClassAnnouncementsInput, SchoolUncheckedCreateWithoutClassAnnouncementsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutClassAnnouncementsInput
    upsert?: SchoolUpsertWithoutClassAnnouncementsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutClassAnnouncementsInput, SchoolUpdateWithoutClassAnnouncementsInput>, SchoolUncheckedUpdateWithoutClassAnnouncementsInput>
  }

  export type ClassUpdateOneRequiredWithoutAnnouncementsNestedInput = {
    create?: XOR<ClassCreateWithoutAnnouncementsInput, ClassUncheckedCreateWithoutAnnouncementsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutAnnouncementsInput
    upsert?: ClassUpsertWithoutAnnouncementsInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutAnnouncementsInput, ClassUpdateWithoutAnnouncementsInput>, ClassUncheckedUpdateWithoutAnnouncementsInput>
  }

  export type TeacherUpdateOneWithoutCreatedClassAnnouncementsNestedInput = {
    create?: XOR<TeacherCreateWithoutCreatedClassAnnouncementsInput, TeacherUncheckedCreateWithoutCreatedClassAnnouncementsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutCreatedClassAnnouncementsInput
    upsert?: TeacherUpsertWithoutCreatedClassAnnouncementsInput
    disconnect?: TeacherWhereInput | boolean
    delete?: TeacherWhereInput | boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutCreatedClassAnnouncementsInput, TeacherUpdateWithoutCreatedClassAnnouncementsInput>, TeacherUncheckedUpdateWithoutCreatedClassAnnouncementsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumTermPeriodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TermPeriod | EnumTermPeriodFieldRefInput<$PrismaModel> | null
    in?: $Enums.TermPeriod[] | null
    notIn?: $Enums.TermPeriod[] | null
    not?: NestedEnumTermPeriodNullableFilter<$PrismaModel> | $Enums.TermPeriod | null
  }

  export type NestedEnumTermPeriodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TermPeriod | EnumTermPeriodFieldRefInput<$PrismaModel> | null
    in?: $Enums.TermPeriod[] | null
    notIn?: $Enums.TermPeriod[] | null
    not?: NestedEnumTermPeriodNullableWithAggregatesFilter<$PrismaModel> | $Enums.TermPeriod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTermPeriodNullableFilter<$PrismaModel>
    _max?: NestedEnumTermPeriodNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[]
    notIn?: $Enums.Gender[]
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type NestedEnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[]
    notIn?: $Enums.Gender[]
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type NestedEnumDayOfWeekFilter<$PrismaModel = never> = {
    equals?: $Enums.DayOfWeek | EnumDayOfWeekFieldRefInput<$PrismaModel>
    in?: $Enums.DayOfWeek[]
    notIn?: $Enums.DayOfWeek[]
    not?: NestedEnumDayOfWeekFilter<$PrismaModel> | $Enums.DayOfWeek
  }

  export type NestedEnumDayOfWeekWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DayOfWeek | EnumDayOfWeekFieldRefInput<$PrismaModel>
    in?: $Enums.DayOfWeek[]
    notIn?: $Enums.DayOfWeek[]
    not?: NestedEnumDayOfWeekWithAggregatesFilter<$PrismaModel> | $Enums.DayOfWeek
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDayOfWeekFilter<$PrismaModel>
    _max?: NestedEnumDayOfWeekFilter<$PrismaModel>
  }

  export type NestedEnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[]
    notIn?: $Enums.AttendanceStatus[]
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type NestedEnumTermPeriodFilter<$PrismaModel = never> = {
    equals?: $Enums.TermPeriod | EnumTermPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.TermPeriod[]
    notIn?: $Enums.TermPeriod[]
    not?: NestedEnumTermPeriodFilter<$PrismaModel> | $Enums.TermPeriod
  }

  export type NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[]
    notIn?: $Enums.AttendanceStatus[]
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type NestedEnumTermPeriodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TermPeriod | EnumTermPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.TermPeriod[]
    notIn?: $Enums.TermPeriod[]
    not?: NestedEnumTermPeriodWithAggregatesFilter<$PrismaModel> | $Enums.TermPeriod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTermPeriodFilter<$PrismaModel>
    _max?: NestedEnumTermPeriodFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[]
    notIn?: $Enums.PaymentStatus[]
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[]
    notIn?: $Enums.PaymentStatus[]
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SuperAdminCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schoolsCreated?: SchoolCreateNestedManyWithoutCreatedBySuperAdminInput
  }

  export type SuperAdminUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schoolsCreated?: SchoolUncheckedCreateNestedManyWithoutCreatedBySuperAdminInput
  }

  export type SuperAdminCreateOrConnectWithoutUserInput = {
    where: SuperAdminWhereUniqueInput
    create: XOR<SuperAdminCreateWithoutUserInput, SuperAdminUncheckedCreateWithoutUserInput>
  }

  export type SchoolAdminCreateWithoutUserInput = {
    id?: string
    jobTitle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutAdminsInput
    createdSchoolAnnouncements?: SchoolAnnouncementCreateNestedManyWithoutCreatedByAdminInput
  }

  export type SchoolAdminUncheckedCreateWithoutUserInput = {
    id?: string
    schoolId: string
    jobTitle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdSchoolAnnouncements?: SchoolAnnouncementUncheckedCreateNestedManyWithoutCreatedByAdminInput
  }

  export type SchoolAdminCreateOrConnectWithoutUserInput = {
    where: SchoolAdminWhereUniqueInput
    create: XOR<SchoolAdminCreateWithoutUserInput, SchoolAdminUncheckedCreateWithoutUserInput>
  }

  export type SchoolAdminCreateManyUserInputEnvelope = {
    data: SchoolAdminCreateManyUserInput | SchoolAdminCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TeacherCreateWithoutUserInput = {
    id?: string
    teacherIdNumber?: string | null
    dateOfJoining?: Date | string | null
    qualifications?: string | null
    specialization?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutTeachersInput
    classTeacherOf?: ClassCreateNestedManyWithoutHomeroomTeacherInput
    timetableSlots?: TimetableSlotCreateNestedManyWithoutTeacherInput
    gradesGiven?: StudentGradeCreateNestedManyWithoutTeacherInput
    assignmentsCreated?: AssignmentCreateNestedManyWithoutTeacherInput
    createdClassAnnouncements?: ClassAnnouncementCreateNestedManyWithoutCreatedByTeacherInput
  }

  export type TeacherUncheckedCreateWithoutUserInput = {
    id?: string
    schoolId: string
    teacherIdNumber?: string | null
    dateOfJoining?: Date | string | null
    qualifications?: string | null
    specialization?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classTeacherOf?: ClassUncheckedCreateNestedManyWithoutHomeroomTeacherInput
    timetableSlots?: TimetableSlotUncheckedCreateNestedManyWithoutTeacherInput
    gradesGiven?: StudentGradeUncheckedCreateNestedManyWithoutTeacherInput
    assignmentsCreated?: AssignmentUncheckedCreateNestedManyWithoutTeacherInput
    createdClassAnnouncements?: ClassAnnouncementUncheckedCreateNestedManyWithoutCreatedByTeacherInput
  }

  export type TeacherCreateOrConnectWithoutUserInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
  }

  export type TeacherCreateManyUserInputEnvelope = {
    data: TeacherCreateManyUserInput | TeacherCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutUserInput = {
    id?: string
    studentIdNumber: string
    firstName: string
    lastName: string
    middleName?: string | null
    dateOfBirth: Date | string
    gender: $Enums.Gender
    enrollmentDate: Date | string
    profilePictureUrl?: string | null
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    bloodGroup?: string | null
    allergies?: string | null
    medicalNotes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutStudentsInput
    currentClass?: ClassCreateNestedOneWithoutCurrentStudentsInput
    parents?: StudentParentLinkCreateNestedManyWithoutStudentInput
    enrollments?: StudentClassEnrollmentCreateNestedManyWithoutStudentInput
    attendances?: StudentAttendanceCreateNestedManyWithoutStudentInput
    grades?: StudentGradeCreateNestedManyWithoutStudentInput
    invoiceLineItems?: InvoiceLineItemCreateNestedManyWithoutStudentInput
    invoices?: InvoiceCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutUserInput = {
    id?: string
    schoolId: string
    studentIdNumber: string
    firstName: string
    lastName: string
    middleName?: string | null
    dateOfBirth: Date | string
    gender: $Enums.Gender
    enrollmentDate: Date | string
    profilePictureUrl?: string | null
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    bloodGroup?: string | null
    allergies?: string | null
    medicalNotes?: string | null
    isActive?: boolean
    currentClassId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: StudentParentLinkUncheckedCreateNestedManyWithoutStudentInput
    enrollments?: StudentClassEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    attendances?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    grades?: StudentGradeUncheckedCreateNestedManyWithoutStudentInput
    invoiceLineItems?: InvoiceLineItemUncheckedCreateNestedManyWithoutStudentInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutUserInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
  }

  export type ParentCreateWithoutUserInput = {
    id?: string
    occupation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: StudentParentLinkCreateNestedManyWithoutParentInput
    invoices?: InvoiceCreateNestedManyWithoutParentToBillInput
  }

  export type ParentUncheckedCreateWithoutUserInput = {
    id?: string
    occupation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: StudentParentLinkUncheckedCreateNestedManyWithoutParentInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutParentToBillInput
  }

  export type ParentCreateOrConnectWithoutUserInput = {
    where: ParentWhereUniqueInput
    create: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
  }

  export type StudentAttendanceCreateWithoutRecordedByInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    classId?: string | null
    subjectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutAttendancesInput
    timetableSlot?: TimetableSlotCreateNestedOneWithoutAttendancesInput
  }

  export type StudentAttendanceUncheckedCreateWithoutRecordedByInput = {
    id?: string
    studentId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    classId?: string | null
    subjectId?: string | null
    timetableSlotId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAttendanceCreateOrConnectWithoutRecordedByInput = {
    where: StudentAttendanceWhereUniqueInput
    create: XOR<StudentAttendanceCreateWithoutRecordedByInput, StudentAttendanceUncheckedCreateWithoutRecordedByInput>
  }

  export type StudentAttendanceCreateManyRecordedByInputEnvelope = {
    data: StudentAttendanceCreateManyRecordedByInput | StudentAttendanceCreateManyRecordedByInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutRecordedByInput = {
    id?: string
    paymentDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutRecordedByInput = {
    id?: string
    invoiceId: string
    paymentDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutRecordedByInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutRecordedByInput, PaymentUncheckedCreateWithoutRecordedByInput>
  }

  export type PaymentCreateManyRecordedByInputEnvelope = {
    data: PaymentCreateManyRecordedByInput | PaymentCreateManyRecordedByInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type SuperAdminUpsertWithoutUserInput = {
    update: XOR<SuperAdminUpdateWithoutUserInput, SuperAdminUncheckedUpdateWithoutUserInput>
    create: XOR<SuperAdminCreateWithoutUserInput, SuperAdminUncheckedCreateWithoutUserInput>
    where?: SuperAdminWhereInput
  }

  export type SuperAdminUpdateToOneWithWhereWithoutUserInput = {
    where?: SuperAdminWhereInput
    data: XOR<SuperAdminUpdateWithoutUserInput, SuperAdminUncheckedUpdateWithoutUserInput>
  }

  export type SuperAdminUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolsCreated?: SchoolUpdateManyWithoutCreatedBySuperAdminNestedInput
  }

  export type SuperAdminUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolsCreated?: SchoolUncheckedUpdateManyWithoutCreatedBySuperAdminNestedInput
  }

  export type SchoolAdminUpsertWithWhereUniqueWithoutUserInput = {
    where: SchoolAdminWhereUniqueInput
    update: XOR<SchoolAdminUpdateWithoutUserInput, SchoolAdminUncheckedUpdateWithoutUserInput>
    create: XOR<SchoolAdminCreateWithoutUserInput, SchoolAdminUncheckedCreateWithoutUserInput>
  }

  export type SchoolAdminUpdateWithWhereUniqueWithoutUserInput = {
    where: SchoolAdminWhereUniqueInput
    data: XOR<SchoolAdminUpdateWithoutUserInput, SchoolAdminUncheckedUpdateWithoutUserInput>
  }

  export type SchoolAdminUpdateManyWithWhereWithoutUserInput = {
    where: SchoolAdminScalarWhereInput
    data: XOR<SchoolAdminUpdateManyMutationInput, SchoolAdminUncheckedUpdateManyWithoutUserInput>
  }

  export type SchoolAdminScalarWhereInput = {
    AND?: SchoolAdminScalarWhereInput | SchoolAdminScalarWhereInput[]
    OR?: SchoolAdminScalarWhereInput[]
    NOT?: SchoolAdminScalarWhereInput | SchoolAdminScalarWhereInput[]
    id?: StringFilter<"SchoolAdmin"> | string
    userId?: StringFilter<"SchoolAdmin"> | string
    schoolId?: StringFilter<"SchoolAdmin"> | string
    jobTitle?: StringNullableFilter<"SchoolAdmin"> | string | null
    createdAt?: DateTimeFilter<"SchoolAdmin"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolAdmin"> | Date | string
  }

  export type TeacherUpsertWithWhereUniqueWithoutUserInput = {
    where: TeacherWhereUniqueInput
    update: XOR<TeacherUpdateWithoutUserInput, TeacherUncheckedUpdateWithoutUserInput>
    create: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
  }

  export type TeacherUpdateWithWhereUniqueWithoutUserInput = {
    where: TeacherWhereUniqueInput
    data: XOR<TeacherUpdateWithoutUserInput, TeacherUncheckedUpdateWithoutUserInput>
  }

  export type TeacherUpdateManyWithWhereWithoutUserInput = {
    where: TeacherScalarWhereInput
    data: XOR<TeacherUpdateManyMutationInput, TeacherUncheckedUpdateManyWithoutUserInput>
  }

  export type TeacherScalarWhereInput = {
    AND?: TeacherScalarWhereInput | TeacherScalarWhereInput[]
    OR?: TeacherScalarWhereInput[]
    NOT?: TeacherScalarWhereInput | TeacherScalarWhereInput[]
    id?: StringFilter<"Teacher"> | string
    userId?: StringFilter<"Teacher"> | string
    schoolId?: StringFilter<"Teacher"> | string
    teacherIdNumber?: StringNullableFilter<"Teacher"> | string | null
    dateOfJoining?: DateTimeNullableFilter<"Teacher"> | Date | string | null
    qualifications?: StringNullableFilter<"Teacher"> | string | null
    specialization?: StringNullableFilter<"Teacher"> | string | null
    createdAt?: DateTimeFilter<"Teacher"> | Date | string
    updatedAt?: DateTimeFilter<"Teacher"> | Date | string
  }

  export type StudentUpsertWithoutUserInput = {
    update: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutUserInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
  }

  export type StudentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentIdNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutStudentsNestedInput
    currentClass?: ClassUpdateOneWithoutCurrentStudentsNestedInput
    parents?: StudentParentLinkUpdateManyWithoutStudentNestedInput
    enrollments?: StudentClassEnrollmentUpdateManyWithoutStudentNestedInput
    attendances?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    grades?: StudentGradeUpdateManyWithoutStudentNestedInput
    invoiceLineItems?: InvoiceLineItemUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    studentIdNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    currentClassId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: StudentParentLinkUncheckedUpdateManyWithoutStudentNestedInput
    enrollments?: StudentClassEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    grades?: StudentGradeUncheckedUpdateManyWithoutStudentNestedInput
    invoiceLineItems?: InvoiceLineItemUncheckedUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ParentUpsertWithoutUserInput = {
    update: XOR<ParentUpdateWithoutUserInput, ParentUncheckedUpdateWithoutUserInput>
    create: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    where?: ParentWhereInput
  }

  export type ParentUpdateToOneWithWhereWithoutUserInput = {
    where?: ParentWhereInput
    data: XOR<ParentUpdateWithoutUserInput, ParentUncheckedUpdateWithoutUserInput>
  }

  export type ParentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: StudentParentLinkUpdateManyWithoutParentNestedInput
    invoices?: InvoiceUpdateManyWithoutParentToBillNestedInput
  }

  export type ParentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: StudentParentLinkUncheckedUpdateManyWithoutParentNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutParentToBillNestedInput
  }

  export type StudentAttendanceUpsertWithWhereUniqueWithoutRecordedByInput = {
    where: StudentAttendanceWhereUniqueInput
    update: XOR<StudentAttendanceUpdateWithoutRecordedByInput, StudentAttendanceUncheckedUpdateWithoutRecordedByInput>
    create: XOR<StudentAttendanceCreateWithoutRecordedByInput, StudentAttendanceUncheckedCreateWithoutRecordedByInput>
  }

  export type StudentAttendanceUpdateWithWhereUniqueWithoutRecordedByInput = {
    where: StudentAttendanceWhereUniqueInput
    data: XOR<StudentAttendanceUpdateWithoutRecordedByInput, StudentAttendanceUncheckedUpdateWithoutRecordedByInput>
  }

  export type StudentAttendanceUpdateManyWithWhereWithoutRecordedByInput = {
    where: StudentAttendanceScalarWhereInput
    data: XOR<StudentAttendanceUpdateManyMutationInput, StudentAttendanceUncheckedUpdateManyWithoutRecordedByInput>
  }

  export type StudentAttendanceScalarWhereInput = {
    AND?: StudentAttendanceScalarWhereInput | StudentAttendanceScalarWhereInput[]
    OR?: StudentAttendanceScalarWhereInput[]
    NOT?: StudentAttendanceScalarWhereInput | StudentAttendanceScalarWhereInput[]
    id?: StringFilter<"StudentAttendance"> | string
    studentId?: StringFilter<"StudentAttendance"> | string
    date?: DateTimeFilter<"StudentAttendance"> | Date | string
    status?: EnumAttendanceStatusFilter<"StudentAttendance"> | $Enums.AttendanceStatus
    remarks?: StringNullableFilter<"StudentAttendance"> | string | null
    academicYear?: StringFilter<"StudentAttendance"> | string
    term?: EnumTermPeriodFilter<"StudentAttendance"> | $Enums.TermPeriod
    classId?: StringNullableFilter<"StudentAttendance"> | string | null
    subjectId?: StringNullableFilter<"StudentAttendance"> | string | null
    timetableSlotId?: StringNullableFilter<"StudentAttendance"> | string | null
    recordedById?: StringNullableFilter<"StudentAttendance"> | string | null
    createdAt?: DateTimeFilter<"StudentAttendance"> | Date | string
    updatedAt?: DateTimeFilter<"StudentAttendance"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutRecordedByInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutRecordedByInput, PaymentUncheckedUpdateWithoutRecordedByInput>
    create: XOR<PaymentCreateWithoutRecordedByInput, PaymentUncheckedCreateWithoutRecordedByInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutRecordedByInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutRecordedByInput, PaymentUncheckedUpdateWithoutRecordedByInput>
  }

  export type PaymentUpdateManyWithWhereWithoutRecordedByInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutRecordedByInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    invoiceId?: StringFilter<"Payment"> | string
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFilter<"Payment"> | string
    reference?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    recordedById?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    email: string
    hashedPassword: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    profilePicture?: string | null
    isActive?: boolean
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    schoolAdmins?: SchoolAdminCreateNestedManyWithoutUserInput
    teacherLinks?: TeacherCreateNestedManyWithoutUserInput
    studentLink?: StudentCreateNestedOneWithoutUserInput
    parentLink?: ParentCreateNestedOneWithoutUserInput
    recordedAttendances?: StudentAttendanceCreateNestedManyWithoutRecordedByInput
    recordedPayments?: PaymentCreateNestedManyWithoutRecordedByInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    email: string
    hashedPassword: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    profilePicture?: string | null
    isActive?: boolean
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    schoolAdmins?: SchoolAdminUncheckedCreateNestedManyWithoutUserInput
    teacherLinks?: TeacherUncheckedCreateNestedManyWithoutUserInput
    studentLink?: StudentUncheckedCreateNestedOneWithoutUserInput
    parentLink?: ParentUncheckedCreateNestedOneWithoutUserInput
    recordedAttendances?: StudentAttendanceUncheckedCreateNestedManyWithoutRecordedByInput
    recordedPayments?: PaymentUncheckedCreateNestedManyWithoutRecordedByInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    schoolAdmins?: SchoolAdminUpdateManyWithoutUserNestedInput
    teacherLinks?: TeacherUpdateManyWithoutUserNestedInput
    studentLink?: StudentUpdateOneWithoutUserNestedInput
    parentLink?: ParentUpdateOneWithoutUserNestedInput
    recordedAttendances?: StudentAttendanceUpdateManyWithoutRecordedByNestedInput
    recordedPayments?: PaymentUpdateManyWithoutRecordedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    schoolAdmins?: SchoolAdminUncheckedUpdateManyWithoutUserNestedInput
    teacherLinks?: TeacherUncheckedUpdateManyWithoutUserNestedInput
    studentLink?: StudentUncheckedUpdateOneWithoutUserNestedInput
    parentLink?: ParentUncheckedUpdateOneWithoutUserNestedInput
    recordedAttendances?: StudentAttendanceUncheckedUpdateManyWithoutRecordedByNestedInput
    recordedPayments?: PaymentUncheckedUpdateManyWithoutRecordedByNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    hashedPassword: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    profilePicture?: string | null
    isActive?: boolean
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    schoolAdmins?: SchoolAdminCreateNestedManyWithoutUserInput
    teacherLinks?: TeacherCreateNestedManyWithoutUserInput
    studentLink?: StudentCreateNestedOneWithoutUserInput
    parentLink?: ParentCreateNestedOneWithoutUserInput
    recordedAttendances?: StudentAttendanceCreateNestedManyWithoutRecordedByInput
    recordedPayments?: PaymentCreateNestedManyWithoutRecordedByInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    hashedPassword: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    profilePicture?: string | null
    isActive?: boolean
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    schoolAdmins?: SchoolAdminUncheckedCreateNestedManyWithoutUserInput
    teacherLinks?: TeacherUncheckedCreateNestedManyWithoutUserInput
    studentLink?: StudentUncheckedCreateNestedOneWithoutUserInput
    parentLink?: ParentUncheckedCreateNestedOneWithoutUserInput
    recordedAttendances?: StudentAttendanceUncheckedCreateNestedManyWithoutRecordedByInput
    recordedPayments?: PaymentUncheckedCreateNestedManyWithoutRecordedByInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    schoolAdmins?: SchoolAdminUpdateManyWithoutUserNestedInput
    teacherLinks?: TeacherUpdateManyWithoutUserNestedInput
    studentLink?: StudentUpdateOneWithoutUserNestedInput
    parentLink?: ParentUpdateOneWithoutUserNestedInput
    recordedAttendances?: StudentAttendanceUpdateManyWithoutRecordedByNestedInput
    recordedPayments?: PaymentUpdateManyWithoutRecordedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    schoolAdmins?: SchoolAdminUncheckedUpdateManyWithoutUserNestedInput
    teacherLinks?: TeacherUncheckedUpdateManyWithoutUserNestedInput
    studentLink?: StudentUncheckedUpdateOneWithoutUserNestedInput
    parentLink?: ParentUncheckedUpdateOneWithoutUserNestedInput
    recordedAttendances?: StudentAttendanceUncheckedUpdateManyWithoutRecordedByNestedInput
    recordedPayments?: PaymentUncheckedUpdateManyWithoutRecordedByNestedInput
  }

  export type UserCreateWithoutSuperAdminInput = {
    id?: string
    email: string
    hashedPassword: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    profilePicture?: string | null
    isActive?: boolean
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    schoolAdmins?: SchoolAdminCreateNestedManyWithoutUserInput
    teacherLinks?: TeacherCreateNestedManyWithoutUserInput
    studentLink?: StudentCreateNestedOneWithoutUserInput
    parentLink?: ParentCreateNestedOneWithoutUserInput
    recordedAttendances?: StudentAttendanceCreateNestedManyWithoutRecordedByInput
    recordedPayments?: PaymentCreateNestedManyWithoutRecordedByInput
  }

  export type UserUncheckedCreateWithoutSuperAdminInput = {
    id?: string
    email: string
    hashedPassword: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    profilePicture?: string | null
    isActive?: boolean
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    schoolAdmins?: SchoolAdminUncheckedCreateNestedManyWithoutUserInput
    teacherLinks?: TeacherUncheckedCreateNestedManyWithoutUserInput
    studentLink?: StudentUncheckedCreateNestedOneWithoutUserInput
    parentLink?: ParentUncheckedCreateNestedOneWithoutUserInput
    recordedAttendances?: StudentAttendanceUncheckedCreateNestedManyWithoutRecordedByInput
    recordedPayments?: PaymentUncheckedCreateNestedManyWithoutRecordedByInput
  }

  export type UserCreateOrConnectWithoutSuperAdminInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSuperAdminInput, UserUncheckedCreateWithoutSuperAdminInput>
  }

  export type SchoolCreateWithoutCreatedBySuperAdminInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    schoolEmail: string
    website?: string | null
    logoUrl?: string | null
    currentAcademicYear?: string | null
    currentTerm?: $Enums.TermPeriod | null
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    admins?: SchoolAdminCreateNestedManyWithoutSchoolInput
    teachers?: TeacherCreateNestedManyWithoutSchoolInput
    students?: StudentCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    subjects?: SubjectCreateNestedManyWithoutSchoolInput
    feeStructures?: FeeStructureCreateNestedManyWithoutSchoolInput
    invoices?: InvoiceCreateNestedManyWithoutSchoolInput
    timetableSlots?: TimetableSlotCreateNestedManyWithoutSchoolInput
    announcements?: SchoolAnnouncementCreateNestedManyWithoutSchoolInput
    classAnnouncements?: ClassAnnouncementCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutCreatedBySuperAdminInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    schoolEmail: string
    website?: string | null
    logoUrl?: string | null
    currentAcademicYear?: string | null
    currentTerm?: $Enums.TermPeriod | null
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    admins?: SchoolAdminUncheckedCreateNestedManyWithoutSchoolInput
    teachers?: TeacherUncheckedCreateNestedManyWithoutSchoolInput
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutSchoolInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutSchoolInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSchoolInput
    timetableSlots?: TimetableSlotUncheckedCreateNestedManyWithoutSchoolInput
    announcements?: SchoolAnnouncementUncheckedCreateNestedManyWithoutSchoolInput
    classAnnouncements?: ClassAnnouncementUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutCreatedBySuperAdminInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutCreatedBySuperAdminInput, SchoolUncheckedCreateWithoutCreatedBySuperAdminInput>
  }

  export type SchoolCreateManyCreatedBySuperAdminInputEnvelope = {
    data: SchoolCreateManyCreatedBySuperAdminInput | SchoolCreateManyCreatedBySuperAdminInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSuperAdminInput = {
    update: XOR<UserUpdateWithoutSuperAdminInput, UserUncheckedUpdateWithoutSuperAdminInput>
    create: XOR<UserCreateWithoutSuperAdminInput, UserUncheckedCreateWithoutSuperAdminInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSuperAdminInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSuperAdminInput, UserUncheckedUpdateWithoutSuperAdminInput>
  }

  export type UserUpdateWithoutSuperAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    schoolAdmins?: SchoolAdminUpdateManyWithoutUserNestedInput
    teacherLinks?: TeacherUpdateManyWithoutUserNestedInput
    studentLink?: StudentUpdateOneWithoutUserNestedInput
    parentLink?: ParentUpdateOneWithoutUserNestedInput
    recordedAttendances?: StudentAttendanceUpdateManyWithoutRecordedByNestedInput
    recordedPayments?: PaymentUpdateManyWithoutRecordedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSuperAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    schoolAdmins?: SchoolAdminUncheckedUpdateManyWithoutUserNestedInput
    teacherLinks?: TeacherUncheckedUpdateManyWithoutUserNestedInput
    studentLink?: StudentUncheckedUpdateOneWithoutUserNestedInput
    parentLink?: ParentUncheckedUpdateOneWithoutUserNestedInput
    recordedAttendances?: StudentAttendanceUncheckedUpdateManyWithoutRecordedByNestedInput
    recordedPayments?: PaymentUncheckedUpdateManyWithoutRecordedByNestedInput
  }

  export type SchoolUpsertWithWhereUniqueWithoutCreatedBySuperAdminInput = {
    where: SchoolWhereUniqueInput
    update: XOR<SchoolUpdateWithoutCreatedBySuperAdminInput, SchoolUncheckedUpdateWithoutCreatedBySuperAdminInput>
    create: XOR<SchoolCreateWithoutCreatedBySuperAdminInput, SchoolUncheckedCreateWithoutCreatedBySuperAdminInput>
  }

  export type SchoolUpdateWithWhereUniqueWithoutCreatedBySuperAdminInput = {
    where: SchoolWhereUniqueInput
    data: XOR<SchoolUpdateWithoutCreatedBySuperAdminInput, SchoolUncheckedUpdateWithoutCreatedBySuperAdminInput>
  }

  export type SchoolUpdateManyWithWhereWithoutCreatedBySuperAdminInput = {
    where: SchoolScalarWhereInput
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyWithoutCreatedBySuperAdminInput>
  }

  export type SchoolScalarWhereInput = {
    AND?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
    OR?: SchoolScalarWhereInput[]
    NOT?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
    id?: StringFilter<"School"> | string
    name?: StringFilter<"School"> | string
    address?: StringNullableFilter<"School"> | string | null
    city?: StringNullableFilter<"School"> | string | null
    stateOrRegion?: StringNullableFilter<"School"> | string | null
    country?: StringNullableFilter<"School"> | string | null
    postalCode?: StringNullableFilter<"School"> | string | null
    phoneNumber?: StringNullableFilter<"School"> | string | null
    schoolEmail?: StringFilter<"School"> | string
    website?: StringNullableFilter<"School"> | string | null
    logoUrl?: StringNullableFilter<"School"> | string | null
    currentAcademicYear?: StringNullableFilter<"School"> | string | null
    currentTerm?: EnumTermPeriodNullableFilter<"School"> | $Enums.TermPeriod | null
    currency?: StringFilter<"School"> | string
    timezone?: StringFilter<"School"> | string
    isActive?: BoolFilter<"School"> | boolean
    createdBySuperAdminId?: StringNullableFilter<"School"> | string | null
    createdAt?: DateTimeFilter<"School"> | Date | string
    updatedAt?: DateTimeFilter<"School"> | Date | string
  }

  export type SuperAdminCreateWithoutSchoolsCreatedInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSuperAdminInput
  }

  export type SuperAdminUncheckedCreateWithoutSchoolsCreatedInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SuperAdminCreateOrConnectWithoutSchoolsCreatedInput = {
    where: SuperAdminWhereUniqueInput
    create: XOR<SuperAdminCreateWithoutSchoolsCreatedInput, SuperAdminUncheckedCreateWithoutSchoolsCreatedInput>
  }

  export type SchoolAdminCreateWithoutSchoolInput = {
    id?: string
    jobTitle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSchoolAdminsInput
    createdSchoolAnnouncements?: SchoolAnnouncementCreateNestedManyWithoutCreatedByAdminInput
  }

  export type SchoolAdminUncheckedCreateWithoutSchoolInput = {
    id?: string
    userId: string
    jobTitle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdSchoolAnnouncements?: SchoolAnnouncementUncheckedCreateNestedManyWithoutCreatedByAdminInput
  }

  export type SchoolAdminCreateOrConnectWithoutSchoolInput = {
    where: SchoolAdminWhereUniqueInput
    create: XOR<SchoolAdminCreateWithoutSchoolInput, SchoolAdminUncheckedCreateWithoutSchoolInput>
  }

  export type SchoolAdminCreateManySchoolInputEnvelope = {
    data: SchoolAdminCreateManySchoolInput | SchoolAdminCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type TeacherCreateWithoutSchoolInput = {
    id?: string
    teacherIdNumber?: string | null
    dateOfJoining?: Date | string | null
    qualifications?: string | null
    specialization?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTeacherLinksInput
    classTeacherOf?: ClassCreateNestedManyWithoutHomeroomTeacherInput
    timetableSlots?: TimetableSlotCreateNestedManyWithoutTeacherInput
    gradesGiven?: StudentGradeCreateNestedManyWithoutTeacherInput
    assignmentsCreated?: AssignmentCreateNestedManyWithoutTeacherInput
    createdClassAnnouncements?: ClassAnnouncementCreateNestedManyWithoutCreatedByTeacherInput
  }

  export type TeacherUncheckedCreateWithoutSchoolInput = {
    id?: string
    userId: string
    teacherIdNumber?: string | null
    dateOfJoining?: Date | string | null
    qualifications?: string | null
    specialization?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classTeacherOf?: ClassUncheckedCreateNestedManyWithoutHomeroomTeacherInput
    timetableSlots?: TimetableSlotUncheckedCreateNestedManyWithoutTeacherInput
    gradesGiven?: StudentGradeUncheckedCreateNestedManyWithoutTeacherInput
    assignmentsCreated?: AssignmentUncheckedCreateNestedManyWithoutTeacherInput
    createdClassAnnouncements?: ClassAnnouncementUncheckedCreateNestedManyWithoutCreatedByTeacherInput
  }

  export type TeacherCreateOrConnectWithoutSchoolInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutSchoolInput, TeacherUncheckedCreateWithoutSchoolInput>
  }

  export type TeacherCreateManySchoolInputEnvelope = {
    data: TeacherCreateManySchoolInput | TeacherCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutSchoolInput = {
    id?: string
    studentIdNumber: string
    firstName: string
    lastName: string
    middleName?: string | null
    dateOfBirth: Date | string
    gender: $Enums.Gender
    enrollmentDate: Date | string
    profilePictureUrl?: string | null
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    bloodGroup?: string | null
    allergies?: string | null
    medicalNotes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentLinkInput
    currentClass?: ClassCreateNestedOneWithoutCurrentStudentsInput
    parents?: StudentParentLinkCreateNestedManyWithoutStudentInput
    enrollments?: StudentClassEnrollmentCreateNestedManyWithoutStudentInput
    attendances?: StudentAttendanceCreateNestedManyWithoutStudentInput
    grades?: StudentGradeCreateNestedManyWithoutStudentInput
    invoiceLineItems?: InvoiceLineItemCreateNestedManyWithoutStudentInput
    invoices?: InvoiceCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutSchoolInput = {
    id?: string
    userId?: string | null
    studentIdNumber: string
    firstName: string
    lastName: string
    middleName?: string | null
    dateOfBirth: Date | string
    gender: $Enums.Gender
    enrollmentDate: Date | string
    profilePictureUrl?: string | null
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    bloodGroup?: string | null
    allergies?: string | null
    medicalNotes?: string | null
    isActive?: boolean
    currentClassId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: StudentParentLinkUncheckedCreateNestedManyWithoutStudentInput
    enrollments?: StudentClassEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    attendances?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    grades?: StudentGradeUncheckedCreateNestedManyWithoutStudentInput
    invoiceLineItems?: InvoiceLineItemUncheckedCreateNestedManyWithoutStudentInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutSchoolInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutSchoolInput, StudentUncheckedCreateWithoutSchoolInput>
  }

  export type StudentCreateManySchoolInputEnvelope = {
    data: StudentCreateManySchoolInput | StudentCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type ClassCreateWithoutSchoolInput = {
    id?: string
    name: string
    section?: string | null
    academicYear: string
    createdAt?: Date | string
    updatedAt?: Date | string
    homeroomTeacher?: TeacherCreateNestedOneWithoutClassTeacherOfInput
    studentsEnrolled?: StudentClassEnrollmentCreateNestedManyWithoutClassInput
    currentStudents?: StudentCreateNestedManyWithoutCurrentClassInput
    timetableSlots?: TimetableSlotCreateNestedManyWithoutClassInput
    assignments?: AssignmentCreateNestedManyWithoutClassInput
    announcements?: ClassAnnouncementCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    section?: string | null
    academicYear: string
    homeroomTeacherId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentsEnrolled?: StudentClassEnrollmentUncheckedCreateNestedManyWithoutClassInput
    currentStudents?: StudentUncheckedCreateNestedManyWithoutCurrentClassInput
    timetableSlots?: TimetableSlotUncheckedCreateNestedManyWithoutClassInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClassInput
    announcements?: ClassAnnouncementUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutSchoolInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput>
  }

  export type ClassCreateManySchoolInputEnvelope = {
    data: ClassCreateManySchoolInput | ClassCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type SubjectCreateWithoutSchoolInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timetableSlots?: TimetableSlotCreateNestedManyWithoutSubjectInput
    assignments?: AssignmentCreateNestedManyWithoutSubjectInput
    grades?: StudentGradeCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timetableSlots?: TimetableSlotUncheckedCreateNestedManyWithoutSubjectInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutSubjectInput
    grades?: StudentGradeUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutSchoolInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutSchoolInput, SubjectUncheckedCreateWithoutSchoolInput>
  }

  export type SubjectCreateManySchoolInputEnvelope = {
    data: SubjectCreateManySchoolInput | SubjectCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type FeeStructureCreateWithoutSchoolInput = {
    id?: string
    name: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    academicYear: string
    term?: $Enums.TermPeriod | null
    frequency: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceLineItems?: InvoiceLineItemCreateNestedManyWithoutFeeStructureInput
  }

  export type FeeStructureUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    academicYear: string
    term?: $Enums.TermPeriod | null
    frequency: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceLineItems?: InvoiceLineItemUncheckedCreateNestedManyWithoutFeeStructureInput
  }

  export type FeeStructureCreateOrConnectWithoutSchoolInput = {
    where: FeeStructureWhereUniqueInput
    create: XOR<FeeStructureCreateWithoutSchoolInput, FeeStructureUncheckedCreateWithoutSchoolInput>
  }

  export type FeeStructureCreateManySchoolInputEnvelope = {
    data: FeeStructureCreateManySchoolInput | FeeStructureCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutSchoolInput = {
    id?: string
    invoiceNumber: string
    issueDate: Date | string
    dueDate: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.PaymentStatus
    notes?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutInvoicesInput
    parentToBill?: ParentCreateNestedOneWithoutInvoicesInput
    lineItems?: InvoiceLineItemCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutSchoolInput = {
    id?: string
    studentId: string
    parentToBillId?: string | null
    invoiceNumber: string
    issueDate: Date | string
    dueDate: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.PaymentStatus
    notes?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    createdAt?: Date | string
    updatedAt?: Date | string
    lineItems?: InvoiceLineItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutSchoolInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutSchoolInput, InvoiceUncheckedCreateWithoutSchoolInput>
  }

  export type InvoiceCreateManySchoolInputEnvelope = {
    data: InvoiceCreateManySchoolInput | InvoiceCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type TimetableSlotCreateWithoutSchoolInput = {
    id?: string
    dayOfWeek: $Enums.DayOfWeek
    startTime: string
    endTime: string
    room?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutTimetableSlotsInput
    subject: SubjectCreateNestedOneWithoutTimetableSlotsInput
    teacher: TeacherCreateNestedOneWithoutTimetableSlotsInput
    attendances?: StudentAttendanceCreateNestedManyWithoutTimetableSlotInput
  }

  export type TimetableSlotUncheckedCreateWithoutSchoolInput = {
    id?: string
    classId: string
    subjectId: string
    teacherId: string
    dayOfWeek: $Enums.DayOfWeek
    startTime: string
    endTime: string
    room?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendances?: StudentAttendanceUncheckedCreateNestedManyWithoutTimetableSlotInput
  }

  export type TimetableSlotCreateOrConnectWithoutSchoolInput = {
    where: TimetableSlotWhereUniqueInput
    create: XOR<TimetableSlotCreateWithoutSchoolInput, TimetableSlotUncheckedCreateWithoutSchoolInput>
  }

  export type TimetableSlotCreateManySchoolInputEnvelope = {
    data: TimetableSlotCreateManySchoolInput | TimetableSlotCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type SchoolAnnouncementCreateWithoutSchoolInput = {
    id?: string
    title: string
    content: string
    publishDate: Date | string
    expiryDate?: Date | string | null
    audience?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByAdmin?: SchoolAdminCreateNestedOneWithoutCreatedSchoolAnnouncementsInput
  }

  export type SchoolAnnouncementUncheckedCreateWithoutSchoolInput = {
    id?: string
    title: string
    content: string
    publishDate: Date | string
    expiryDate?: Date | string | null
    audience?: string | null
    isPublished?: boolean
    createdByAdminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolAnnouncementCreateOrConnectWithoutSchoolInput = {
    where: SchoolAnnouncementWhereUniqueInput
    create: XOR<SchoolAnnouncementCreateWithoutSchoolInput, SchoolAnnouncementUncheckedCreateWithoutSchoolInput>
  }

  export type SchoolAnnouncementCreateManySchoolInputEnvelope = {
    data: SchoolAnnouncementCreateManySchoolInput | SchoolAnnouncementCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type ClassAnnouncementCreateWithoutSchoolInput = {
    id?: string
    title: string
    content: string
    publishDate: Date | string
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutAnnouncementsInput
    createdByTeacher?: TeacherCreateNestedOneWithoutCreatedClassAnnouncementsInput
  }

  export type ClassAnnouncementUncheckedCreateWithoutSchoolInput = {
    id?: string
    classId: string
    title: string
    content: string
    publishDate: Date | string
    isPublished?: boolean
    createdByTeacherId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassAnnouncementCreateOrConnectWithoutSchoolInput = {
    where: ClassAnnouncementWhereUniqueInput
    create: XOR<ClassAnnouncementCreateWithoutSchoolInput, ClassAnnouncementUncheckedCreateWithoutSchoolInput>
  }

  export type ClassAnnouncementCreateManySchoolInputEnvelope = {
    data: ClassAnnouncementCreateManySchoolInput | ClassAnnouncementCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type SuperAdminUpsertWithoutSchoolsCreatedInput = {
    update: XOR<SuperAdminUpdateWithoutSchoolsCreatedInput, SuperAdminUncheckedUpdateWithoutSchoolsCreatedInput>
    create: XOR<SuperAdminCreateWithoutSchoolsCreatedInput, SuperAdminUncheckedCreateWithoutSchoolsCreatedInput>
    where?: SuperAdminWhereInput
  }

  export type SuperAdminUpdateToOneWithWhereWithoutSchoolsCreatedInput = {
    where?: SuperAdminWhereInput
    data: XOR<SuperAdminUpdateWithoutSchoolsCreatedInput, SuperAdminUncheckedUpdateWithoutSchoolsCreatedInput>
  }

  export type SuperAdminUpdateWithoutSchoolsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSuperAdminNestedInput
  }

  export type SuperAdminUncheckedUpdateWithoutSchoolsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolAdminUpsertWithWhereUniqueWithoutSchoolInput = {
    where: SchoolAdminWhereUniqueInput
    update: XOR<SchoolAdminUpdateWithoutSchoolInput, SchoolAdminUncheckedUpdateWithoutSchoolInput>
    create: XOR<SchoolAdminCreateWithoutSchoolInput, SchoolAdminUncheckedCreateWithoutSchoolInput>
  }

  export type SchoolAdminUpdateWithWhereUniqueWithoutSchoolInput = {
    where: SchoolAdminWhereUniqueInput
    data: XOR<SchoolAdminUpdateWithoutSchoolInput, SchoolAdminUncheckedUpdateWithoutSchoolInput>
  }

  export type SchoolAdminUpdateManyWithWhereWithoutSchoolInput = {
    where: SchoolAdminScalarWhereInput
    data: XOR<SchoolAdminUpdateManyMutationInput, SchoolAdminUncheckedUpdateManyWithoutSchoolInput>
  }

  export type TeacherUpsertWithWhereUniqueWithoutSchoolInput = {
    where: TeacherWhereUniqueInput
    update: XOR<TeacherUpdateWithoutSchoolInput, TeacherUncheckedUpdateWithoutSchoolInput>
    create: XOR<TeacherCreateWithoutSchoolInput, TeacherUncheckedCreateWithoutSchoolInput>
  }

  export type TeacherUpdateWithWhereUniqueWithoutSchoolInput = {
    where: TeacherWhereUniqueInput
    data: XOR<TeacherUpdateWithoutSchoolInput, TeacherUncheckedUpdateWithoutSchoolInput>
  }

  export type TeacherUpdateManyWithWhereWithoutSchoolInput = {
    where: TeacherScalarWhereInput
    data: XOR<TeacherUpdateManyMutationInput, TeacherUncheckedUpdateManyWithoutSchoolInput>
  }

  export type StudentUpsertWithWhereUniqueWithoutSchoolInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutSchoolInput, StudentUncheckedUpdateWithoutSchoolInput>
    create: XOR<StudentCreateWithoutSchoolInput, StudentUncheckedCreateWithoutSchoolInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutSchoolInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutSchoolInput, StudentUncheckedUpdateWithoutSchoolInput>
  }

  export type StudentUpdateManyWithWhereWithoutSchoolInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutSchoolInput>
  }

  export type StudentScalarWhereInput = {
    AND?: StudentScalarWhereInput | StudentScalarWhereInput[]
    OR?: StudentScalarWhereInput[]
    NOT?: StudentScalarWhereInput | StudentScalarWhereInput[]
    id?: StringFilter<"Student"> | string
    userId?: StringNullableFilter<"Student"> | string | null
    schoolId?: StringFilter<"Student"> | string
    studentIdNumber?: StringFilter<"Student"> | string
    firstName?: StringFilter<"Student"> | string
    lastName?: StringFilter<"Student"> | string
    middleName?: StringNullableFilter<"Student"> | string | null
    dateOfBirth?: DateTimeFilter<"Student"> | Date | string
    gender?: EnumGenderFilter<"Student"> | $Enums.Gender
    enrollmentDate?: DateTimeFilter<"Student"> | Date | string
    profilePictureUrl?: StringNullableFilter<"Student"> | string | null
    address?: StringNullableFilter<"Student"> | string | null
    city?: StringNullableFilter<"Student"> | string | null
    stateOrRegion?: StringNullableFilter<"Student"> | string | null
    country?: StringNullableFilter<"Student"> | string | null
    postalCode?: StringNullableFilter<"Student"> | string | null
    emergencyContactName?: StringNullableFilter<"Student"> | string | null
    emergencyContactPhone?: StringNullableFilter<"Student"> | string | null
    bloodGroup?: StringNullableFilter<"Student"> | string | null
    allergies?: StringNullableFilter<"Student"> | string | null
    medicalNotes?: StringNullableFilter<"Student"> | string | null
    isActive?: BoolFilter<"Student"> | boolean
    currentClassId?: StringNullableFilter<"Student"> | string | null
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
  }

  export type ClassUpsertWithWhereUniqueWithoutSchoolInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutSchoolInput, ClassUncheckedUpdateWithoutSchoolInput>
    create: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutSchoolInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutSchoolInput, ClassUncheckedUpdateWithoutSchoolInput>
  }

  export type ClassUpdateManyWithWhereWithoutSchoolInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutSchoolInput>
  }

  export type ClassScalarWhereInput = {
    AND?: ClassScalarWhereInput | ClassScalarWhereInput[]
    OR?: ClassScalarWhereInput[]
    NOT?: ClassScalarWhereInput | ClassScalarWhereInput[]
    id?: StringFilter<"Class"> | string
    schoolId?: StringFilter<"Class"> | string
    name?: StringFilter<"Class"> | string
    section?: StringNullableFilter<"Class"> | string | null
    academicYear?: StringFilter<"Class"> | string
    homeroomTeacherId?: StringNullableFilter<"Class"> | string | null
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
  }

  export type SubjectUpsertWithWhereUniqueWithoutSchoolInput = {
    where: SubjectWhereUniqueInput
    update: XOR<SubjectUpdateWithoutSchoolInput, SubjectUncheckedUpdateWithoutSchoolInput>
    create: XOR<SubjectCreateWithoutSchoolInput, SubjectUncheckedCreateWithoutSchoolInput>
  }

  export type SubjectUpdateWithWhereUniqueWithoutSchoolInput = {
    where: SubjectWhereUniqueInput
    data: XOR<SubjectUpdateWithoutSchoolInput, SubjectUncheckedUpdateWithoutSchoolInput>
  }

  export type SubjectUpdateManyWithWhereWithoutSchoolInput = {
    where: SubjectScalarWhereInput
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyWithoutSchoolInput>
  }

  export type SubjectScalarWhereInput = {
    AND?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
    OR?: SubjectScalarWhereInput[]
    NOT?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
    id?: StringFilter<"Subject"> | string
    schoolId?: StringFilter<"Subject"> | string
    name?: StringFilter<"Subject"> | string
    code?: StringNullableFilter<"Subject"> | string | null
    description?: StringNullableFilter<"Subject"> | string | null
    createdAt?: DateTimeFilter<"Subject"> | Date | string
    updatedAt?: DateTimeFilter<"Subject"> | Date | string
  }

  export type FeeStructureUpsertWithWhereUniqueWithoutSchoolInput = {
    where: FeeStructureWhereUniqueInput
    update: XOR<FeeStructureUpdateWithoutSchoolInput, FeeStructureUncheckedUpdateWithoutSchoolInput>
    create: XOR<FeeStructureCreateWithoutSchoolInput, FeeStructureUncheckedCreateWithoutSchoolInput>
  }

  export type FeeStructureUpdateWithWhereUniqueWithoutSchoolInput = {
    where: FeeStructureWhereUniqueInput
    data: XOR<FeeStructureUpdateWithoutSchoolInput, FeeStructureUncheckedUpdateWithoutSchoolInput>
  }

  export type FeeStructureUpdateManyWithWhereWithoutSchoolInput = {
    where: FeeStructureScalarWhereInput
    data: XOR<FeeStructureUpdateManyMutationInput, FeeStructureUncheckedUpdateManyWithoutSchoolInput>
  }

  export type FeeStructureScalarWhereInput = {
    AND?: FeeStructureScalarWhereInput | FeeStructureScalarWhereInput[]
    OR?: FeeStructureScalarWhereInput[]
    NOT?: FeeStructureScalarWhereInput | FeeStructureScalarWhereInput[]
    id?: StringFilter<"FeeStructure"> | string
    schoolId?: StringFilter<"FeeStructure"> | string
    name?: StringFilter<"FeeStructure"> | string
    description?: StringNullableFilter<"FeeStructure"> | string | null
    amount?: DecimalFilter<"FeeStructure"> | Decimal | DecimalJsLike | number | string
    academicYear?: StringFilter<"FeeStructure"> | string
    term?: EnumTermPeriodNullableFilter<"FeeStructure"> | $Enums.TermPeriod | null
    frequency?: StringFilter<"FeeStructure"> | string
    createdAt?: DateTimeFilter<"FeeStructure"> | Date | string
    updatedAt?: DateTimeFilter<"FeeStructure"> | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutSchoolInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutSchoolInput, InvoiceUncheckedUpdateWithoutSchoolInput>
    create: XOR<InvoiceCreateWithoutSchoolInput, InvoiceUncheckedCreateWithoutSchoolInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutSchoolInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutSchoolInput, InvoiceUncheckedUpdateWithoutSchoolInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutSchoolInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutSchoolInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    schoolId?: StringFilter<"Invoice"> | string
    studentId?: StringFilter<"Invoice"> | string
    parentToBillId?: StringNullableFilter<"Invoice"> | string | null
    invoiceNumber?: StringFilter<"Invoice"> | string
    issueDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    totalAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFilter<"Invoice"> | $Enums.PaymentStatus
    notes?: StringNullableFilter<"Invoice"> | string | null
    academicYear?: StringFilter<"Invoice"> | string
    term?: EnumTermPeriodFilter<"Invoice"> | $Enums.TermPeriod
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type TimetableSlotUpsertWithWhereUniqueWithoutSchoolInput = {
    where: TimetableSlotWhereUniqueInput
    update: XOR<TimetableSlotUpdateWithoutSchoolInput, TimetableSlotUncheckedUpdateWithoutSchoolInput>
    create: XOR<TimetableSlotCreateWithoutSchoolInput, TimetableSlotUncheckedCreateWithoutSchoolInput>
  }

  export type TimetableSlotUpdateWithWhereUniqueWithoutSchoolInput = {
    where: TimetableSlotWhereUniqueInput
    data: XOR<TimetableSlotUpdateWithoutSchoolInput, TimetableSlotUncheckedUpdateWithoutSchoolInput>
  }

  export type TimetableSlotUpdateManyWithWhereWithoutSchoolInput = {
    where: TimetableSlotScalarWhereInput
    data: XOR<TimetableSlotUpdateManyMutationInput, TimetableSlotUncheckedUpdateManyWithoutSchoolInput>
  }

  export type TimetableSlotScalarWhereInput = {
    AND?: TimetableSlotScalarWhereInput | TimetableSlotScalarWhereInput[]
    OR?: TimetableSlotScalarWhereInput[]
    NOT?: TimetableSlotScalarWhereInput | TimetableSlotScalarWhereInput[]
    id?: StringFilter<"TimetableSlot"> | string
    schoolId?: StringFilter<"TimetableSlot"> | string
    classId?: StringFilter<"TimetableSlot"> | string
    subjectId?: StringFilter<"TimetableSlot"> | string
    teacherId?: StringFilter<"TimetableSlot"> | string
    dayOfWeek?: EnumDayOfWeekFilter<"TimetableSlot"> | $Enums.DayOfWeek
    startTime?: StringFilter<"TimetableSlot"> | string
    endTime?: StringFilter<"TimetableSlot"> | string
    room?: StringNullableFilter<"TimetableSlot"> | string | null
    createdAt?: DateTimeFilter<"TimetableSlot"> | Date | string
    updatedAt?: DateTimeFilter<"TimetableSlot"> | Date | string
  }

  export type SchoolAnnouncementUpsertWithWhereUniqueWithoutSchoolInput = {
    where: SchoolAnnouncementWhereUniqueInput
    update: XOR<SchoolAnnouncementUpdateWithoutSchoolInput, SchoolAnnouncementUncheckedUpdateWithoutSchoolInput>
    create: XOR<SchoolAnnouncementCreateWithoutSchoolInput, SchoolAnnouncementUncheckedCreateWithoutSchoolInput>
  }

  export type SchoolAnnouncementUpdateWithWhereUniqueWithoutSchoolInput = {
    where: SchoolAnnouncementWhereUniqueInput
    data: XOR<SchoolAnnouncementUpdateWithoutSchoolInput, SchoolAnnouncementUncheckedUpdateWithoutSchoolInput>
  }

  export type SchoolAnnouncementUpdateManyWithWhereWithoutSchoolInput = {
    where: SchoolAnnouncementScalarWhereInput
    data: XOR<SchoolAnnouncementUpdateManyMutationInput, SchoolAnnouncementUncheckedUpdateManyWithoutSchoolInput>
  }

  export type SchoolAnnouncementScalarWhereInput = {
    AND?: SchoolAnnouncementScalarWhereInput | SchoolAnnouncementScalarWhereInput[]
    OR?: SchoolAnnouncementScalarWhereInput[]
    NOT?: SchoolAnnouncementScalarWhereInput | SchoolAnnouncementScalarWhereInput[]
    id?: StringFilter<"SchoolAnnouncement"> | string
    schoolId?: StringFilter<"SchoolAnnouncement"> | string
    title?: StringFilter<"SchoolAnnouncement"> | string
    content?: StringFilter<"SchoolAnnouncement"> | string
    publishDate?: DateTimeFilter<"SchoolAnnouncement"> | Date | string
    expiryDate?: DateTimeNullableFilter<"SchoolAnnouncement"> | Date | string | null
    audience?: StringNullableFilter<"SchoolAnnouncement"> | string | null
    isPublished?: BoolFilter<"SchoolAnnouncement"> | boolean
    createdByAdminId?: StringNullableFilter<"SchoolAnnouncement"> | string | null
    createdAt?: DateTimeFilter<"SchoolAnnouncement"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolAnnouncement"> | Date | string
  }

  export type ClassAnnouncementUpsertWithWhereUniqueWithoutSchoolInput = {
    where: ClassAnnouncementWhereUniqueInput
    update: XOR<ClassAnnouncementUpdateWithoutSchoolInput, ClassAnnouncementUncheckedUpdateWithoutSchoolInput>
    create: XOR<ClassAnnouncementCreateWithoutSchoolInput, ClassAnnouncementUncheckedCreateWithoutSchoolInput>
  }

  export type ClassAnnouncementUpdateWithWhereUniqueWithoutSchoolInput = {
    where: ClassAnnouncementWhereUniqueInput
    data: XOR<ClassAnnouncementUpdateWithoutSchoolInput, ClassAnnouncementUncheckedUpdateWithoutSchoolInput>
  }

  export type ClassAnnouncementUpdateManyWithWhereWithoutSchoolInput = {
    where: ClassAnnouncementScalarWhereInput
    data: XOR<ClassAnnouncementUpdateManyMutationInput, ClassAnnouncementUncheckedUpdateManyWithoutSchoolInput>
  }

  export type ClassAnnouncementScalarWhereInput = {
    AND?: ClassAnnouncementScalarWhereInput | ClassAnnouncementScalarWhereInput[]
    OR?: ClassAnnouncementScalarWhereInput[]
    NOT?: ClassAnnouncementScalarWhereInput | ClassAnnouncementScalarWhereInput[]
    id?: StringFilter<"ClassAnnouncement"> | string
    schoolId?: StringFilter<"ClassAnnouncement"> | string
    classId?: StringFilter<"ClassAnnouncement"> | string
    title?: StringFilter<"ClassAnnouncement"> | string
    content?: StringFilter<"ClassAnnouncement"> | string
    publishDate?: DateTimeFilter<"ClassAnnouncement"> | Date | string
    isPublished?: BoolFilter<"ClassAnnouncement"> | boolean
    createdByTeacherId?: StringNullableFilter<"ClassAnnouncement"> | string | null
    createdAt?: DateTimeFilter<"ClassAnnouncement"> | Date | string
    updatedAt?: DateTimeFilter<"ClassAnnouncement"> | Date | string
  }

  export type UserCreateWithoutSchoolAdminsInput = {
    id?: string
    email: string
    hashedPassword: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    profilePicture?: string | null
    isActive?: boolean
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    teacherLinks?: TeacherCreateNestedManyWithoutUserInput
    studentLink?: StudentCreateNestedOneWithoutUserInput
    parentLink?: ParentCreateNestedOneWithoutUserInput
    recordedAttendances?: StudentAttendanceCreateNestedManyWithoutRecordedByInput
    recordedPayments?: PaymentCreateNestedManyWithoutRecordedByInput
  }

  export type UserUncheckedCreateWithoutSchoolAdminsInput = {
    id?: string
    email: string
    hashedPassword: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    profilePicture?: string | null
    isActive?: boolean
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    teacherLinks?: TeacherUncheckedCreateNestedManyWithoutUserInput
    studentLink?: StudentUncheckedCreateNestedOneWithoutUserInput
    parentLink?: ParentUncheckedCreateNestedOneWithoutUserInput
    recordedAttendances?: StudentAttendanceUncheckedCreateNestedManyWithoutRecordedByInput
    recordedPayments?: PaymentUncheckedCreateNestedManyWithoutRecordedByInput
  }

  export type UserCreateOrConnectWithoutSchoolAdminsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSchoolAdminsInput, UserUncheckedCreateWithoutSchoolAdminsInput>
  }

  export type SchoolCreateWithoutAdminsInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    schoolEmail: string
    website?: string | null
    logoUrl?: string | null
    currentAcademicYear?: string | null
    currentTerm?: $Enums.TermPeriod | null
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBySuperAdmin?: SuperAdminCreateNestedOneWithoutSchoolsCreatedInput
    teachers?: TeacherCreateNestedManyWithoutSchoolInput
    students?: StudentCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    subjects?: SubjectCreateNestedManyWithoutSchoolInput
    feeStructures?: FeeStructureCreateNestedManyWithoutSchoolInput
    invoices?: InvoiceCreateNestedManyWithoutSchoolInput
    timetableSlots?: TimetableSlotCreateNestedManyWithoutSchoolInput
    announcements?: SchoolAnnouncementCreateNestedManyWithoutSchoolInput
    classAnnouncements?: ClassAnnouncementCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutAdminsInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    schoolEmail: string
    website?: string | null
    logoUrl?: string | null
    currentAcademicYear?: string | null
    currentTerm?: $Enums.TermPeriod | null
    currency?: string
    timezone?: string
    isActive?: boolean
    createdBySuperAdminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teachers?: TeacherUncheckedCreateNestedManyWithoutSchoolInput
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutSchoolInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutSchoolInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSchoolInput
    timetableSlots?: TimetableSlotUncheckedCreateNestedManyWithoutSchoolInput
    announcements?: SchoolAnnouncementUncheckedCreateNestedManyWithoutSchoolInput
    classAnnouncements?: ClassAnnouncementUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutAdminsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutAdminsInput, SchoolUncheckedCreateWithoutAdminsInput>
  }

  export type SchoolAnnouncementCreateWithoutCreatedByAdminInput = {
    id?: string
    title: string
    content: string
    publishDate: Date | string
    expiryDate?: Date | string | null
    audience?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutAnnouncementsInput
  }

  export type SchoolAnnouncementUncheckedCreateWithoutCreatedByAdminInput = {
    id?: string
    schoolId: string
    title: string
    content: string
    publishDate: Date | string
    expiryDate?: Date | string | null
    audience?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolAnnouncementCreateOrConnectWithoutCreatedByAdminInput = {
    where: SchoolAnnouncementWhereUniqueInput
    create: XOR<SchoolAnnouncementCreateWithoutCreatedByAdminInput, SchoolAnnouncementUncheckedCreateWithoutCreatedByAdminInput>
  }

  export type SchoolAnnouncementCreateManyCreatedByAdminInputEnvelope = {
    data: SchoolAnnouncementCreateManyCreatedByAdminInput | SchoolAnnouncementCreateManyCreatedByAdminInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSchoolAdminsInput = {
    update: XOR<UserUpdateWithoutSchoolAdminsInput, UserUncheckedUpdateWithoutSchoolAdminsInput>
    create: XOR<UserCreateWithoutSchoolAdminsInput, UserUncheckedCreateWithoutSchoolAdminsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSchoolAdminsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSchoolAdminsInput, UserUncheckedUpdateWithoutSchoolAdminsInput>
  }

  export type UserUpdateWithoutSchoolAdminsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    teacherLinks?: TeacherUpdateManyWithoutUserNestedInput
    studentLink?: StudentUpdateOneWithoutUserNestedInput
    parentLink?: ParentUpdateOneWithoutUserNestedInput
    recordedAttendances?: StudentAttendanceUpdateManyWithoutRecordedByNestedInput
    recordedPayments?: PaymentUpdateManyWithoutRecordedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSchoolAdminsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    teacherLinks?: TeacherUncheckedUpdateManyWithoutUserNestedInput
    studentLink?: StudentUncheckedUpdateOneWithoutUserNestedInput
    parentLink?: ParentUncheckedUpdateOneWithoutUserNestedInput
    recordedAttendances?: StudentAttendanceUncheckedUpdateManyWithoutRecordedByNestedInput
    recordedPayments?: PaymentUncheckedUpdateManyWithoutRecordedByNestedInput
  }

  export type SchoolUpsertWithoutAdminsInput = {
    update: XOR<SchoolUpdateWithoutAdminsInput, SchoolUncheckedUpdateWithoutAdminsInput>
    create: XOR<SchoolCreateWithoutAdminsInput, SchoolUncheckedCreateWithoutAdminsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutAdminsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutAdminsInput, SchoolUncheckedUpdateWithoutAdminsInput>
  }

  export type SchoolUpdateWithoutAdminsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    schoolEmail?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    currentAcademicYear?: NullableStringFieldUpdateOperationsInput | string | null
    currentTerm?: NullableEnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBySuperAdmin?: SuperAdminUpdateOneWithoutSchoolsCreatedNestedInput
    teachers?: TeacherUpdateManyWithoutSchoolNestedInput
    students?: StudentUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUpdateManyWithoutSchoolNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutSchoolNestedInput
    invoices?: InvoiceUpdateManyWithoutSchoolNestedInput
    timetableSlots?: TimetableSlotUpdateManyWithoutSchoolNestedInput
    announcements?: SchoolAnnouncementUpdateManyWithoutSchoolNestedInput
    classAnnouncements?: ClassAnnouncementUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutAdminsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    schoolEmail?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    currentAcademicYear?: NullableStringFieldUpdateOperationsInput | string | null
    currentTerm?: NullableEnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBySuperAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teachers?: TeacherUncheckedUpdateManyWithoutSchoolNestedInput
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutSchoolNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutSchoolNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSchoolNestedInput
    timetableSlots?: TimetableSlotUncheckedUpdateManyWithoutSchoolNestedInput
    announcements?: SchoolAnnouncementUncheckedUpdateManyWithoutSchoolNestedInput
    classAnnouncements?: ClassAnnouncementUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolAnnouncementUpsertWithWhereUniqueWithoutCreatedByAdminInput = {
    where: SchoolAnnouncementWhereUniqueInput
    update: XOR<SchoolAnnouncementUpdateWithoutCreatedByAdminInput, SchoolAnnouncementUncheckedUpdateWithoutCreatedByAdminInput>
    create: XOR<SchoolAnnouncementCreateWithoutCreatedByAdminInput, SchoolAnnouncementUncheckedCreateWithoutCreatedByAdminInput>
  }

  export type SchoolAnnouncementUpdateWithWhereUniqueWithoutCreatedByAdminInput = {
    where: SchoolAnnouncementWhereUniqueInput
    data: XOR<SchoolAnnouncementUpdateWithoutCreatedByAdminInput, SchoolAnnouncementUncheckedUpdateWithoutCreatedByAdminInput>
  }

  export type SchoolAnnouncementUpdateManyWithWhereWithoutCreatedByAdminInput = {
    where: SchoolAnnouncementScalarWhereInput
    data: XOR<SchoolAnnouncementUpdateManyMutationInput, SchoolAnnouncementUncheckedUpdateManyWithoutCreatedByAdminInput>
  }

  export type UserCreateWithoutTeacherLinksInput = {
    id?: string
    email: string
    hashedPassword: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    profilePicture?: string | null
    isActive?: boolean
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    schoolAdmins?: SchoolAdminCreateNestedManyWithoutUserInput
    studentLink?: StudentCreateNestedOneWithoutUserInput
    parentLink?: ParentCreateNestedOneWithoutUserInput
    recordedAttendances?: StudentAttendanceCreateNestedManyWithoutRecordedByInput
    recordedPayments?: PaymentCreateNestedManyWithoutRecordedByInput
  }

  export type UserUncheckedCreateWithoutTeacherLinksInput = {
    id?: string
    email: string
    hashedPassword: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    profilePicture?: string | null
    isActive?: boolean
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    schoolAdmins?: SchoolAdminUncheckedCreateNestedManyWithoutUserInput
    studentLink?: StudentUncheckedCreateNestedOneWithoutUserInput
    parentLink?: ParentUncheckedCreateNestedOneWithoutUserInput
    recordedAttendances?: StudentAttendanceUncheckedCreateNestedManyWithoutRecordedByInput
    recordedPayments?: PaymentUncheckedCreateNestedManyWithoutRecordedByInput
  }

  export type UserCreateOrConnectWithoutTeacherLinksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeacherLinksInput, UserUncheckedCreateWithoutTeacherLinksInput>
  }

  export type SchoolCreateWithoutTeachersInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    schoolEmail: string
    website?: string | null
    logoUrl?: string | null
    currentAcademicYear?: string | null
    currentTerm?: $Enums.TermPeriod | null
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBySuperAdmin?: SuperAdminCreateNestedOneWithoutSchoolsCreatedInput
    admins?: SchoolAdminCreateNestedManyWithoutSchoolInput
    students?: StudentCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    subjects?: SubjectCreateNestedManyWithoutSchoolInput
    feeStructures?: FeeStructureCreateNestedManyWithoutSchoolInput
    invoices?: InvoiceCreateNestedManyWithoutSchoolInput
    timetableSlots?: TimetableSlotCreateNestedManyWithoutSchoolInput
    announcements?: SchoolAnnouncementCreateNestedManyWithoutSchoolInput
    classAnnouncements?: ClassAnnouncementCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutTeachersInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    schoolEmail: string
    website?: string | null
    logoUrl?: string | null
    currentAcademicYear?: string | null
    currentTerm?: $Enums.TermPeriod | null
    currency?: string
    timezone?: string
    isActive?: boolean
    createdBySuperAdminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admins?: SchoolAdminUncheckedCreateNestedManyWithoutSchoolInput
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutSchoolInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutSchoolInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSchoolInput
    timetableSlots?: TimetableSlotUncheckedCreateNestedManyWithoutSchoolInput
    announcements?: SchoolAnnouncementUncheckedCreateNestedManyWithoutSchoolInput
    classAnnouncements?: ClassAnnouncementUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutTeachersInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutTeachersInput, SchoolUncheckedCreateWithoutTeachersInput>
  }

  export type ClassCreateWithoutHomeroomTeacherInput = {
    id?: string
    name: string
    section?: string | null
    academicYear: string
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutClassesInput
    studentsEnrolled?: StudentClassEnrollmentCreateNestedManyWithoutClassInput
    currentStudents?: StudentCreateNestedManyWithoutCurrentClassInput
    timetableSlots?: TimetableSlotCreateNestedManyWithoutClassInput
    assignments?: AssignmentCreateNestedManyWithoutClassInput
    announcements?: ClassAnnouncementCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutHomeroomTeacherInput = {
    id?: string
    schoolId: string
    name: string
    section?: string | null
    academicYear: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studentsEnrolled?: StudentClassEnrollmentUncheckedCreateNestedManyWithoutClassInput
    currentStudents?: StudentUncheckedCreateNestedManyWithoutCurrentClassInput
    timetableSlots?: TimetableSlotUncheckedCreateNestedManyWithoutClassInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClassInput
    announcements?: ClassAnnouncementUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutHomeroomTeacherInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutHomeroomTeacherInput, ClassUncheckedCreateWithoutHomeroomTeacherInput>
  }

  export type ClassCreateManyHomeroomTeacherInputEnvelope = {
    data: ClassCreateManyHomeroomTeacherInput | ClassCreateManyHomeroomTeacherInput[]
    skipDuplicates?: boolean
  }

  export type TimetableSlotCreateWithoutTeacherInput = {
    id?: string
    dayOfWeek: $Enums.DayOfWeek
    startTime: string
    endTime: string
    room?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutTimetableSlotsInput
    class: ClassCreateNestedOneWithoutTimetableSlotsInput
    subject: SubjectCreateNestedOneWithoutTimetableSlotsInput
    attendances?: StudentAttendanceCreateNestedManyWithoutTimetableSlotInput
  }

  export type TimetableSlotUncheckedCreateWithoutTeacherInput = {
    id?: string
    schoolId: string
    classId: string
    subjectId: string
    dayOfWeek: $Enums.DayOfWeek
    startTime: string
    endTime: string
    room?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendances?: StudentAttendanceUncheckedCreateNestedManyWithoutTimetableSlotInput
  }

  export type TimetableSlotCreateOrConnectWithoutTeacherInput = {
    where: TimetableSlotWhereUniqueInput
    create: XOR<TimetableSlotCreateWithoutTeacherInput, TimetableSlotUncheckedCreateWithoutTeacherInput>
  }

  export type TimetableSlotCreateManyTeacherInputEnvelope = {
    data: TimetableSlotCreateManyTeacherInput | TimetableSlotCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type StudentGradeCreateWithoutTeacherInput = {
    id?: string
    grade: string
    numericValue?: number | null
    comments?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    dateRecorded?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutGradesInput
    subject: SubjectCreateNestedOneWithoutGradesInput
    assignment?: AssignmentCreateNestedOneWithoutGradesInput
  }

  export type StudentGradeUncheckedCreateWithoutTeacherInput = {
    id?: string
    studentId: string
    subjectId: string
    assignmentId?: string | null
    grade: string
    numericValue?: number | null
    comments?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    dateRecorded?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentGradeCreateOrConnectWithoutTeacherInput = {
    where: StudentGradeWhereUniqueInput
    create: XOR<StudentGradeCreateWithoutTeacherInput, StudentGradeUncheckedCreateWithoutTeacherInput>
  }

  export type StudentGradeCreateManyTeacherInputEnvelope = {
    data: StudentGradeCreateManyTeacherInput | StudentGradeCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type AssignmentCreateWithoutTeacherInput = {
    id?: string
    schoolId: string
    title: string
    description?: string | null
    maxPoints?: number | null
    dueDate?: Date | string | null
    academicYear: string
    term: $Enums.TermPeriod
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutAssignmentsInput
    subject: SubjectCreateNestedOneWithoutAssignmentsInput
    grades?: StudentGradeCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentUncheckedCreateWithoutTeacherInput = {
    id?: string
    schoolId: string
    classId: string
    subjectId: string
    title: string
    description?: string | null
    maxPoints?: number | null
    dueDate?: Date | string | null
    academicYear: string
    term: $Enums.TermPeriod
    createdAt?: Date | string
    updatedAt?: Date | string
    grades?: StudentGradeUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentCreateOrConnectWithoutTeacherInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutTeacherInput, AssignmentUncheckedCreateWithoutTeacherInput>
  }

  export type AssignmentCreateManyTeacherInputEnvelope = {
    data: AssignmentCreateManyTeacherInput | AssignmentCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type ClassAnnouncementCreateWithoutCreatedByTeacherInput = {
    id?: string
    title: string
    content: string
    publishDate: Date | string
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutClassAnnouncementsInput
    class: ClassCreateNestedOneWithoutAnnouncementsInput
  }

  export type ClassAnnouncementUncheckedCreateWithoutCreatedByTeacherInput = {
    id?: string
    schoolId: string
    classId: string
    title: string
    content: string
    publishDate: Date | string
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassAnnouncementCreateOrConnectWithoutCreatedByTeacherInput = {
    where: ClassAnnouncementWhereUniqueInput
    create: XOR<ClassAnnouncementCreateWithoutCreatedByTeacherInput, ClassAnnouncementUncheckedCreateWithoutCreatedByTeacherInput>
  }

  export type ClassAnnouncementCreateManyCreatedByTeacherInputEnvelope = {
    data: ClassAnnouncementCreateManyCreatedByTeacherInput | ClassAnnouncementCreateManyCreatedByTeacherInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutTeacherLinksInput = {
    update: XOR<UserUpdateWithoutTeacherLinksInput, UserUncheckedUpdateWithoutTeacherLinksInput>
    create: XOR<UserCreateWithoutTeacherLinksInput, UserUncheckedCreateWithoutTeacherLinksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeacherLinksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeacherLinksInput, UserUncheckedUpdateWithoutTeacherLinksInput>
  }

  export type UserUpdateWithoutTeacherLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    schoolAdmins?: SchoolAdminUpdateManyWithoutUserNestedInput
    studentLink?: StudentUpdateOneWithoutUserNestedInput
    parentLink?: ParentUpdateOneWithoutUserNestedInput
    recordedAttendances?: StudentAttendanceUpdateManyWithoutRecordedByNestedInput
    recordedPayments?: PaymentUpdateManyWithoutRecordedByNestedInput
  }

  export type UserUncheckedUpdateWithoutTeacherLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    schoolAdmins?: SchoolAdminUncheckedUpdateManyWithoutUserNestedInput
    studentLink?: StudentUncheckedUpdateOneWithoutUserNestedInput
    parentLink?: ParentUncheckedUpdateOneWithoutUserNestedInput
    recordedAttendances?: StudentAttendanceUncheckedUpdateManyWithoutRecordedByNestedInput
    recordedPayments?: PaymentUncheckedUpdateManyWithoutRecordedByNestedInput
  }

  export type SchoolUpsertWithoutTeachersInput = {
    update: XOR<SchoolUpdateWithoutTeachersInput, SchoolUncheckedUpdateWithoutTeachersInput>
    create: XOR<SchoolCreateWithoutTeachersInput, SchoolUncheckedCreateWithoutTeachersInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutTeachersInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutTeachersInput, SchoolUncheckedUpdateWithoutTeachersInput>
  }

  export type SchoolUpdateWithoutTeachersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    schoolEmail?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    currentAcademicYear?: NullableStringFieldUpdateOperationsInput | string | null
    currentTerm?: NullableEnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBySuperAdmin?: SuperAdminUpdateOneWithoutSchoolsCreatedNestedInput
    admins?: SchoolAdminUpdateManyWithoutSchoolNestedInput
    students?: StudentUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUpdateManyWithoutSchoolNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutSchoolNestedInput
    invoices?: InvoiceUpdateManyWithoutSchoolNestedInput
    timetableSlots?: TimetableSlotUpdateManyWithoutSchoolNestedInput
    announcements?: SchoolAnnouncementUpdateManyWithoutSchoolNestedInput
    classAnnouncements?: ClassAnnouncementUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutTeachersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    schoolEmail?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    currentAcademicYear?: NullableStringFieldUpdateOperationsInput | string | null
    currentTerm?: NullableEnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBySuperAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admins?: SchoolAdminUncheckedUpdateManyWithoutSchoolNestedInput
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutSchoolNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutSchoolNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSchoolNestedInput
    timetableSlots?: TimetableSlotUncheckedUpdateManyWithoutSchoolNestedInput
    announcements?: SchoolAnnouncementUncheckedUpdateManyWithoutSchoolNestedInput
    classAnnouncements?: ClassAnnouncementUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type ClassUpsertWithWhereUniqueWithoutHomeroomTeacherInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutHomeroomTeacherInput, ClassUncheckedUpdateWithoutHomeroomTeacherInput>
    create: XOR<ClassCreateWithoutHomeroomTeacherInput, ClassUncheckedCreateWithoutHomeroomTeacherInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutHomeroomTeacherInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutHomeroomTeacherInput, ClassUncheckedUpdateWithoutHomeroomTeacherInput>
  }

  export type ClassUpdateManyWithWhereWithoutHomeroomTeacherInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutHomeroomTeacherInput>
  }

  export type TimetableSlotUpsertWithWhereUniqueWithoutTeacherInput = {
    where: TimetableSlotWhereUniqueInput
    update: XOR<TimetableSlotUpdateWithoutTeacherInput, TimetableSlotUncheckedUpdateWithoutTeacherInput>
    create: XOR<TimetableSlotCreateWithoutTeacherInput, TimetableSlotUncheckedCreateWithoutTeacherInput>
  }

  export type TimetableSlotUpdateWithWhereUniqueWithoutTeacherInput = {
    where: TimetableSlotWhereUniqueInput
    data: XOR<TimetableSlotUpdateWithoutTeacherInput, TimetableSlotUncheckedUpdateWithoutTeacherInput>
  }

  export type TimetableSlotUpdateManyWithWhereWithoutTeacherInput = {
    where: TimetableSlotScalarWhereInput
    data: XOR<TimetableSlotUpdateManyMutationInput, TimetableSlotUncheckedUpdateManyWithoutTeacherInput>
  }

  export type StudentGradeUpsertWithWhereUniqueWithoutTeacherInput = {
    where: StudentGradeWhereUniqueInput
    update: XOR<StudentGradeUpdateWithoutTeacherInput, StudentGradeUncheckedUpdateWithoutTeacherInput>
    create: XOR<StudentGradeCreateWithoutTeacherInput, StudentGradeUncheckedCreateWithoutTeacherInput>
  }

  export type StudentGradeUpdateWithWhereUniqueWithoutTeacherInput = {
    where: StudentGradeWhereUniqueInput
    data: XOR<StudentGradeUpdateWithoutTeacherInput, StudentGradeUncheckedUpdateWithoutTeacherInput>
  }

  export type StudentGradeUpdateManyWithWhereWithoutTeacherInput = {
    where: StudentGradeScalarWhereInput
    data: XOR<StudentGradeUpdateManyMutationInput, StudentGradeUncheckedUpdateManyWithoutTeacherInput>
  }

  export type StudentGradeScalarWhereInput = {
    AND?: StudentGradeScalarWhereInput | StudentGradeScalarWhereInput[]
    OR?: StudentGradeScalarWhereInput[]
    NOT?: StudentGradeScalarWhereInput | StudentGradeScalarWhereInput[]
    id?: StringFilter<"StudentGrade"> | string
    studentId?: StringFilter<"StudentGrade"> | string
    subjectId?: StringFilter<"StudentGrade"> | string
    assignmentId?: StringNullableFilter<"StudentGrade"> | string | null
    teacherId?: StringNullableFilter<"StudentGrade"> | string | null
    grade?: StringFilter<"StudentGrade"> | string
    numericValue?: FloatNullableFilter<"StudentGrade"> | number | null
    comments?: StringNullableFilter<"StudentGrade"> | string | null
    academicYear?: StringFilter<"StudentGrade"> | string
    term?: EnumTermPeriodFilter<"StudentGrade"> | $Enums.TermPeriod
    dateRecorded?: DateTimeFilter<"StudentGrade"> | Date | string
    createdAt?: DateTimeFilter<"StudentGrade"> | Date | string
    updatedAt?: DateTimeFilter<"StudentGrade"> | Date | string
  }

  export type AssignmentUpsertWithWhereUniqueWithoutTeacherInput = {
    where: AssignmentWhereUniqueInput
    update: XOR<AssignmentUpdateWithoutTeacherInput, AssignmentUncheckedUpdateWithoutTeacherInput>
    create: XOR<AssignmentCreateWithoutTeacherInput, AssignmentUncheckedCreateWithoutTeacherInput>
  }

  export type AssignmentUpdateWithWhereUniqueWithoutTeacherInput = {
    where: AssignmentWhereUniqueInput
    data: XOR<AssignmentUpdateWithoutTeacherInput, AssignmentUncheckedUpdateWithoutTeacherInput>
  }

  export type AssignmentUpdateManyWithWhereWithoutTeacherInput = {
    where: AssignmentScalarWhereInput
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyWithoutTeacherInput>
  }

  export type AssignmentScalarWhereInput = {
    AND?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
    OR?: AssignmentScalarWhereInput[]
    NOT?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
    id?: StringFilter<"Assignment"> | string
    schoolId?: StringFilter<"Assignment"> | string
    classId?: StringFilter<"Assignment"> | string
    subjectId?: StringFilter<"Assignment"> | string
    teacherId?: StringFilter<"Assignment"> | string
    title?: StringFilter<"Assignment"> | string
    description?: StringNullableFilter<"Assignment"> | string | null
    maxPoints?: FloatNullableFilter<"Assignment"> | number | null
    dueDate?: DateTimeNullableFilter<"Assignment"> | Date | string | null
    academicYear?: StringFilter<"Assignment"> | string
    term?: EnumTermPeriodFilter<"Assignment"> | $Enums.TermPeriod
    createdAt?: DateTimeFilter<"Assignment"> | Date | string
    updatedAt?: DateTimeFilter<"Assignment"> | Date | string
  }

  export type ClassAnnouncementUpsertWithWhereUniqueWithoutCreatedByTeacherInput = {
    where: ClassAnnouncementWhereUniqueInput
    update: XOR<ClassAnnouncementUpdateWithoutCreatedByTeacherInput, ClassAnnouncementUncheckedUpdateWithoutCreatedByTeacherInput>
    create: XOR<ClassAnnouncementCreateWithoutCreatedByTeacherInput, ClassAnnouncementUncheckedCreateWithoutCreatedByTeacherInput>
  }

  export type ClassAnnouncementUpdateWithWhereUniqueWithoutCreatedByTeacherInput = {
    where: ClassAnnouncementWhereUniqueInput
    data: XOR<ClassAnnouncementUpdateWithoutCreatedByTeacherInput, ClassAnnouncementUncheckedUpdateWithoutCreatedByTeacherInput>
  }

  export type ClassAnnouncementUpdateManyWithWhereWithoutCreatedByTeacherInput = {
    where: ClassAnnouncementScalarWhereInput
    data: XOR<ClassAnnouncementUpdateManyMutationInput, ClassAnnouncementUncheckedUpdateManyWithoutCreatedByTeacherInput>
  }

  export type UserCreateWithoutStudentLinkInput = {
    id?: string
    email: string
    hashedPassword: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    profilePicture?: string | null
    isActive?: boolean
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    schoolAdmins?: SchoolAdminCreateNestedManyWithoutUserInput
    teacherLinks?: TeacherCreateNestedManyWithoutUserInput
    parentLink?: ParentCreateNestedOneWithoutUserInput
    recordedAttendances?: StudentAttendanceCreateNestedManyWithoutRecordedByInput
    recordedPayments?: PaymentCreateNestedManyWithoutRecordedByInput
  }

  export type UserUncheckedCreateWithoutStudentLinkInput = {
    id?: string
    email: string
    hashedPassword: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    profilePicture?: string | null
    isActive?: boolean
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    schoolAdmins?: SchoolAdminUncheckedCreateNestedManyWithoutUserInput
    teacherLinks?: TeacherUncheckedCreateNestedManyWithoutUserInput
    parentLink?: ParentUncheckedCreateNestedOneWithoutUserInput
    recordedAttendances?: StudentAttendanceUncheckedCreateNestedManyWithoutRecordedByInput
    recordedPayments?: PaymentUncheckedCreateNestedManyWithoutRecordedByInput
  }

  export type UserCreateOrConnectWithoutStudentLinkInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudentLinkInput, UserUncheckedCreateWithoutStudentLinkInput>
  }

  export type SchoolCreateWithoutStudentsInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    schoolEmail: string
    website?: string | null
    logoUrl?: string | null
    currentAcademicYear?: string | null
    currentTerm?: $Enums.TermPeriod | null
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBySuperAdmin?: SuperAdminCreateNestedOneWithoutSchoolsCreatedInput
    admins?: SchoolAdminCreateNestedManyWithoutSchoolInput
    teachers?: TeacherCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    subjects?: SubjectCreateNestedManyWithoutSchoolInput
    feeStructures?: FeeStructureCreateNestedManyWithoutSchoolInput
    invoices?: InvoiceCreateNestedManyWithoutSchoolInput
    timetableSlots?: TimetableSlotCreateNestedManyWithoutSchoolInput
    announcements?: SchoolAnnouncementCreateNestedManyWithoutSchoolInput
    classAnnouncements?: ClassAnnouncementCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutStudentsInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    schoolEmail: string
    website?: string | null
    logoUrl?: string | null
    currentAcademicYear?: string | null
    currentTerm?: $Enums.TermPeriod | null
    currency?: string
    timezone?: string
    isActive?: boolean
    createdBySuperAdminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admins?: SchoolAdminUncheckedCreateNestedManyWithoutSchoolInput
    teachers?: TeacherUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutSchoolInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutSchoolInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSchoolInput
    timetableSlots?: TimetableSlotUncheckedCreateNestedManyWithoutSchoolInput
    announcements?: SchoolAnnouncementUncheckedCreateNestedManyWithoutSchoolInput
    classAnnouncements?: ClassAnnouncementUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutStudentsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutStudentsInput, SchoolUncheckedCreateWithoutStudentsInput>
  }

  export type ClassCreateWithoutCurrentStudentsInput = {
    id?: string
    name: string
    section?: string | null
    academicYear: string
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutClassesInput
    homeroomTeacher?: TeacherCreateNestedOneWithoutClassTeacherOfInput
    studentsEnrolled?: StudentClassEnrollmentCreateNestedManyWithoutClassInput
    timetableSlots?: TimetableSlotCreateNestedManyWithoutClassInput
    assignments?: AssignmentCreateNestedManyWithoutClassInput
    announcements?: ClassAnnouncementCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutCurrentStudentsInput = {
    id?: string
    schoolId: string
    name: string
    section?: string | null
    academicYear: string
    homeroomTeacherId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentsEnrolled?: StudentClassEnrollmentUncheckedCreateNestedManyWithoutClassInput
    timetableSlots?: TimetableSlotUncheckedCreateNestedManyWithoutClassInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClassInput
    announcements?: ClassAnnouncementUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutCurrentStudentsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutCurrentStudentsInput, ClassUncheckedCreateWithoutCurrentStudentsInput>
  }

  export type StudentParentLinkCreateWithoutStudentInput = {
    id?: string
    relationshipToStudent: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parent: ParentCreateNestedOneWithoutChildrenInput
  }

  export type StudentParentLinkUncheckedCreateWithoutStudentInput = {
    id?: string
    parentId: string
    relationshipToStudent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentParentLinkCreateOrConnectWithoutStudentInput = {
    where: StudentParentLinkWhereUniqueInput
    create: XOR<StudentParentLinkCreateWithoutStudentInput, StudentParentLinkUncheckedCreateWithoutStudentInput>
  }

  export type StudentParentLinkCreateManyStudentInputEnvelope = {
    data: StudentParentLinkCreateManyStudentInput | StudentParentLinkCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentClassEnrollmentCreateWithoutStudentInput = {
    id?: string
    academicYear: string
    enrollmentDate?: Date | string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutStudentsEnrolledInput
  }

  export type StudentClassEnrollmentUncheckedCreateWithoutStudentInput = {
    id?: string
    classId: string
    academicYear: string
    enrollmentDate?: Date | string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentClassEnrollmentCreateOrConnectWithoutStudentInput = {
    where: StudentClassEnrollmentWhereUniqueInput
    create: XOR<StudentClassEnrollmentCreateWithoutStudentInput, StudentClassEnrollmentUncheckedCreateWithoutStudentInput>
  }

  export type StudentClassEnrollmentCreateManyStudentInputEnvelope = {
    data: StudentClassEnrollmentCreateManyStudentInput | StudentClassEnrollmentCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentAttendanceCreateWithoutStudentInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    classId?: string | null
    subjectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timetableSlot?: TimetableSlotCreateNestedOneWithoutAttendancesInput
    recordedBy?: UserCreateNestedOneWithoutRecordedAttendancesInput
  }

  export type StudentAttendanceUncheckedCreateWithoutStudentInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    classId?: string | null
    subjectId?: string | null
    timetableSlotId?: string | null
    recordedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAttendanceCreateOrConnectWithoutStudentInput = {
    where: StudentAttendanceWhereUniqueInput
    create: XOR<StudentAttendanceCreateWithoutStudentInput, StudentAttendanceUncheckedCreateWithoutStudentInput>
  }

  export type StudentAttendanceCreateManyStudentInputEnvelope = {
    data: StudentAttendanceCreateManyStudentInput | StudentAttendanceCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentGradeCreateWithoutStudentInput = {
    id?: string
    grade: string
    numericValue?: number | null
    comments?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    dateRecorded?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: SubjectCreateNestedOneWithoutGradesInput
    assignment?: AssignmentCreateNestedOneWithoutGradesInput
    teacher?: TeacherCreateNestedOneWithoutGradesGivenInput
  }

  export type StudentGradeUncheckedCreateWithoutStudentInput = {
    id?: string
    subjectId: string
    assignmentId?: string | null
    teacherId?: string | null
    grade: string
    numericValue?: number | null
    comments?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    dateRecorded?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentGradeCreateOrConnectWithoutStudentInput = {
    where: StudentGradeWhereUniqueInput
    create: XOR<StudentGradeCreateWithoutStudentInput, StudentGradeUncheckedCreateWithoutStudentInput>
  }

  export type StudentGradeCreateManyStudentInputEnvelope = {
    data: StudentGradeCreateManyStudentInput | StudentGradeCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceLineItemCreateWithoutStudentInput = {
    id?: string
    description: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutLineItemsInput
    feeStructure?: FeeStructureCreateNestedOneWithoutInvoiceLineItemsInput
  }

  export type InvoiceLineItemUncheckedCreateWithoutStudentInput = {
    id?: string
    invoiceId: string
    feeStructureId?: string | null
    description: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceLineItemCreateOrConnectWithoutStudentInput = {
    where: InvoiceLineItemWhereUniqueInput
    create: XOR<InvoiceLineItemCreateWithoutStudentInput, InvoiceLineItemUncheckedCreateWithoutStudentInput>
  }

  export type InvoiceLineItemCreateManyStudentInputEnvelope = {
    data: InvoiceLineItemCreateManyStudentInput | InvoiceLineItemCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutStudentInput = {
    id?: string
    invoiceNumber: string
    issueDate: Date | string
    dueDate: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.PaymentStatus
    notes?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutInvoicesInput
    parentToBill?: ParentCreateNestedOneWithoutInvoicesInput
    lineItems?: InvoiceLineItemCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutStudentInput = {
    id?: string
    schoolId: string
    parentToBillId?: string | null
    invoiceNumber: string
    issueDate: Date | string
    dueDate: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.PaymentStatus
    notes?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    createdAt?: Date | string
    updatedAt?: Date | string
    lineItems?: InvoiceLineItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutStudentInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutStudentInput, InvoiceUncheckedCreateWithoutStudentInput>
  }

  export type InvoiceCreateManyStudentInputEnvelope = {
    data: InvoiceCreateManyStudentInput | InvoiceCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutStudentLinkInput = {
    update: XOR<UserUpdateWithoutStudentLinkInput, UserUncheckedUpdateWithoutStudentLinkInput>
    create: XOR<UserCreateWithoutStudentLinkInput, UserUncheckedCreateWithoutStudentLinkInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStudentLinkInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStudentLinkInput, UserUncheckedUpdateWithoutStudentLinkInput>
  }

  export type UserUpdateWithoutStudentLinkInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    schoolAdmins?: SchoolAdminUpdateManyWithoutUserNestedInput
    teacherLinks?: TeacherUpdateManyWithoutUserNestedInput
    parentLink?: ParentUpdateOneWithoutUserNestedInput
    recordedAttendances?: StudentAttendanceUpdateManyWithoutRecordedByNestedInput
    recordedPayments?: PaymentUpdateManyWithoutRecordedByNestedInput
  }

  export type UserUncheckedUpdateWithoutStudentLinkInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    schoolAdmins?: SchoolAdminUncheckedUpdateManyWithoutUserNestedInput
    teacherLinks?: TeacherUncheckedUpdateManyWithoutUserNestedInput
    parentLink?: ParentUncheckedUpdateOneWithoutUserNestedInput
    recordedAttendances?: StudentAttendanceUncheckedUpdateManyWithoutRecordedByNestedInput
    recordedPayments?: PaymentUncheckedUpdateManyWithoutRecordedByNestedInput
  }

  export type SchoolUpsertWithoutStudentsInput = {
    update: XOR<SchoolUpdateWithoutStudentsInput, SchoolUncheckedUpdateWithoutStudentsInput>
    create: XOR<SchoolCreateWithoutStudentsInput, SchoolUncheckedCreateWithoutStudentsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutStudentsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutStudentsInput, SchoolUncheckedUpdateWithoutStudentsInput>
  }

  export type SchoolUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    schoolEmail?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    currentAcademicYear?: NullableStringFieldUpdateOperationsInput | string | null
    currentTerm?: NullableEnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBySuperAdmin?: SuperAdminUpdateOneWithoutSchoolsCreatedNestedInput
    admins?: SchoolAdminUpdateManyWithoutSchoolNestedInput
    teachers?: TeacherUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUpdateManyWithoutSchoolNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutSchoolNestedInput
    invoices?: InvoiceUpdateManyWithoutSchoolNestedInput
    timetableSlots?: TimetableSlotUpdateManyWithoutSchoolNestedInput
    announcements?: SchoolAnnouncementUpdateManyWithoutSchoolNestedInput
    classAnnouncements?: ClassAnnouncementUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    schoolEmail?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    currentAcademicYear?: NullableStringFieldUpdateOperationsInput | string | null
    currentTerm?: NullableEnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBySuperAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admins?: SchoolAdminUncheckedUpdateManyWithoutSchoolNestedInput
    teachers?: TeacherUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutSchoolNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutSchoolNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSchoolNestedInput
    timetableSlots?: TimetableSlotUncheckedUpdateManyWithoutSchoolNestedInput
    announcements?: SchoolAnnouncementUncheckedUpdateManyWithoutSchoolNestedInput
    classAnnouncements?: ClassAnnouncementUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type ClassUpsertWithoutCurrentStudentsInput = {
    update: XOR<ClassUpdateWithoutCurrentStudentsInput, ClassUncheckedUpdateWithoutCurrentStudentsInput>
    create: XOR<ClassCreateWithoutCurrentStudentsInput, ClassUncheckedCreateWithoutCurrentStudentsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutCurrentStudentsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutCurrentStudentsInput, ClassUncheckedUpdateWithoutCurrentStudentsInput>
  }

  export type ClassUpdateWithoutCurrentStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    homeroomTeacher?: TeacherUpdateOneWithoutClassTeacherOfNestedInput
    studentsEnrolled?: StudentClassEnrollmentUpdateManyWithoutClassNestedInput
    timetableSlots?: TimetableSlotUpdateManyWithoutClassNestedInput
    assignments?: AssignmentUpdateManyWithoutClassNestedInput
    announcements?: ClassAnnouncementUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutCurrentStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    homeroomTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentsEnrolled?: StudentClassEnrollmentUncheckedUpdateManyWithoutClassNestedInput
    timetableSlots?: TimetableSlotUncheckedUpdateManyWithoutClassNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutClassNestedInput
    announcements?: ClassAnnouncementUncheckedUpdateManyWithoutClassNestedInput
  }

  export type StudentParentLinkUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentParentLinkWhereUniqueInput
    update: XOR<StudentParentLinkUpdateWithoutStudentInput, StudentParentLinkUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentParentLinkCreateWithoutStudentInput, StudentParentLinkUncheckedCreateWithoutStudentInput>
  }

  export type StudentParentLinkUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentParentLinkWhereUniqueInput
    data: XOR<StudentParentLinkUpdateWithoutStudentInput, StudentParentLinkUncheckedUpdateWithoutStudentInput>
  }

  export type StudentParentLinkUpdateManyWithWhereWithoutStudentInput = {
    where: StudentParentLinkScalarWhereInput
    data: XOR<StudentParentLinkUpdateManyMutationInput, StudentParentLinkUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentParentLinkScalarWhereInput = {
    AND?: StudentParentLinkScalarWhereInput | StudentParentLinkScalarWhereInput[]
    OR?: StudentParentLinkScalarWhereInput[]
    NOT?: StudentParentLinkScalarWhereInput | StudentParentLinkScalarWhereInput[]
    id?: StringFilter<"StudentParentLink"> | string
    studentId?: StringFilter<"StudentParentLink"> | string
    parentId?: StringFilter<"StudentParentLink"> | string
    relationshipToStudent?: StringFilter<"StudentParentLink"> | string
    createdAt?: DateTimeFilter<"StudentParentLink"> | Date | string
    updatedAt?: DateTimeFilter<"StudentParentLink"> | Date | string
  }

  export type StudentClassEnrollmentUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentClassEnrollmentWhereUniqueInput
    update: XOR<StudentClassEnrollmentUpdateWithoutStudentInput, StudentClassEnrollmentUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentClassEnrollmentCreateWithoutStudentInput, StudentClassEnrollmentUncheckedCreateWithoutStudentInput>
  }

  export type StudentClassEnrollmentUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentClassEnrollmentWhereUniqueInput
    data: XOR<StudentClassEnrollmentUpdateWithoutStudentInput, StudentClassEnrollmentUncheckedUpdateWithoutStudentInput>
  }

  export type StudentClassEnrollmentUpdateManyWithWhereWithoutStudentInput = {
    where: StudentClassEnrollmentScalarWhereInput
    data: XOR<StudentClassEnrollmentUpdateManyMutationInput, StudentClassEnrollmentUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentClassEnrollmentScalarWhereInput = {
    AND?: StudentClassEnrollmentScalarWhereInput | StudentClassEnrollmentScalarWhereInput[]
    OR?: StudentClassEnrollmentScalarWhereInput[]
    NOT?: StudentClassEnrollmentScalarWhereInput | StudentClassEnrollmentScalarWhereInput[]
    id?: StringFilter<"StudentClassEnrollment"> | string
    studentId?: StringFilter<"StudentClassEnrollment"> | string
    classId?: StringFilter<"StudentClassEnrollment"> | string
    academicYear?: StringFilter<"StudentClassEnrollment"> | string
    enrollmentDate?: DateTimeFilter<"StudentClassEnrollment"> | Date | string
    isCurrent?: BoolFilter<"StudentClassEnrollment"> | boolean
    createdAt?: DateTimeFilter<"StudentClassEnrollment"> | Date | string
    updatedAt?: DateTimeFilter<"StudentClassEnrollment"> | Date | string
  }

  export type StudentAttendanceUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentAttendanceWhereUniqueInput
    update: XOR<StudentAttendanceUpdateWithoutStudentInput, StudentAttendanceUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentAttendanceCreateWithoutStudentInput, StudentAttendanceUncheckedCreateWithoutStudentInput>
  }

  export type StudentAttendanceUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentAttendanceWhereUniqueInput
    data: XOR<StudentAttendanceUpdateWithoutStudentInput, StudentAttendanceUncheckedUpdateWithoutStudentInput>
  }

  export type StudentAttendanceUpdateManyWithWhereWithoutStudentInput = {
    where: StudentAttendanceScalarWhereInput
    data: XOR<StudentAttendanceUpdateManyMutationInput, StudentAttendanceUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentGradeUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentGradeWhereUniqueInput
    update: XOR<StudentGradeUpdateWithoutStudentInput, StudentGradeUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentGradeCreateWithoutStudentInput, StudentGradeUncheckedCreateWithoutStudentInput>
  }

  export type StudentGradeUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentGradeWhereUniqueInput
    data: XOR<StudentGradeUpdateWithoutStudentInput, StudentGradeUncheckedUpdateWithoutStudentInput>
  }

  export type StudentGradeUpdateManyWithWhereWithoutStudentInput = {
    where: StudentGradeScalarWhereInput
    data: XOR<StudentGradeUpdateManyMutationInput, StudentGradeUncheckedUpdateManyWithoutStudentInput>
  }

  export type InvoiceLineItemUpsertWithWhereUniqueWithoutStudentInput = {
    where: InvoiceLineItemWhereUniqueInput
    update: XOR<InvoiceLineItemUpdateWithoutStudentInput, InvoiceLineItemUncheckedUpdateWithoutStudentInput>
    create: XOR<InvoiceLineItemCreateWithoutStudentInput, InvoiceLineItemUncheckedCreateWithoutStudentInput>
  }

  export type InvoiceLineItemUpdateWithWhereUniqueWithoutStudentInput = {
    where: InvoiceLineItemWhereUniqueInput
    data: XOR<InvoiceLineItemUpdateWithoutStudentInput, InvoiceLineItemUncheckedUpdateWithoutStudentInput>
  }

  export type InvoiceLineItemUpdateManyWithWhereWithoutStudentInput = {
    where: InvoiceLineItemScalarWhereInput
    data: XOR<InvoiceLineItemUpdateManyMutationInput, InvoiceLineItemUncheckedUpdateManyWithoutStudentInput>
  }

  export type InvoiceLineItemScalarWhereInput = {
    AND?: InvoiceLineItemScalarWhereInput | InvoiceLineItemScalarWhereInput[]
    OR?: InvoiceLineItemScalarWhereInput[]
    NOT?: InvoiceLineItemScalarWhereInput | InvoiceLineItemScalarWhereInput[]
    id?: StringFilter<"InvoiceLineItem"> | string
    invoiceId?: StringFilter<"InvoiceLineItem"> | string
    feeStructureId?: StringNullableFilter<"InvoiceLineItem"> | string | null
    studentId?: StringFilter<"InvoiceLineItem"> | string
    description?: StringFilter<"InvoiceLineItem"> | string
    quantity?: IntFilter<"InvoiceLineItem"> | number
    unitPrice?: DecimalFilter<"InvoiceLineItem"> | Decimal | DecimalJsLike | number | string
    amount?: DecimalFilter<"InvoiceLineItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"InvoiceLineItem"> | Date | string
    updatedAt?: DateTimeFilter<"InvoiceLineItem"> | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutStudentInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutStudentInput, InvoiceUncheckedUpdateWithoutStudentInput>
    create: XOR<InvoiceCreateWithoutStudentInput, InvoiceUncheckedCreateWithoutStudentInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutStudentInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutStudentInput, InvoiceUncheckedUpdateWithoutStudentInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutStudentInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutStudentInput>
  }

  export type UserCreateWithoutParentLinkInput = {
    id?: string
    email: string
    hashedPassword: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    profilePicture?: string | null
    isActive?: boolean
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    schoolAdmins?: SchoolAdminCreateNestedManyWithoutUserInput
    teacherLinks?: TeacherCreateNestedManyWithoutUserInput
    studentLink?: StudentCreateNestedOneWithoutUserInput
    recordedAttendances?: StudentAttendanceCreateNestedManyWithoutRecordedByInput
    recordedPayments?: PaymentCreateNestedManyWithoutRecordedByInput
  }

  export type UserUncheckedCreateWithoutParentLinkInput = {
    id?: string
    email: string
    hashedPassword: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    profilePicture?: string | null
    isActive?: boolean
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    schoolAdmins?: SchoolAdminUncheckedCreateNestedManyWithoutUserInput
    teacherLinks?: TeacherUncheckedCreateNestedManyWithoutUserInput
    studentLink?: StudentUncheckedCreateNestedOneWithoutUserInput
    recordedAttendances?: StudentAttendanceUncheckedCreateNestedManyWithoutRecordedByInput
    recordedPayments?: PaymentUncheckedCreateNestedManyWithoutRecordedByInput
  }

  export type UserCreateOrConnectWithoutParentLinkInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutParentLinkInput, UserUncheckedCreateWithoutParentLinkInput>
  }

  export type StudentParentLinkCreateWithoutParentInput = {
    id?: string
    relationshipToStudent: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutParentsInput
  }

  export type StudentParentLinkUncheckedCreateWithoutParentInput = {
    id?: string
    studentId: string
    relationshipToStudent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentParentLinkCreateOrConnectWithoutParentInput = {
    where: StudentParentLinkWhereUniqueInput
    create: XOR<StudentParentLinkCreateWithoutParentInput, StudentParentLinkUncheckedCreateWithoutParentInput>
  }

  export type StudentParentLinkCreateManyParentInputEnvelope = {
    data: StudentParentLinkCreateManyParentInput | StudentParentLinkCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutParentToBillInput = {
    id?: string
    invoiceNumber: string
    issueDate: Date | string
    dueDate: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.PaymentStatus
    notes?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutInvoicesInput
    student: StudentCreateNestedOneWithoutInvoicesInput
    lineItems?: InvoiceLineItemCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutParentToBillInput = {
    id?: string
    schoolId: string
    studentId: string
    invoiceNumber: string
    issueDate: Date | string
    dueDate: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.PaymentStatus
    notes?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    createdAt?: Date | string
    updatedAt?: Date | string
    lineItems?: InvoiceLineItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutParentToBillInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutParentToBillInput, InvoiceUncheckedCreateWithoutParentToBillInput>
  }

  export type InvoiceCreateManyParentToBillInputEnvelope = {
    data: InvoiceCreateManyParentToBillInput | InvoiceCreateManyParentToBillInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutParentLinkInput = {
    update: XOR<UserUpdateWithoutParentLinkInput, UserUncheckedUpdateWithoutParentLinkInput>
    create: XOR<UserCreateWithoutParentLinkInput, UserUncheckedCreateWithoutParentLinkInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutParentLinkInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutParentLinkInput, UserUncheckedUpdateWithoutParentLinkInput>
  }

  export type UserUpdateWithoutParentLinkInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    schoolAdmins?: SchoolAdminUpdateManyWithoutUserNestedInput
    teacherLinks?: TeacherUpdateManyWithoutUserNestedInput
    studentLink?: StudentUpdateOneWithoutUserNestedInput
    recordedAttendances?: StudentAttendanceUpdateManyWithoutRecordedByNestedInput
    recordedPayments?: PaymentUpdateManyWithoutRecordedByNestedInput
  }

  export type UserUncheckedUpdateWithoutParentLinkInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    schoolAdmins?: SchoolAdminUncheckedUpdateManyWithoutUserNestedInput
    teacherLinks?: TeacherUncheckedUpdateManyWithoutUserNestedInput
    studentLink?: StudentUncheckedUpdateOneWithoutUserNestedInput
    recordedAttendances?: StudentAttendanceUncheckedUpdateManyWithoutRecordedByNestedInput
    recordedPayments?: PaymentUncheckedUpdateManyWithoutRecordedByNestedInput
  }

  export type StudentParentLinkUpsertWithWhereUniqueWithoutParentInput = {
    where: StudentParentLinkWhereUniqueInput
    update: XOR<StudentParentLinkUpdateWithoutParentInput, StudentParentLinkUncheckedUpdateWithoutParentInput>
    create: XOR<StudentParentLinkCreateWithoutParentInput, StudentParentLinkUncheckedCreateWithoutParentInput>
  }

  export type StudentParentLinkUpdateWithWhereUniqueWithoutParentInput = {
    where: StudentParentLinkWhereUniqueInput
    data: XOR<StudentParentLinkUpdateWithoutParentInput, StudentParentLinkUncheckedUpdateWithoutParentInput>
  }

  export type StudentParentLinkUpdateManyWithWhereWithoutParentInput = {
    where: StudentParentLinkScalarWhereInput
    data: XOR<StudentParentLinkUpdateManyMutationInput, StudentParentLinkUncheckedUpdateManyWithoutParentInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutParentToBillInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutParentToBillInput, InvoiceUncheckedUpdateWithoutParentToBillInput>
    create: XOR<InvoiceCreateWithoutParentToBillInput, InvoiceUncheckedCreateWithoutParentToBillInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutParentToBillInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutParentToBillInput, InvoiceUncheckedUpdateWithoutParentToBillInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutParentToBillInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutParentToBillInput>
  }

  export type StudentCreateWithoutParentsInput = {
    id?: string
    studentIdNumber: string
    firstName: string
    lastName: string
    middleName?: string | null
    dateOfBirth: Date | string
    gender: $Enums.Gender
    enrollmentDate: Date | string
    profilePictureUrl?: string | null
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    bloodGroup?: string | null
    allergies?: string | null
    medicalNotes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentLinkInput
    school: SchoolCreateNestedOneWithoutStudentsInput
    currentClass?: ClassCreateNestedOneWithoutCurrentStudentsInput
    enrollments?: StudentClassEnrollmentCreateNestedManyWithoutStudentInput
    attendances?: StudentAttendanceCreateNestedManyWithoutStudentInput
    grades?: StudentGradeCreateNestedManyWithoutStudentInput
    invoiceLineItems?: InvoiceLineItemCreateNestedManyWithoutStudentInput
    invoices?: InvoiceCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutParentsInput = {
    id?: string
    userId?: string | null
    schoolId: string
    studentIdNumber: string
    firstName: string
    lastName: string
    middleName?: string | null
    dateOfBirth: Date | string
    gender: $Enums.Gender
    enrollmentDate: Date | string
    profilePictureUrl?: string | null
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    bloodGroup?: string | null
    allergies?: string | null
    medicalNotes?: string | null
    isActive?: boolean
    currentClassId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: StudentClassEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    attendances?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    grades?: StudentGradeUncheckedCreateNestedManyWithoutStudentInput
    invoiceLineItems?: InvoiceLineItemUncheckedCreateNestedManyWithoutStudentInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutParentsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutParentsInput, StudentUncheckedCreateWithoutParentsInput>
  }

  export type ParentCreateWithoutChildrenInput = {
    id?: string
    occupation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutParentLinkInput
    invoices?: InvoiceCreateNestedManyWithoutParentToBillInput
  }

  export type ParentUncheckedCreateWithoutChildrenInput = {
    id?: string
    userId: string
    occupation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutParentToBillInput
  }

  export type ParentCreateOrConnectWithoutChildrenInput = {
    where: ParentWhereUniqueInput
    create: XOR<ParentCreateWithoutChildrenInput, ParentUncheckedCreateWithoutChildrenInput>
  }

  export type StudentUpsertWithoutParentsInput = {
    update: XOR<StudentUpdateWithoutParentsInput, StudentUncheckedUpdateWithoutParentsInput>
    create: XOR<StudentCreateWithoutParentsInput, StudentUncheckedCreateWithoutParentsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutParentsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutParentsInput, StudentUncheckedUpdateWithoutParentsInput>
  }

  export type StudentUpdateWithoutParentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentIdNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentLinkNestedInput
    school?: SchoolUpdateOneRequiredWithoutStudentsNestedInput
    currentClass?: ClassUpdateOneWithoutCurrentStudentsNestedInput
    enrollments?: StudentClassEnrollmentUpdateManyWithoutStudentNestedInput
    attendances?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    grades?: StudentGradeUpdateManyWithoutStudentNestedInput
    invoiceLineItems?: InvoiceLineItemUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutParentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    studentIdNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    currentClassId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: StudentClassEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    grades?: StudentGradeUncheckedUpdateManyWithoutStudentNestedInput
    invoiceLineItems?: InvoiceLineItemUncheckedUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ParentUpsertWithoutChildrenInput = {
    update: XOR<ParentUpdateWithoutChildrenInput, ParentUncheckedUpdateWithoutChildrenInput>
    create: XOR<ParentCreateWithoutChildrenInput, ParentUncheckedCreateWithoutChildrenInput>
    where?: ParentWhereInput
  }

  export type ParentUpdateToOneWithWhereWithoutChildrenInput = {
    where?: ParentWhereInput
    data: XOR<ParentUpdateWithoutChildrenInput, ParentUncheckedUpdateWithoutChildrenInput>
  }

  export type ParentUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutParentLinkNestedInput
    invoices?: InvoiceUpdateManyWithoutParentToBillNestedInput
  }

  export type ParentUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutParentToBillNestedInput
  }

  export type SchoolCreateWithoutClassesInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    schoolEmail: string
    website?: string | null
    logoUrl?: string | null
    currentAcademicYear?: string | null
    currentTerm?: $Enums.TermPeriod | null
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBySuperAdmin?: SuperAdminCreateNestedOneWithoutSchoolsCreatedInput
    admins?: SchoolAdminCreateNestedManyWithoutSchoolInput
    teachers?: TeacherCreateNestedManyWithoutSchoolInput
    students?: StudentCreateNestedManyWithoutSchoolInput
    subjects?: SubjectCreateNestedManyWithoutSchoolInput
    feeStructures?: FeeStructureCreateNestedManyWithoutSchoolInput
    invoices?: InvoiceCreateNestedManyWithoutSchoolInput
    timetableSlots?: TimetableSlotCreateNestedManyWithoutSchoolInput
    announcements?: SchoolAnnouncementCreateNestedManyWithoutSchoolInput
    classAnnouncements?: ClassAnnouncementCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutClassesInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    schoolEmail: string
    website?: string | null
    logoUrl?: string | null
    currentAcademicYear?: string | null
    currentTerm?: $Enums.TermPeriod | null
    currency?: string
    timezone?: string
    isActive?: boolean
    createdBySuperAdminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admins?: SchoolAdminUncheckedCreateNestedManyWithoutSchoolInput
    teachers?: TeacherUncheckedCreateNestedManyWithoutSchoolInput
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutSchoolInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutSchoolInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSchoolInput
    timetableSlots?: TimetableSlotUncheckedCreateNestedManyWithoutSchoolInput
    announcements?: SchoolAnnouncementUncheckedCreateNestedManyWithoutSchoolInput
    classAnnouncements?: ClassAnnouncementUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutClassesInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutClassesInput, SchoolUncheckedCreateWithoutClassesInput>
  }

  export type TeacherCreateWithoutClassTeacherOfInput = {
    id?: string
    teacherIdNumber?: string | null
    dateOfJoining?: Date | string | null
    qualifications?: string | null
    specialization?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTeacherLinksInput
    school: SchoolCreateNestedOneWithoutTeachersInput
    timetableSlots?: TimetableSlotCreateNestedManyWithoutTeacherInput
    gradesGiven?: StudentGradeCreateNestedManyWithoutTeacherInput
    assignmentsCreated?: AssignmentCreateNestedManyWithoutTeacherInput
    createdClassAnnouncements?: ClassAnnouncementCreateNestedManyWithoutCreatedByTeacherInput
  }

  export type TeacherUncheckedCreateWithoutClassTeacherOfInput = {
    id?: string
    userId: string
    schoolId: string
    teacherIdNumber?: string | null
    dateOfJoining?: Date | string | null
    qualifications?: string | null
    specialization?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timetableSlots?: TimetableSlotUncheckedCreateNestedManyWithoutTeacherInput
    gradesGiven?: StudentGradeUncheckedCreateNestedManyWithoutTeacherInput
    assignmentsCreated?: AssignmentUncheckedCreateNestedManyWithoutTeacherInput
    createdClassAnnouncements?: ClassAnnouncementUncheckedCreateNestedManyWithoutCreatedByTeacherInput
  }

  export type TeacherCreateOrConnectWithoutClassTeacherOfInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutClassTeacherOfInput, TeacherUncheckedCreateWithoutClassTeacherOfInput>
  }

  export type StudentClassEnrollmentCreateWithoutClassInput = {
    id?: string
    academicYear: string
    enrollmentDate?: Date | string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutEnrollmentsInput
  }

  export type StudentClassEnrollmentUncheckedCreateWithoutClassInput = {
    id?: string
    studentId: string
    academicYear: string
    enrollmentDate?: Date | string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentClassEnrollmentCreateOrConnectWithoutClassInput = {
    where: StudentClassEnrollmentWhereUniqueInput
    create: XOR<StudentClassEnrollmentCreateWithoutClassInput, StudentClassEnrollmentUncheckedCreateWithoutClassInput>
  }

  export type StudentClassEnrollmentCreateManyClassInputEnvelope = {
    data: StudentClassEnrollmentCreateManyClassInput | StudentClassEnrollmentCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutCurrentClassInput = {
    id?: string
    studentIdNumber: string
    firstName: string
    lastName: string
    middleName?: string | null
    dateOfBirth: Date | string
    gender: $Enums.Gender
    enrollmentDate: Date | string
    profilePictureUrl?: string | null
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    bloodGroup?: string | null
    allergies?: string | null
    medicalNotes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentLinkInput
    school: SchoolCreateNestedOneWithoutStudentsInput
    parents?: StudentParentLinkCreateNestedManyWithoutStudentInput
    enrollments?: StudentClassEnrollmentCreateNestedManyWithoutStudentInput
    attendances?: StudentAttendanceCreateNestedManyWithoutStudentInput
    grades?: StudentGradeCreateNestedManyWithoutStudentInput
    invoiceLineItems?: InvoiceLineItemCreateNestedManyWithoutStudentInput
    invoices?: InvoiceCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutCurrentClassInput = {
    id?: string
    userId?: string | null
    schoolId: string
    studentIdNumber: string
    firstName: string
    lastName: string
    middleName?: string | null
    dateOfBirth: Date | string
    gender: $Enums.Gender
    enrollmentDate: Date | string
    profilePictureUrl?: string | null
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    bloodGroup?: string | null
    allergies?: string | null
    medicalNotes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: StudentParentLinkUncheckedCreateNestedManyWithoutStudentInput
    enrollments?: StudentClassEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    attendances?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    grades?: StudentGradeUncheckedCreateNestedManyWithoutStudentInput
    invoiceLineItems?: InvoiceLineItemUncheckedCreateNestedManyWithoutStudentInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutCurrentClassInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutCurrentClassInput, StudentUncheckedCreateWithoutCurrentClassInput>
  }

  export type StudentCreateManyCurrentClassInputEnvelope = {
    data: StudentCreateManyCurrentClassInput | StudentCreateManyCurrentClassInput[]
    skipDuplicates?: boolean
  }

  export type TimetableSlotCreateWithoutClassInput = {
    id?: string
    dayOfWeek: $Enums.DayOfWeek
    startTime: string
    endTime: string
    room?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutTimetableSlotsInput
    subject: SubjectCreateNestedOneWithoutTimetableSlotsInput
    teacher: TeacherCreateNestedOneWithoutTimetableSlotsInput
    attendances?: StudentAttendanceCreateNestedManyWithoutTimetableSlotInput
  }

  export type TimetableSlotUncheckedCreateWithoutClassInput = {
    id?: string
    schoolId: string
    subjectId: string
    teacherId: string
    dayOfWeek: $Enums.DayOfWeek
    startTime: string
    endTime: string
    room?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendances?: StudentAttendanceUncheckedCreateNestedManyWithoutTimetableSlotInput
  }

  export type TimetableSlotCreateOrConnectWithoutClassInput = {
    where: TimetableSlotWhereUniqueInput
    create: XOR<TimetableSlotCreateWithoutClassInput, TimetableSlotUncheckedCreateWithoutClassInput>
  }

  export type TimetableSlotCreateManyClassInputEnvelope = {
    data: TimetableSlotCreateManyClassInput | TimetableSlotCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type AssignmentCreateWithoutClassInput = {
    id?: string
    schoolId: string
    title: string
    description?: string | null
    maxPoints?: number | null
    dueDate?: Date | string | null
    academicYear: string
    term: $Enums.TermPeriod
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: SubjectCreateNestedOneWithoutAssignmentsInput
    teacher: TeacherCreateNestedOneWithoutAssignmentsCreatedInput
    grades?: StudentGradeCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentUncheckedCreateWithoutClassInput = {
    id?: string
    schoolId: string
    subjectId: string
    teacherId: string
    title: string
    description?: string | null
    maxPoints?: number | null
    dueDate?: Date | string | null
    academicYear: string
    term: $Enums.TermPeriod
    createdAt?: Date | string
    updatedAt?: Date | string
    grades?: StudentGradeUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentCreateOrConnectWithoutClassInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutClassInput, AssignmentUncheckedCreateWithoutClassInput>
  }

  export type AssignmentCreateManyClassInputEnvelope = {
    data: AssignmentCreateManyClassInput | AssignmentCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type ClassAnnouncementCreateWithoutClassInput = {
    id?: string
    title: string
    content: string
    publishDate: Date | string
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutClassAnnouncementsInput
    createdByTeacher?: TeacherCreateNestedOneWithoutCreatedClassAnnouncementsInput
  }

  export type ClassAnnouncementUncheckedCreateWithoutClassInput = {
    id?: string
    schoolId: string
    title: string
    content: string
    publishDate: Date | string
    isPublished?: boolean
    createdByTeacherId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassAnnouncementCreateOrConnectWithoutClassInput = {
    where: ClassAnnouncementWhereUniqueInput
    create: XOR<ClassAnnouncementCreateWithoutClassInput, ClassAnnouncementUncheckedCreateWithoutClassInput>
  }

  export type ClassAnnouncementCreateManyClassInputEnvelope = {
    data: ClassAnnouncementCreateManyClassInput | ClassAnnouncementCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type SchoolUpsertWithoutClassesInput = {
    update: XOR<SchoolUpdateWithoutClassesInput, SchoolUncheckedUpdateWithoutClassesInput>
    create: XOR<SchoolCreateWithoutClassesInput, SchoolUncheckedCreateWithoutClassesInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutClassesInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutClassesInput, SchoolUncheckedUpdateWithoutClassesInput>
  }

  export type SchoolUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    schoolEmail?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    currentAcademicYear?: NullableStringFieldUpdateOperationsInput | string | null
    currentTerm?: NullableEnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBySuperAdmin?: SuperAdminUpdateOneWithoutSchoolsCreatedNestedInput
    admins?: SchoolAdminUpdateManyWithoutSchoolNestedInput
    teachers?: TeacherUpdateManyWithoutSchoolNestedInput
    students?: StudentUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUpdateManyWithoutSchoolNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutSchoolNestedInput
    invoices?: InvoiceUpdateManyWithoutSchoolNestedInput
    timetableSlots?: TimetableSlotUpdateManyWithoutSchoolNestedInput
    announcements?: SchoolAnnouncementUpdateManyWithoutSchoolNestedInput
    classAnnouncements?: ClassAnnouncementUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    schoolEmail?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    currentAcademicYear?: NullableStringFieldUpdateOperationsInput | string | null
    currentTerm?: NullableEnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBySuperAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admins?: SchoolAdminUncheckedUpdateManyWithoutSchoolNestedInput
    teachers?: TeacherUncheckedUpdateManyWithoutSchoolNestedInput
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutSchoolNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutSchoolNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSchoolNestedInput
    timetableSlots?: TimetableSlotUncheckedUpdateManyWithoutSchoolNestedInput
    announcements?: SchoolAnnouncementUncheckedUpdateManyWithoutSchoolNestedInput
    classAnnouncements?: ClassAnnouncementUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type TeacherUpsertWithoutClassTeacherOfInput = {
    update: XOR<TeacherUpdateWithoutClassTeacherOfInput, TeacherUncheckedUpdateWithoutClassTeacherOfInput>
    create: XOR<TeacherCreateWithoutClassTeacherOfInput, TeacherUncheckedCreateWithoutClassTeacherOfInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutClassTeacherOfInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutClassTeacherOfInput, TeacherUncheckedUpdateWithoutClassTeacherOfInput>
  }

  export type TeacherUpdateWithoutClassTeacherOfInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeacherLinksNestedInput
    school?: SchoolUpdateOneRequiredWithoutTeachersNestedInput
    timetableSlots?: TimetableSlotUpdateManyWithoutTeacherNestedInput
    gradesGiven?: StudentGradeUpdateManyWithoutTeacherNestedInput
    assignmentsCreated?: AssignmentUpdateManyWithoutTeacherNestedInput
    createdClassAnnouncements?: ClassAnnouncementUpdateManyWithoutCreatedByTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutClassTeacherOfInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    teacherIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timetableSlots?: TimetableSlotUncheckedUpdateManyWithoutTeacherNestedInput
    gradesGiven?: StudentGradeUncheckedUpdateManyWithoutTeacherNestedInput
    assignmentsCreated?: AssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    createdClassAnnouncements?: ClassAnnouncementUncheckedUpdateManyWithoutCreatedByTeacherNestedInput
  }

  export type StudentClassEnrollmentUpsertWithWhereUniqueWithoutClassInput = {
    where: StudentClassEnrollmentWhereUniqueInput
    update: XOR<StudentClassEnrollmentUpdateWithoutClassInput, StudentClassEnrollmentUncheckedUpdateWithoutClassInput>
    create: XOR<StudentClassEnrollmentCreateWithoutClassInput, StudentClassEnrollmentUncheckedCreateWithoutClassInput>
  }

  export type StudentClassEnrollmentUpdateWithWhereUniqueWithoutClassInput = {
    where: StudentClassEnrollmentWhereUniqueInput
    data: XOR<StudentClassEnrollmentUpdateWithoutClassInput, StudentClassEnrollmentUncheckedUpdateWithoutClassInput>
  }

  export type StudentClassEnrollmentUpdateManyWithWhereWithoutClassInput = {
    where: StudentClassEnrollmentScalarWhereInput
    data: XOR<StudentClassEnrollmentUpdateManyMutationInput, StudentClassEnrollmentUncheckedUpdateManyWithoutClassInput>
  }

  export type StudentUpsertWithWhereUniqueWithoutCurrentClassInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutCurrentClassInput, StudentUncheckedUpdateWithoutCurrentClassInput>
    create: XOR<StudentCreateWithoutCurrentClassInput, StudentUncheckedCreateWithoutCurrentClassInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutCurrentClassInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutCurrentClassInput, StudentUncheckedUpdateWithoutCurrentClassInput>
  }

  export type StudentUpdateManyWithWhereWithoutCurrentClassInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutCurrentClassInput>
  }

  export type TimetableSlotUpsertWithWhereUniqueWithoutClassInput = {
    where: TimetableSlotWhereUniqueInput
    update: XOR<TimetableSlotUpdateWithoutClassInput, TimetableSlotUncheckedUpdateWithoutClassInput>
    create: XOR<TimetableSlotCreateWithoutClassInput, TimetableSlotUncheckedCreateWithoutClassInput>
  }

  export type TimetableSlotUpdateWithWhereUniqueWithoutClassInput = {
    where: TimetableSlotWhereUniqueInput
    data: XOR<TimetableSlotUpdateWithoutClassInput, TimetableSlotUncheckedUpdateWithoutClassInput>
  }

  export type TimetableSlotUpdateManyWithWhereWithoutClassInput = {
    where: TimetableSlotScalarWhereInput
    data: XOR<TimetableSlotUpdateManyMutationInput, TimetableSlotUncheckedUpdateManyWithoutClassInput>
  }

  export type AssignmentUpsertWithWhereUniqueWithoutClassInput = {
    where: AssignmentWhereUniqueInput
    update: XOR<AssignmentUpdateWithoutClassInput, AssignmentUncheckedUpdateWithoutClassInput>
    create: XOR<AssignmentCreateWithoutClassInput, AssignmentUncheckedCreateWithoutClassInput>
  }

  export type AssignmentUpdateWithWhereUniqueWithoutClassInput = {
    where: AssignmentWhereUniqueInput
    data: XOR<AssignmentUpdateWithoutClassInput, AssignmentUncheckedUpdateWithoutClassInput>
  }

  export type AssignmentUpdateManyWithWhereWithoutClassInput = {
    where: AssignmentScalarWhereInput
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyWithoutClassInput>
  }

  export type ClassAnnouncementUpsertWithWhereUniqueWithoutClassInput = {
    where: ClassAnnouncementWhereUniqueInput
    update: XOR<ClassAnnouncementUpdateWithoutClassInput, ClassAnnouncementUncheckedUpdateWithoutClassInput>
    create: XOR<ClassAnnouncementCreateWithoutClassInput, ClassAnnouncementUncheckedCreateWithoutClassInput>
  }

  export type ClassAnnouncementUpdateWithWhereUniqueWithoutClassInput = {
    where: ClassAnnouncementWhereUniqueInput
    data: XOR<ClassAnnouncementUpdateWithoutClassInput, ClassAnnouncementUncheckedUpdateWithoutClassInput>
  }

  export type ClassAnnouncementUpdateManyWithWhereWithoutClassInput = {
    where: ClassAnnouncementScalarWhereInput
    data: XOR<ClassAnnouncementUpdateManyMutationInput, ClassAnnouncementUncheckedUpdateManyWithoutClassInput>
  }

  export type StudentCreateWithoutEnrollmentsInput = {
    id?: string
    studentIdNumber: string
    firstName: string
    lastName: string
    middleName?: string | null
    dateOfBirth: Date | string
    gender: $Enums.Gender
    enrollmentDate: Date | string
    profilePictureUrl?: string | null
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    bloodGroup?: string | null
    allergies?: string | null
    medicalNotes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentLinkInput
    school: SchoolCreateNestedOneWithoutStudentsInput
    currentClass?: ClassCreateNestedOneWithoutCurrentStudentsInput
    parents?: StudentParentLinkCreateNestedManyWithoutStudentInput
    attendances?: StudentAttendanceCreateNestedManyWithoutStudentInput
    grades?: StudentGradeCreateNestedManyWithoutStudentInput
    invoiceLineItems?: InvoiceLineItemCreateNestedManyWithoutStudentInput
    invoices?: InvoiceCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    userId?: string | null
    schoolId: string
    studentIdNumber: string
    firstName: string
    lastName: string
    middleName?: string | null
    dateOfBirth: Date | string
    gender: $Enums.Gender
    enrollmentDate: Date | string
    profilePictureUrl?: string | null
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    bloodGroup?: string | null
    allergies?: string | null
    medicalNotes?: string | null
    isActive?: boolean
    currentClassId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: StudentParentLinkUncheckedCreateNestedManyWithoutStudentInput
    attendances?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    grades?: StudentGradeUncheckedCreateNestedManyWithoutStudentInput
    invoiceLineItems?: InvoiceLineItemUncheckedCreateNestedManyWithoutStudentInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutEnrollmentsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutEnrollmentsInput, StudentUncheckedCreateWithoutEnrollmentsInput>
  }

  export type ClassCreateWithoutStudentsEnrolledInput = {
    id?: string
    name: string
    section?: string | null
    academicYear: string
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutClassesInput
    homeroomTeacher?: TeacherCreateNestedOneWithoutClassTeacherOfInput
    currentStudents?: StudentCreateNestedManyWithoutCurrentClassInput
    timetableSlots?: TimetableSlotCreateNestedManyWithoutClassInput
    assignments?: AssignmentCreateNestedManyWithoutClassInput
    announcements?: ClassAnnouncementCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutStudentsEnrolledInput = {
    id?: string
    schoolId: string
    name: string
    section?: string | null
    academicYear: string
    homeroomTeacherId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentStudents?: StudentUncheckedCreateNestedManyWithoutCurrentClassInput
    timetableSlots?: TimetableSlotUncheckedCreateNestedManyWithoutClassInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClassInput
    announcements?: ClassAnnouncementUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutStudentsEnrolledInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutStudentsEnrolledInput, ClassUncheckedCreateWithoutStudentsEnrolledInput>
  }

  export type StudentUpsertWithoutEnrollmentsInput = {
    update: XOR<StudentUpdateWithoutEnrollmentsInput, StudentUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<StudentCreateWithoutEnrollmentsInput, StudentUncheckedCreateWithoutEnrollmentsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutEnrollmentsInput, StudentUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type StudentUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentIdNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentLinkNestedInput
    school?: SchoolUpdateOneRequiredWithoutStudentsNestedInput
    currentClass?: ClassUpdateOneWithoutCurrentStudentsNestedInput
    parents?: StudentParentLinkUpdateManyWithoutStudentNestedInput
    attendances?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    grades?: StudentGradeUpdateManyWithoutStudentNestedInput
    invoiceLineItems?: InvoiceLineItemUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    studentIdNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    currentClassId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: StudentParentLinkUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    grades?: StudentGradeUncheckedUpdateManyWithoutStudentNestedInput
    invoiceLineItems?: InvoiceLineItemUncheckedUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ClassUpsertWithoutStudentsEnrolledInput = {
    update: XOR<ClassUpdateWithoutStudentsEnrolledInput, ClassUncheckedUpdateWithoutStudentsEnrolledInput>
    create: XOR<ClassCreateWithoutStudentsEnrolledInput, ClassUncheckedCreateWithoutStudentsEnrolledInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutStudentsEnrolledInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutStudentsEnrolledInput, ClassUncheckedUpdateWithoutStudentsEnrolledInput>
  }

  export type ClassUpdateWithoutStudentsEnrolledInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    homeroomTeacher?: TeacherUpdateOneWithoutClassTeacherOfNestedInput
    currentStudents?: StudentUpdateManyWithoutCurrentClassNestedInput
    timetableSlots?: TimetableSlotUpdateManyWithoutClassNestedInput
    assignments?: AssignmentUpdateManyWithoutClassNestedInput
    announcements?: ClassAnnouncementUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutStudentsEnrolledInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    homeroomTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentStudents?: StudentUncheckedUpdateManyWithoutCurrentClassNestedInput
    timetableSlots?: TimetableSlotUncheckedUpdateManyWithoutClassNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutClassNestedInput
    announcements?: ClassAnnouncementUncheckedUpdateManyWithoutClassNestedInput
  }

  export type SchoolCreateWithoutSubjectsInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    schoolEmail: string
    website?: string | null
    logoUrl?: string | null
    currentAcademicYear?: string | null
    currentTerm?: $Enums.TermPeriod | null
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBySuperAdmin?: SuperAdminCreateNestedOneWithoutSchoolsCreatedInput
    admins?: SchoolAdminCreateNestedManyWithoutSchoolInput
    teachers?: TeacherCreateNestedManyWithoutSchoolInput
    students?: StudentCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    feeStructures?: FeeStructureCreateNestedManyWithoutSchoolInput
    invoices?: InvoiceCreateNestedManyWithoutSchoolInput
    timetableSlots?: TimetableSlotCreateNestedManyWithoutSchoolInput
    announcements?: SchoolAnnouncementCreateNestedManyWithoutSchoolInput
    classAnnouncements?: ClassAnnouncementCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutSubjectsInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    schoolEmail: string
    website?: string | null
    logoUrl?: string | null
    currentAcademicYear?: string | null
    currentTerm?: $Enums.TermPeriod | null
    currency?: string
    timezone?: string
    isActive?: boolean
    createdBySuperAdminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admins?: SchoolAdminUncheckedCreateNestedManyWithoutSchoolInput
    teachers?: TeacherUncheckedCreateNestedManyWithoutSchoolInput
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutSchoolInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSchoolInput
    timetableSlots?: TimetableSlotUncheckedCreateNestedManyWithoutSchoolInput
    announcements?: SchoolAnnouncementUncheckedCreateNestedManyWithoutSchoolInput
    classAnnouncements?: ClassAnnouncementUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutSubjectsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutSubjectsInput, SchoolUncheckedCreateWithoutSubjectsInput>
  }

  export type TimetableSlotCreateWithoutSubjectInput = {
    id?: string
    dayOfWeek: $Enums.DayOfWeek
    startTime: string
    endTime: string
    room?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutTimetableSlotsInput
    class: ClassCreateNestedOneWithoutTimetableSlotsInput
    teacher: TeacherCreateNestedOneWithoutTimetableSlotsInput
    attendances?: StudentAttendanceCreateNestedManyWithoutTimetableSlotInput
  }

  export type TimetableSlotUncheckedCreateWithoutSubjectInput = {
    id?: string
    schoolId: string
    classId: string
    teacherId: string
    dayOfWeek: $Enums.DayOfWeek
    startTime: string
    endTime: string
    room?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendances?: StudentAttendanceUncheckedCreateNestedManyWithoutTimetableSlotInput
  }

  export type TimetableSlotCreateOrConnectWithoutSubjectInput = {
    where: TimetableSlotWhereUniqueInput
    create: XOR<TimetableSlotCreateWithoutSubjectInput, TimetableSlotUncheckedCreateWithoutSubjectInput>
  }

  export type TimetableSlotCreateManySubjectInputEnvelope = {
    data: TimetableSlotCreateManySubjectInput | TimetableSlotCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type AssignmentCreateWithoutSubjectInput = {
    id?: string
    schoolId: string
    title: string
    description?: string | null
    maxPoints?: number | null
    dueDate?: Date | string | null
    academicYear: string
    term: $Enums.TermPeriod
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutAssignmentsInput
    teacher: TeacherCreateNestedOneWithoutAssignmentsCreatedInput
    grades?: StudentGradeCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentUncheckedCreateWithoutSubjectInput = {
    id?: string
    schoolId: string
    classId: string
    teacherId: string
    title: string
    description?: string | null
    maxPoints?: number | null
    dueDate?: Date | string | null
    academicYear: string
    term: $Enums.TermPeriod
    createdAt?: Date | string
    updatedAt?: Date | string
    grades?: StudentGradeUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentCreateOrConnectWithoutSubjectInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutSubjectInput, AssignmentUncheckedCreateWithoutSubjectInput>
  }

  export type AssignmentCreateManySubjectInputEnvelope = {
    data: AssignmentCreateManySubjectInput | AssignmentCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type StudentGradeCreateWithoutSubjectInput = {
    id?: string
    grade: string
    numericValue?: number | null
    comments?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    dateRecorded?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutGradesInput
    assignment?: AssignmentCreateNestedOneWithoutGradesInput
    teacher?: TeacherCreateNestedOneWithoutGradesGivenInput
  }

  export type StudentGradeUncheckedCreateWithoutSubjectInput = {
    id?: string
    studentId: string
    assignmentId?: string | null
    teacherId?: string | null
    grade: string
    numericValue?: number | null
    comments?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    dateRecorded?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentGradeCreateOrConnectWithoutSubjectInput = {
    where: StudentGradeWhereUniqueInput
    create: XOR<StudentGradeCreateWithoutSubjectInput, StudentGradeUncheckedCreateWithoutSubjectInput>
  }

  export type StudentGradeCreateManySubjectInputEnvelope = {
    data: StudentGradeCreateManySubjectInput | StudentGradeCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type SchoolUpsertWithoutSubjectsInput = {
    update: XOR<SchoolUpdateWithoutSubjectsInput, SchoolUncheckedUpdateWithoutSubjectsInput>
    create: XOR<SchoolCreateWithoutSubjectsInput, SchoolUncheckedCreateWithoutSubjectsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutSubjectsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutSubjectsInput, SchoolUncheckedUpdateWithoutSubjectsInput>
  }

  export type SchoolUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    schoolEmail?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    currentAcademicYear?: NullableStringFieldUpdateOperationsInput | string | null
    currentTerm?: NullableEnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBySuperAdmin?: SuperAdminUpdateOneWithoutSchoolsCreatedNestedInput
    admins?: SchoolAdminUpdateManyWithoutSchoolNestedInput
    teachers?: TeacherUpdateManyWithoutSchoolNestedInput
    students?: StudentUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutSchoolNestedInput
    invoices?: InvoiceUpdateManyWithoutSchoolNestedInput
    timetableSlots?: TimetableSlotUpdateManyWithoutSchoolNestedInput
    announcements?: SchoolAnnouncementUpdateManyWithoutSchoolNestedInput
    classAnnouncements?: ClassAnnouncementUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    schoolEmail?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    currentAcademicYear?: NullableStringFieldUpdateOperationsInput | string | null
    currentTerm?: NullableEnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBySuperAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admins?: SchoolAdminUncheckedUpdateManyWithoutSchoolNestedInput
    teachers?: TeacherUncheckedUpdateManyWithoutSchoolNestedInput
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutSchoolNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSchoolNestedInput
    timetableSlots?: TimetableSlotUncheckedUpdateManyWithoutSchoolNestedInput
    announcements?: SchoolAnnouncementUncheckedUpdateManyWithoutSchoolNestedInput
    classAnnouncements?: ClassAnnouncementUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type TimetableSlotUpsertWithWhereUniqueWithoutSubjectInput = {
    where: TimetableSlotWhereUniqueInput
    update: XOR<TimetableSlotUpdateWithoutSubjectInput, TimetableSlotUncheckedUpdateWithoutSubjectInput>
    create: XOR<TimetableSlotCreateWithoutSubjectInput, TimetableSlotUncheckedCreateWithoutSubjectInput>
  }

  export type TimetableSlotUpdateWithWhereUniqueWithoutSubjectInput = {
    where: TimetableSlotWhereUniqueInput
    data: XOR<TimetableSlotUpdateWithoutSubjectInput, TimetableSlotUncheckedUpdateWithoutSubjectInput>
  }

  export type TimetableSlotUpdateManyWithWhereWithoutSubjectInput = {
    where: TimetableSlotScalarWhereInput
    data: XOR<TimetableSlotUpdateManyMutationInput, TimetableSlotUncheckedUpdateManyWithoutSubjectInput>
  }

  export type AssignmentUpsertWithWhereUniqueWithoutSubjectInput = {
    where: AssignmentWhereUniqueInput
    update: XOR<AssignmentUpdateWithoutSubjectInput, AssignmentUncheckedUpdateWithoutSubjectInput>
    create: XOR<AssignmentCreateWithoutSubjectInput, AssignmentUncheckedCreateWithoutSubjectInput>
  }

  export type AssignmentUpdateWithWhereUniqueWithoutSubjectInput = {
    where: AssignmentWhereUniqueInput
    data: XOR<AssignmentUpdateWithoutSubjectInput, AssignmentUncheckedUpdateWithoutSubjectInput>
  }

  export type AssignmentUpdateManyWithWhereWithoutSubjectInput = {
    where: AssignmentScalarWhereInput
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyWithoutSubjectInput>
  }

  export type StudentGradeUpsertWithWhereUniqueWithoutSubjectInput = {
    where: StudentGradeWhereUniqueInput
    update: XOR<StudentGradeUpdateWithoutSubjectInput, StudentGradeUncheckedUpdateWithoutSubjectInput>
    create: XOR<StudentGradeCreateWithoutSubjectInput, StudentGradeUncheckedCreateWithoutSubjectInput>
  }

  export type StudentGradeUpdateWithWhereUniqueWithoutSubjectInput = {
    where: StudentGradeWhereUniqueInput
    data: XOR<StudentGradeUpdateWithoutSubjectInput, StudentGradeUncheckedUpdateWithoutSubjectInput>
  }

  export type StudentGradeUpdateManyWithWhereWithoutSubjectInput = {
    where: StudentGradeScalarWhereInput
    data: XOR<StudentGradeUpdateManyMutationInput, StudentGradeUncheckedUpdateManyWithoutSubjectInput>
  }

  export type SchoolCreateWithoutTimetableSlotsInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    schoolEmail: string
    website?: string | null
    logoUrl?: string | null
    currentAcademicYear?: string | null
    currentTerm?: $Enums.TermPeriod | null
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBySuperAdmin?: SuperAdminCreateNestedOneWithoutSchoolsCreatedInput
    admins?: SchoolAdminCreateNestedManyWithoutSchoolInput
    teachers?: TeacherCreateNestedManyWithoutSchoolInput
    students?: StudentCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    subjects?: SubjectCreateNestedManyWithoutSchoolInput
    feeStructures?: FeeStructureCreateNestedManyWithoutSchoolInput
    invoices?: InvoiceCreateNestedManyWithoutSchoolInput
    announcements?: SchoolAnnouncementCreateNestedManyWithoutSchoolInput
    classAnnouncements?: ClassAnnouncementCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutTimetableSlotsInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    schoolEmail: string
    website?: string | null
    logoUrl?: string | null
    currentAcademicYear?: string | null
    currentTerm?: $Enums.TermPeriod | null
    currency?: string
    timezone?: string
    isActive?: boolean
    createdBySuperAdminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admins?: SchoolAdminUncheckedCreateNestedManyWithoutSchoolInput
    teachers?: TeacherUncheckedCreateNestedManyWithoutSchoolInput
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutSchoolInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutSchoolInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSchoolInput
    announcements?: SchoolAnnouncementUncheckedCreateNestedManyWithoutSchoolInput
    classAnnouncements?: ClassAnnouncementUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutTimetableSlotsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutTimetableSlotsInput, SchoolUncheckedCreateWithoutTimetableSlotsInput>
  }

  export type ClassCreateWithoutTimetableSlotsInput = {
    id?: string
    name: string
    section?: string | null
    academicYear: string
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutClassesInput
    homeroomTeacher?: TeacherCreateNestedOneWithoutClassTeacherOfInput
    studentsEnrolled?: StudentClassEnrollmentCreateNestedManyWithoutClassInput
    currentStudents?: StudentCreateNestedManyWithoutCurrentClassInput
    assignments?: AssignmentCreateNestedManyWithoutClassInput
    announcements?: ClassAnnouncementCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutTimetableSlotsInput = {
    id?: string
    schoolId: string
    name: string
    section?: string | null
    academicYear: string
    homeroomTeacherId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentsEnrolled?: StudentClassEnrollmentUncheckedCreateNestedManyWithoutClassInput
    currentStudents?: StudentUncheckedCreateNestedManyWithoutCurrentClassInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClassInput
    announcements?: ClassAnnouncementUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutTimetableSlotsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutTimetableSlotsInput, ClassUncheckedCreateWithoutTimetableSlotsInput>
  }

  export type SubjectCreateWithoutTimetableSlotsInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutSubjectsInput
    assignments?: AssignmentCreateNestedManyWithoutSubjectInput
    grades?: StudentGradeCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutTimetableSlotsInput = {
    id?: string
    schoolId: string
    name: string
    code?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutSubjectInput
    grades?: StudentGradeUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutTimetableSlotsInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutTimetableSlotsInput, SubjectUncheckedCreateWithoutTimetableSlotsInput>
  }

  export type TeacherCreateWithoutTimetableSlotsInput = {
    id?: string
    teacherIdNumber?: string | null
    dateOfJoining?: Date | string | null
    qualifications?: string | null
    specialization?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTeacherLinksInput
    school: SchoolCreateNestedOneWithoutTeachersInput
    classTeacherOf?: ClassCreateNestedManyWithoutHomeroomTeacherInput
    gradesGiven?: StudentGradeCreateNestedManyWithoutTeacherInput
    assignmentsCreated?: AssignmentCreateNestedManyWithoutTeacherInput
    createdClassAnnouncements?: ClassAnnouncementCreateNestedManyWithoutCreatedByTeacherInput
  }

  export type TeacherUncheckedCreateWithoutTimetableSlotsInput = {
    id?: string
    userId: string
    schoolId: string
    teacherIdNumber?: string | null
    dateOfJoining?: Date | string | null
    qualifications?: string | null
    specialization?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classTeacherOf?: ClassUncheckedCreateNestedManyWithoutHomeroomTeacherInput
    gradesGiven?: StudentGradeUncheckedCreateNestedManyWithoutTeacherInput
    assignmentsCreated?: AssignmentUncheckedCreateNestedManyWithoutTeacherInput
    createdClassAnnouncements?: ClassAnnouncementUncheckedCreateNestedManyWithoutCreatedByTeacherInput
  }

  export type TeacherCreateOrConnectWithoutTimetableSlotsInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutTimetableSlotsInput, TeacherUncheckedCreateWithoutTimetableSlotsInput>
  }

  export type StudentAttendanceCreateWithoutTimetableSlotInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    classId?: string | null
    subjectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutAttendancesInput
    recordedBy?: UserCreateNestedOneWithoutRecordedAttendancesInput
  }

  export type StudentAttendanceUncheckedCreateWithoutTimetableSlotInput = {
    id?: string
    studentId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    classId?: string | null
    subjectId?: string | null
    recordedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAttendanceCreateOrConnectWithoutTimetableSlotInput = {
    where: StudentAttendanceWhereUniqueInput
    create: XOR<StudentAttendanceCreateWithoutTimetableSlotInput, StudentAttendanceUncheckedCreateWithoutTimetableSlotInput>
  }

  export type StudentAttendanceCreateManyTimetableSlotInputEnvelope = {
    data: StudentAttendanceCreateManyTimetableSlotInput | StudentAttendanceCreateManyTimetableSlotInput[]
    skipDuplicates?: boolean
  }

  export type SchoolUpsertWithoutTimetableSlotsInput = {
    update: XOR<SchoolUpdateWithoutTimetableSlotsInput, SchoolUncheckedUpdateWithoutTimetableSlotsInput>
    create: XOR<SchoolCreateWithoutTimetableSlotsInput, SchoolUncheckedCreateWithoutTimetableSlotsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutTimetableSlotsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutTimetableSlotsInput, SchoolUncheckedUpdateWithoutTimetableSlotsInput>
  }

  export type SchoolUpdateWithoutTimetableSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    schoolEmail?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    currentAcademicYear?: NullableStringFieldUpdateOperationsInput | string | null
    currentTerm?: NullableEnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBySuperAdmin?: SuperAdminUpdateOneWithoutSchoolsCreatedNestedInput
    admins?: SchoolAdminUpdateManyWithoutSchoolNestedInput
    teachers?: TeacherUpdateManyWithoutSchoolNestedInput
    students?: StudentUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUpdateManyWithoutSchoolNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutSchoolNestedInput
    invoices?: InvoiceUpdateManyWithoutSchoolNestedInput
    announcements?: SchoolAnnouncementUpdateManyWithoutSchoolNestedInput
    classAnnouncements?: ClassAnnouncementUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutTimetableSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    schoolEmail?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    currentAcademicYear?: NullableStringFieldUpdateOperationsInput | string | null
    currentTerm?: NullableEnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBySuperAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admins?: SchoolAdminUncheckedUpdateManyWithoutSchoolNestedInput
    teachers?: TeacherUncheckedUpdateManyWithoutSchoolNestedInput
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutSchoolNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutSchoolNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSchoolNestedInput
    announcements?: SchoolAnnouncementUncheckedUpdateManyWithoutSchoolNestedInput
    classAnnouncements?: ClassAnnouncementUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type ClassUpsertWithoutTimetableSlotsInput = {
    update: XOR<ClassUpdateWithoutTimetableSlotsInput, ClassUncheckedUpdateWithoutTimetableSlotsInput>
    create: XOR<ClassCreateWithoutTimetableSlotsInput, ClassUncheckedCreateWithoutTimetableSlotsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutTimetableSlotsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutTimetableSlotsInput, ClassUncheckedUpdateWithoutTimetableSlotsInput>
  }

  export type ClassUpdateWithoutTimetableSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    homeroomTeacher?: TeacherUpdateOneWithoutClassTeacherOfNestedInput
    studentsEnrolled?: StudentClassEnrollmentUpdateManyWithoutClassNestedInput
    currentStudents?: StudentUpdateManyWithoutCurrentClassNestedInput
    assignments?: AssignmentUpdateManyWithoutClassNestedInput
    announcements?: ClassAnnouncementUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutTimetableSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    homeroomTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentsEnrolled?: StudentClassEnrollmentUncheckedUpdateManyWithoutClassNestedInput
    currentStudents?: StudentUncheckedUpdateManyWithoutCurrentClassNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutClassNestedInput
    announcements?: ClassAnnouncementUncheckedUpdateManyWithoutClassNestedInput
  }

  export type SubjectUpsertWithoutTimetableSlotsInput = {
    update: XOR<SubjectUpdateWithoutTimetableSlotsInput, SubjectUncheckedUpdateWithoutTimetableSlotsInput>
    create: XOR<SubjectCreateWithoutTimetableSlotsInput, SubjectUncheckedCreateWithoutTimetableSlotsInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutTimetableSlotsInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutTimetableSlotsInput, SubjectUncheckedUpdateWithoutTimetableSlotsInput>
  }

  export type SubjectUpdateWithoutTimetableSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutSubjectsNestedInput
    assignments?: AssignmentUpdateManyWithoutSubjectNestedInput
    grades?: StudentGradeUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutTimetableSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutSubjectNestedInput
    grades?: StudentGradeUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type TeacherUpsertWithoutTimetableSlotsInput = {
    update: XOR<TeacherUpdateWithoutTimetableSlotsInput, TeacherUncheckedUpdateWithoutTimetableSlotsInput>
    create: XOR<TeacherCreateWithoutTimetableSlotsInput, TeacherUncheckedCreateWithoutTimetableSlotsInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutTimetableSlotsInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutTimetableSlotsInput, TeacherUncheckedUpdateWithoutTimetableSlotsInput>
  }

  export type TeacherUpdateWithoutTimetableSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeacherLinksNestedInput
    school?: SchoolUpdateOneRequiredWithoutTeachersNestedInput
    classTeacherOf?: ClassUpdateManyWithoutHomeroomTeacherNestedInput
    gradesGiven?: StudentGradeUpdateManyWithoutTeacherNestedInput
    assignmentsCreated?: AssignmentUpdateManyWithoutTeacherNestedInput
    createdClassAnnouncements?: ClassAnnouncementUpdateManyWithoutCreatedByTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutTimetableSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    teacherIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classTeacherOf?: ClassUncheckedUpdateManyWithoutHomeroomTeacherNestedInput
    gradesGiven?: StudentGradeUncheckedUpdateManyWithoutTeacherNestedInput
    assignmentsCreated?: AssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    createdClassAnnouncements?: ClassAnnouncementUncheckedUpdateManyWithoutCreatedByTeacherNestedInput
  }

  export type StudentAttendanceUpsertWithWhereUniqueWithoutTimetableSlotInput = {
    where: StudentAttendanceWhereUniqueInput
    update: XOR<StudentAttendanceUpdateWithoutTimetableSlotInput, StudentAttendanceUncheckedUpdateWithoutTimetableSlotInput>
    create: XOR<StudentAttendanceCreateWithoutTimetableSlotInput, StudentAttendanceUncheckedCreateWithoutTimetableSlotInput>
  }

  export type StudentAttendanceUpdateWithWhereUniqueWithoutTimetableSlotInput = {
    where: StudentAttendanceWhereUniqueInput
    data: XOR<StudentAttendanceUpdateWithoutTimetableSlotInput, StudentAttendanceUncheckedUpdateWithoutTimetableSlotInput>
  }

  export type StudentAttendanceUpdateManyWithWhereWithoutTimetableSlotInput = {
    where: StudentAttendanceScalarWhereInput
    data: XOR<StudentAttendanceUpdateManyMutationInput, StudentAttendanceUncheckedUpdateManyWithoutTimetableSlotInput>
  }

  export type StudentCreateWithoutAttendancesInput = {
    id?: string
    studentIdNumber: string
    firstName: string
    lastName: string
    middleName?: string | null
    dateOfBirth: Date | string
    gender: $Enums.Gender
    enrollmentDate: Date | string
    profilePictureUrl?: string | null
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    bloodGroup?: string | null
    allergies?: string | null
    medicalNotes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentLinkInput
    school: SchoolCreateNestedOneWithoutStudentsInput
    currentClass?: ClassCreateNestedOneWithoutCurrentStudentsInput
    parents?: StudentParentLinkCreateNestedManyWithoutStudentInput
    enrollments?: StudentClassEnrollmentCreateNestedManyWithoutStudentInput
    grades?: StudentGradeCreateNestedManyWithoutStudentInput
    invoiceLineItems?: InvoiceLineItemCreateNestedManyWithoutStudentInput
    invoices?: InvoiceCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutAttendancesInput = {
    id?: string
    userId?: string | null
    schoolId: string
    studentIdNumber: string
    firstName: string
    lastName: string
    middleName?: string | null
    dateOfBirth: Date | string
    gender: $Enums.Gender
    enrollmentDate: Date | string
    profilePictureUrl?: string | null
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    bloodGroup?: string | null
    allergies?: string | null
    medicalNotes?: string | null
    isActive?: boolean
    currentClassId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: StudentParentLinkUncheckedCreateNestedManyWithoutStudentInput
    enrollments?: StudentClassEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    grades?: StudentGradeUncheckedCreateNestedManyWithoutStudentInput
    invoiceLineItems?: InvoiceLineItemUncheckedCreateNestedManyWithoutStudentInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutAttendancesInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAttendancesInput, StudentUncheckedCreateWithoutAttendancesInput>
  }

  export type TimetableSlotCreateWithoutAttendancesInput = {
    id?: string
    dayOfWeek: $Enums.DayOfWeek
    startTime: string
    endTime: string
    room?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutTimetableSlotsInput
    class: ClassCreateNestedOneWithoutTimetableSlotsInput
    subject: SubjectCreateNestedOneWithoutTimetableSlotsInput
    teacher: TeacherCreateNestedOneWithoutTimetableSlotsInput
  }

  export type TimetableSlotUncheckedCreateWithoutAttendancesInput = {
    id?: string
    schoolId: string
    classId: string
    subjectId: string
    teacherId: string
    dayOfWeek: $Enums.DayOfWeek
    startTime: string
    endTime: string
    room?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimetableSlotCreateOrConnectWithoutAttendancesInput = {
    where: TimetableSlotWhereUniqueInput
    create: XOR<TimetableSlotCreateWithoutAttendancesInput, TimetableSlotUncheckedCreateWithoutAttendancesInput>
  }

  export type UserCreateWithoutRecordedAttendancesInput = {
    id?: string
    email: string
    hashedPassword: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    profilePicture?: string | null
    isActive?: boolean
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    schoolAdmins?: SchoolAdminCreateNestedManyWithoutUserInput
    teacherLinks?: TeacherCreateNestedManyWithoutUserInput
    studentLink?: StudentCreateNestedOneWithoutUserInput
    parentLink?: ParentCreateNestedOneWithoutUserInput
    recordedPayments?: PaymentCreateNestedManyWithoutRecordedByInput
  }

  export type UserUncheckedCreateWithoutRecordedAttendancesInput = {
    id?: string
    email: string
    hashedPassword: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    profilePicture?: string | null
    isActive?: boolean
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    schoolAdmins?: SchoolAdminUncheckedCreateNestedManyWithoutUserInput
    teacherLinks?: TeacherUncheckedCreateNestedManyWithoutUserInput
    studentLink?: StudentUncheckedCreateNestedOneWithoutUserInput
    parentLink?: ParentUncheckedCreateNestedOneWithoutUserInput
    recordedPayments?: PaymentUncheckedCreateNestedManyWithoutRecordedByInput
  }

  export type UserCreateOrConnectWithoutRecordedAttendancesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecordedAttendancesInput, UserUncheckedCreateWithoutRecordedAttendancesInput>
  }

  export type StudentUpsertWithoutAttendancesInput = {
    update: XOR<StudentUpdateWithoutAttendancesInput, StudentUncheckedUpdateWithoutAttendancesInput>
    create: XOR<StudentCreateWithoutAttendancesInput, StudentUncheckedCreateWithoutAttendancesInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutAttendancesInput, StudentUncheckedUpdateWithoutAttendancesInput>
  }

  export type StudentUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentIdNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentLinkNestedInput
    school?: SchoolUpdateOneRequiredWithoutStudentsNestedInput
    currentClass?: ClassUpdateOneWithoutCurrentStudentsNestedInput
    parents?: StudentParentLinkUpdateManyWithoutStudentNestedInput
    enrollments?: StudentClassEnrollmentUpdateManyWithoutStudentNestedInput
    grades?: StudentGradeUpdateManyWithoutStudentNestedInput
    invoiceLineItems?: InvoiceLineItemUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    studentIdNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    currentClassId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: StudentParentLinkUncheckedUpdateManyWithoutStudentNestedInput
    enrollments?: StudentClassEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    grades?: StudentGradeUncheckedUpdateManyWithoutStudentNestedInput
    invoiceLineItems?: InvoiceLineItemUncheckedUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type TimetableSlotUpsertWithoutAttendancesInput = {
    update: XOR<TimetableSlotUpdateWithoutAttendancesInput, TimetableSlotUncheckedUpdateWithoutAttendancesInput>
    create: XOR<TimetableSlotCreateWithoutAttendancesInput, TimetableSlotUncheckedCreateWithoutAttendancesInput>
    where?: TimetableSlotWhereInput
  }

  export type TimetableSlotUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: TimetableSlotWhereInput
    data: XOR<TimetableSlotUpdateWithoutAttendancesInput, TimetableSlotUncheckedUpdateWithoutAttendancesInput>
  }

  export type TimetableSlotUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutTimetableSlotsNestedInput
    class?: ClassUpdateOneRequiredWithoutTimetableSlotsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutTimetableSlotsNestedInput
    teacher?: TeacherUpdateOneRequiredWithoutTimetableSlotsNestedInput
  }

  export type TimetableSlotUncheckedUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutRecordedAttendancesInput = {
    update: XOR<UserUpdateWithoutRecordedAttendancesInput, UserUncheckedUpdateWithoutRecordedAttendancesInput>
    create: XOR<UserCreateWithoutRecordedAttendancesInput, UserUncheckedCreateWithoutRecordedAttendancesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRecordedAttendancesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRecordedAttendancesInput, UserUncheckedUpdateWithoutRecordedAttendancesInput>
  }

  export type UserUpdateWithoutRecordedAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    schoolAdmins?: SchoolAdminUpdateManyWithoutUserNestedInput
    teacherLinks?: TeacherUpdateManyWithoutUserNestedInput
    studentLink?: StudentUpdateOneWithoutUserNestedInput
    parentLink?: ParentUpdateOneWithoutUserNestedInput
    recordedPayments?: PaymentUpdateManyWithoutRecordedByNestedInput
  }

  export type UserUncheckedUpdateWithoutRecordedAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    schoolAdmins?: SchoolAdminUncheckedUpdateManyWithoutUserNestedInput
    teacherLinks?: TeacherUncheckedUpdateManyWithoutUserNestedInput
    studentLink?: StudentUncheckedUpdateOneWithoutUserNestedInput
    parentLink?: ParentUncheckedUpdateOneWithoutUserNestedInput
    recordedPayments?: PaymentUncheckedUpdateManyWithoutRecordedByNestedInput
  }

  export type ClassCreateWithoutAssignmentsInput = {
    id?: string
    name: string
    section?: string | null
    academicYear: string
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutClassesInput
    homeroomTeacher?: TeacherCreateNestedOneWithoutClassTeacherOfInput
    studentsEnrolled?: StudentClassEnrollmentCreateNestedManyWithoutClassInput
    currentStudents?: StudentCreateNestedManyWithoutCurrentClassInput
    timetableSlots?: TimetableSlotCreateNestedManyWithoutClassInput
    announcements?: ClassAnnouncementCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    schoolId: string
    name: string
    section?: string | null
    academicYear: string
    homeroomTeacherId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentsEnrolled?: StudentClassEnrollmentUncheckedCreateNestedManyWithoutClassInput
    currentStudents?: StudentUncheckedCreateNestedManyWithoutCurrentClassInput
    timetableSlots?: TimetableSlotUncheckedCreateNestedManyWithoutClassInput
    announcements?: ClassAnnouncementUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutAssignmentsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutAssignmentsInput, ClassUncheckedCreateWithoutAssignmentsInput>
  }

  export type SubjectCreateWithoutAssignmentsInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutSubjectsInput
    timetableSlots?: TimetableSlotCreateNestedManyWithoutSubjectInput
    grades?: StudentGradeCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    schoolId: string
    name: string
    code?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timetableSlots?: TimetableSlotUncheckedCreateNestedManyWithoutSubjectInput
    grades?: StudentGradeUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutAssignmentsInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutAssignmentsInput, SubjectUncheckedCreateWithoutAssignmentsInput>
  }

  export type TeacherCreateWithoutAssignmentsCreatedInput = {
    id?: string
    teacherIdNumber?: string | null
    dateOfJoining?: Date | string | null
    qualifications?: string | null
    specialization?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTeacherLinksInput
    school: SchoolCreateNestedOneWithoutTeachersInput
    classTeacherOf?: ClassCreateNestedManyWithoutHomeroomTeacherInput
    timetableSlots?: TimetableSlotCreateNestedManyWithoutTeacherInput
    gradesGiven?: StudentGradeCreateNestedManyWithoutTeacherInput
    createdClassAnnouncements?: ClassAnnouncementCreateNestedManyWithoutCreatedByTeacherInput
  }

  export type TeacherUncheckedCreateWithoutAssignmentsCreatedInput = {
    id?: string
    userId: string
    schoolId: string
    teacherIdNumber?: string | null
    dateOfJoining?: Date | string | null
    qualifications?: string | null
    specialization?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classTeacherOf?: ClassUncheckedCreateNestedManyWithoutHomeroomTeacherInput
    timetableSlots?: TimetableSlotUncheckedCreateNestedManyWithoutTeacherInput
    gradesGiven?: StudentGradeUncheckedCreateNestedManyWithoutTeacherInput
    createdClassAnnouncements?: ClassAnnouncementUncheckedCreateNestedManyWithoutCreatedByTeacherInput
  }

  export type TeacherCreateOrConnectWithoutAssignmentsCreatedInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutAssignmentsCreatedInput, TeacherUncheckedCreateWithoutAssignmentsCreatedInput>
  }

  export type StudentGradeCreateWithoutAssignmentInput = {
    id?: string
    grade: string
    numericValue?: number | null
    comments?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    dateRecorded?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutGradesInput
    subject: SubjectCreateNestedOneWithoutGradesInput
    teacher?: TeacherCreateNestedOneWithoutGradesGivenInput
  }

  export type StudentGradeUncheckedCreateWithoutAssignmentInput = {
    id?: string
    studentId: string
    subjectId: string
    teacherId?: string | null
    grade: string
    numericValue?: number | null
    comments?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    dateRecorded?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentGradeCreateOrConnectWithoutAssignmentInput = {
    where: StudentGradeWhereUniqueInput
    create: XOR<StudentGradeCreateWithoutAssignmentInput, StudentGradeUncheckedCreateWithoutAssignmentInput>
  }

  export type StudentGradeCreateManyAssignmentInputEnvelope = {
    data: StudentGradeCreateManyAssignmentInput | StudentGradeCreateManyAssignmentInput[]
    skipDuplicates?: boolean
  }

  export type ClassUpsertWithoutAssignmentsInput = {
    update: XOR<ClassUpdateWithoutAssignmentsInput, ClassUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<ClassCreateWithoutAssignmentsInput, ClassUncheckedCreateWithoutAssignmentsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutAssignmentsInput, ClassUncheckedUpdateWithoutAssignmentsInput>
  }

  export type ClassUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    homeroomTeacher?: TeacherUpdateOneWithoutClassTeacherOfNestedInput
    studentsEnrolled?: StudentClassEnrollmentUpdateManyWithoutClassNestedInput
    currentStudents?: StudentUpdateManyWithoutCurrentClassNestedInput
    timetableSlots?: TimetableSlotUpdateManyWithoutClassNestedInput
    announcements?: ClassAnnouncementUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    homeroomTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentsEnrolled?: StudentClassEnrollmentUncheckedUpdateManyWithoutClassNestedInput
    currentStudents?: StudentUncheckedUpdateManyWithoutCurrentClassNestedInput
    timetableSlots?: TimetableSlotUncheckedUpdateManyWithoutClassNestedInput
    announcements?: ClassAnnouncementUncheckedUpdateManyWithoutClassNestedInput
  }

  export type SubjectUpsertWithoutAssignmentsInput = {
    update: XOR<SubjectUpdateWithoutAssignmentsInput, SubjectUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<SubjectCreateWithoutAssignmentsInput, SubjectUncheckedCreateWithoutAssignmentsInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutAssignmentsInput, SubjectUncheckedUpdateWithoutAssignmentsInput>
  }

  export type SubjectUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutSubjectsNestedInput
    timetableSlots?: TimetableSlotUpdateManyWithoutSubjectNestedInput
    grades?: StudentGradeUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timetableSlots?: TimetableSlotUncheckedUpdateManyWithoutSubjectNestedInput
    grades?: StudentGradeUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type TeacherUpsertWithoutAssignmentsCreatedInput = {
    update: XOR<TeacherUpdateWithoutAssignmentsCreatedInput, TeacherUncheckedUpdateWithoutAssignmentsCreatedInput>
    create: XOR<TeacherCreateWithoutAssignmentsCreatedInput, TeacherUncheckedCreateWithoutAssignmentsCreatedInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutAssignmentsCreatedInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutAssignmentsCreatedInput, TeacherUncheckedUpdateWithoutAssignmentsCreatedInput>
  }

  export type TeacherUpdateWithoutAssignmentsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeacherLinksNestedInput
    school?: SchoolUpdateOneRequiredWithoutTeachersNestedInput
    classTeacherOf?: ClassUpdateManyWithoutHomeroomTeacherNestedInput
    timetableSlots?: TimetableSlotUpdateManyWithoutTeacherNestedInput
    gradesGiven?: StudentGradeUpdateManyWithoutTeacherNestedInput
    createdClassAnnouncements?: ClassAnnouncementUpdateManyWithoutCreatedByTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutAssignmentsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    teacherIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classTeacherOf?: ClassUncheckedUpdateManyWithoutHomeroomTeacherNestedInput
    timetableSlots?: TimetableSlotUncheckedUpdateManyWithoutTeacherNestedInput
    gradesGiven?: StudentGradeUncheckedUpdateManyWithoutTeacherNestedInput
    createdClassAnnouncements?: ClassAnnouncementUncheckedUpdateManyWithoutCreatedByTeacherNestedInput
  }

  export type StudentGradeUpsertWithWhereUniqueWithoutAssignmentInput = {
    where: StudentGradeWhereUniqueInput
    update: XOR<StudentGradeUpdateWithoutAssignmentInput, StudentGradeUncheckedUpdateWithoutAssignmentInput>
    create: XOR<StudentGradeCreateWithoutAssignmentInput, StudentGradeUncheckedCreateWithoutAssignmentInput>
  }

  export type StudentGradeUpdateWithWhereUniqueWithoutAssignmentInput = {
    where: StudentGradeWhereUniqueInput
    data: XOR<StudentGradeUpdateWithoutAssignmentInput, StudentGradeUncheckedUpdateWithoutAssignmentInput>
  }

  export type StudentGradeUpdateManyWithWhereWithoutAssignmentInput = {
    where: StudentGradeScalarWhereInput
    data: XOR<StudentGradeUpdateManyMutationInput, StudentGradeUncheckedUpdateManyWithoutAssignmentInput>
  }

  export type StudentCreateWithoutGradesInput = {
    id?: string
    studentIdNumber: string
    firstName: string
    lastName: string
    middleName?: string | null
    dateOfBirth: Date | string
    gender: $Enums.Gender
    enrollmentDate: Date | string
    profilePictureUrl?: string | null
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    bloodGroup?: string | null
    allergies?: string | null
    medicalNotes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentLinkInput
    school: SchoolCreateNestedOneWithoutStudentsInput
    currentClass?: ClassCreateNestedOneWithoutCurrentStudentsInput
    parents?: StudentParentLinkCreateNestedManyWithoutStudentInput
    enrollments?: StudentClassEnrollmentCreateNestedManyWithoutStudentInput
    attendances?: StudentAttendanceCreateNestedManyWithoutStudentInput
    invoiceLineItems?: InvoiceLineItemCreateNestedManyWithoutStudentInput
    invoices?: InvoiceCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutGradesInput = {
    id?: string
    userId?: string | null
    schoolId: string
    studentIdNumber: string
    firstName: string
    lastName: string
    middleName?: string | null
    dateOfBirth: Date | string
    gender: $Enums.Gender
    enrollmentDate: Date | string
    profilePictureUrl?: string | null
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    bloodGroup?: string | null
    allergies?: string | null
    medicalNotes?: string | null
    isActive?: boolean
    currentClassId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: StudentParentLinkUncheckedCreateNestedManyWithoutStudentInput
    enrollments?: StudentClassEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    attendances?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    invoiceLineItems?: InvoiceLineItemUncheckedCreateNestedManyWithoutStudentInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutGradesInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutGradesInput, StudentUncheckedCreateWithoutGradesInput>
  }

  export type SubjectCreateWithoutGradesInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutSubjectsInput
    timetableSlots?: TimetableSlotCreateNestedManyWithoutSubjectInput
    assignments?: AssignmentCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutGradesInput = {
    id?: string
    schoolId: string
    name: string
    code?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timetableSlots?: TimetableSlotUncheckedCreateNestedManyWithoutSubjectInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutGradesInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutGradesInput, SubjectUncheckedCreateWithoutGradesInput>
  }

  export type AssignmentCreateWithoutGradesInput = {
    id?: string
    schoolId: string
    title: string
    description?: string | null
    maxPoints?: number | null
    dueDate?: Date | string | null
    academicYear: string
    term: $Enums.TermPeriod
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutAssignmentsInput
    subject: SubjectCreateNestedOneWithoutAssignmentsInput
    teacher: TeacherCreateNestedOneWithoutAssignmentsCreatedInput
  }

  export type AssignmentUncheckedCreateWithoutGradesInput = {
    id?: string
    schoolId: string
    classId: string
    subjectId: string
    teacherId: string
    title: string
    description?: string | null
    maxPoints?: number | null
    dueDate?: Date | string | null
    academicYear: string
    term: $Enums.TermPeriod
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentCreateOrConnectWithoutGradesInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutGradesInput, AssignmentUncheckedCreateWithoutGradesInput>
  }

  export type TeacherCreateWithoutGradesGivenInput = {
    id?: string
    teacherIdNumber?: string | null
    dateOfJoining?: Date | string | null
    qualifications?: string | null
    specialization?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTeacherLinksInput
    school: SchoolCreateNestedOneWithoutTeachersInput
    classTeacherOf?: ClassCreateNestedManyWithoutHomeroomTeacherInput
    timetableSlots?: TimetableSlotCreateNestedManyWithoutTeacherInput
    assignmentsCreated?: AssignmentCreateNestedManyWithoutTeacherInput
    createdClassAnnouncements?: ClassAnnouncementCreateNestedManyWithoutCreatedByTeacherInput
  }

  export type TeacherUncheckedCreateWithoutGradesGivenInput = {
    id?: string
    userId: string
    schoolId: string
    teacherIdNumber?: string | null
    dateOfJoining?: Date | string | null
    qualifications?: string | null
    specialization?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classTeacherOf?: ClassUncheckedCreateNestedManyWithoutHomeroomTeacherInput
    timetableSlots?: TimetableSlotUncheckedCreateNestedManyWithoutTeacherInput
    assignmentsCreated?: AssignmentUncheckedCreateNestedManyWithoutTeacherInput
    createdClassAnnouncements?: ClassAnnouncementUncheckedCreateNestedManyWithoutCreatedByTeacherInput
  }

  export type TeacherCreateOrConnectWithoutGradesGivenInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutGradesGivenInput, TeacherUncheckedCreateWithoutGradesGivenInput>
  }

  export type StudentUpsertWithoutGradesInput = {
    update: XOR<StudentUpdateWithoutGradesInput, StudentUncheckedUpdateWithoutGradesInput>
    create: XOR<StudentCreateWithoutGradesInput, StudentUncheckedCreateWithoutGradesInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutGradesInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutGradesInput, StudentUncheckedUpdateWithoutGradesInput>
  }

  export type StudentUpdateWithoutGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentIdNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentLinkNestedInput
    school?: SchoolUpdateOneRequiredWithoutStudentsNestedInput
    currentClass?: ClassUpdateOneWithoutCurrentStudentsNestedInput
    parents?: StudentParentLinkUpdateManyWithoutStudentNestedInput
    enrollments?: StudentClassEnrollmentUpdateManyWithoutStudentNestedInput
    attendances?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    invoiceLineItems?: InvoiceLineItemUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    studentIdNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    currentClassId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: StudentParentLinkUncheckedUpdateManyWithoutStudentNestedInput
    enrollments?: StudentClassEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    invoiceLineItems?: InvoiceLineItemUncheckedUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type SubjectUpsertWithoutGradesInput = {
    update: XOR<SubjectUpdateWithoutGradesInput, SubjectUncheckedUpdateWithoutGradesInput>
    create: XOR<SubjectCreateWithoutGradesInput, SubjectUncheckedCreateWithoutGradesInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutGradesInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutGradesInput, SubjectUncheckedUpdateWithoutGradesInput>
  }

  export type SubjectUpdateWithoutGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutSubjectsNestedInput
    timetableSlots?: TimetableSlotUpdateManyWithoutSubjectNestedInput
    assignments?: AssignmentUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timetableSlots?: TimetableSlotUncheckedUpdateManyWithoutSubjectNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type AssignmentUpsertWithoutGradesInput = {
    update: XOR<AssignmentUpdateWithoutGradesInput, AssignmentUncheckedUpdateWithoutGradesInput>
    create: XOR<AssignmentCreateWithoutGradesInput, AssignmentUncheckedCreateWithoutGradesInput>
    where?: AssignmentWhereInput
  }

  export type AssignmentUpdateToOneWithWhereWithoutGradesInput = {
    where?: AssignmentWhereInput
    data: XOR<AssignmentUpdateWithoutGradesInput, AssignmentUncheckedUpdateWithoutGradesInput>
  }

  export type AssignmentUpdateWithoutGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutAssignmentsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutAssignmentsNestedInput
    teacher?: TeacherUpdateOneRequiredWithoutAssignmentsCreatedNestedInput
  }

  export type AssignmentUncheckedUpdateWithoutGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherUpsertWithoutGradesGivenInput = {
    update: XOR<TeacherUpdateWithoutGradesGivenInput, TeacherUncheckedUpdateWithoutGradesGivenInput>
    create: XOR<TeacherCreateWithoutGradesGivenInput, TeacherUncheckedCreateWithoutGradesGivenInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutGradesGivenInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutGradesGivenInput, TeacherUncheckedUpdateWithoutGradesGivenInput>
  }

  export type TeacherUpdateWithoutGradesGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeacherLinksNestedInput
    school?: SchoolUpdateOneRequiredWithoutTeachersNestedInput
    classTeacherOf?: ClassUpdateManyWithoutHomeroomTeacherNestedInput
    timetableSlots?: TimetableSlotUpdateManyWithoutTeacherNestedInput
    assignmentsCreated?: AssignmentUpdateManyWithoutTeacherNestedInput
    createdClassAnnouncements?: ClassAnnouncementUpdateManyWithoutCreatedByTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutGradesGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    teacherIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classTeacherOf?: ClassUncheckedUpdateManyWithoutHomeroomTeacherNestedInput
    timetableSlots?: TimetableSlotUncheckedUpdateManyWithoutTeacherNestedInput
    assignmentsCreated?: AssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    createdClassAnnouncements?: ClassAnnouncementUncheckedUpdateManyWithoutCreatedByTeacherNestedInput
  }

  export type SchoolCreateWithoutFeeStructuresInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    schoolEmail: string
    website?: string | null
    logoUrl?: string | null
    currentAcademicYear?: string | null
    currentTerm?: $Enums.TermPeriod | null
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBySuperAdmin?: SuperAdminCreateNestedOneWithoutSchoolsCreatedInput
    admins?: SchoolAdminCreateNestedManyWithoutSchoolInput
    teachers?: TeacherCreateNestedManyWithoutSchoolInput
    students?: StudentCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    subjects?: SubjectCreateNestedManyWithoutSchoolInput
    invoices?: InvoiceCreateNestedManyWithoutSchoolInput
    timetableSlots?: TimetableSlotCreateNestedManyWithoutSchoolInput
    announcements?: SchoolAnnouncementCreateNestedManyWithoutSchoolInput
    classAnnouncements?: ClassAnnouncementCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutFeeStructuresInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    schoolEmail: string
    website?: string | null
    logoUrl?: string | null
    currentAcademicYear?: string | null
    currentTerm?: $Enums.TermPeriod | null
    currency?: string
    timezone?: string
    isActive?: boolean
    createdBySuperAdminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admins?: SchoolAdminUncheckedCreateNestedManyWithoutSchoolInput
    teachers?: TeacherUncheckedCreateNestedManyWithoutSchoolInput
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutSchoolInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSchoolInput
    timetableSlots?: TimetableSlotUncheckedCreateNestedManyWithoutSchoolInput
    announcements?: SchoolAnnouncementUncheckedCreateNestedManyWithoutSchoolInput
    classAnnouncements?: ClassAnnouncementUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutFeeStructuresInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutFeeStructuresInput, SchoolUncheckedCreateWithoutFeeStructuresInput>
  }

  export type InvoiceLineItemCreateWithoutFeeStructureInput = {
    id?: string
    description: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutLineItemsInput
    student: StudentCreateNestedOneWithoutInvoiceLineItemsInput
  }

  export type InvoiceLineItemUncheckedCreateWithoutFeeStructureInput = {
    id?: string
    invoiceId: string
    studentId: string
    description: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceLineItemCreateOrConnectWithoutFeeStructureInput = {
    where: InvoiceLineItemWhereUniqueInput
    create: XOR<InvoiceLineItemCreateWithoutFeeStructureInput, InvoiceLineItemUncheckedCreateWithoutFeeStructureInput>
  }

  export type InvoiceLineItemCreateManyFeeStructureInputEnvelope = {
    data: InvoiceLineItemCreateManyFeeStructureInput | InvoiceLineItemCreateManyFeeStructureInput[]
    skipDuplicates?: boolean
  }

  export type SchoolUpsertWithoutFeeStructuresInput = {
    update: XOR<SchoolUpdateWithoutFeeStructuresInput, SchoolUncheckedUpdateWithoutFeeStructuresInput>
    create: XOR<SchoolCreateWithoutFeeStructuresInput, SchoolUncheckedCreateWithoutFeeStructuresInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutFeeStructuresInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutFeeStructuresInput, SchoolUncheckedUpdateWithoutFeeStructuresInput>
  }

  export type SchoolUpdateWithoutFeeStructuresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    schoolEmail?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    currentAcademicYear?: NullableStringFieldUpdateOperationsInput | string | null
    currentTerm?: NullableEnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBySuperAdmin?: SuperAdminUpdateOneWithoutSchoolsCreatedNestedInput
    admins?: SchoolAdminUpdateManyWithoutSchoolNestedInput
    teachers?: TeacherUpdateManyWithoutSchoolNestedInput
    students?: StudentUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUpdateManyWithoutSchoolNestedInput
    invoices?: InvoiceUpdateManyWithoutSchoolNestedInput
    timetableSlots?: TimetableSlotUpdateManyWithoutSchoolNestedInput
    announcements?: SchoolAnnouncementUpdateManyWithoutSchoolNestedInput
    classAnnouncements?: ClassAnnouncementUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutFeeStructuresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    schoolEmail?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    currentAcademicYear?: NullableStringFieldUpdateOperationsInput | string | null
    currentTerm?: NullableEnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBySuperAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admins?: SchoolAdminUncheckedUpdateManyWithoutSchoolNestedInput
    teachers?: TeacherUncheckedUpdateManyWithoutSchoolNestedInput
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutSchoolNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSchoolNestedInput
    timetableSlots?: TimetableSlotUncheckedUpdateManyWithoutSchoolNestedInput
    announcements?: SchoolAnnouncementUncheckedUpdateManyWithoutSchoolNestedInput
    classAnnouncements?: ClassAnnouncementUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type InvoiceLineItemUpsertWithWhereUniqueWithoutFeeStructureInput = {
    where: InvoiceLineItemWhereUniqueInput
    update: XOR<InvoiceLineItemUpdateWithoutFeeStructureInput, InvoiceLineItemUncheckedUpdateWithoutFeeStructureInput>
    create: XOR<InvoiceLineItemCreateWithoutFeeStructureInput, InvoiceLineItemUncheckedCreateWithoutFeeStructureInput>
  }

  export type InvoiceLineItemUpdateWithWhereUniqueWithoutFeeStructureInput = {
    where: InvoiceLineItemWhereUniqueInput
    data: XOR<InvoiceLineItemUpdateWithoutFeeStructureInput, InvoiceLineItemUncheckedUpdateWithoutFeeStructureInput>
  }

  export type InvoiceLineItemUpdateManyWithWhereWithoutFeeStructureInput = {
    where: InvoiceLineItemScalarWhereInput
    data: XOR<InvoiceLineItemUpdateManyMutationInput, InvoiceLineItemUncheckedUpdateManyWithoutFeeStructureInput>
  }

  export type SchoolCreateWithoutInvoicesInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    schoolEmail: string
    website?: string | null
    logoUrl?: string | null
    currentAcademicYear?: string | null
    currentTerm?: $Enums.TermPeriod | null
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBySuperAdmin?: SuperAdminCreateNestedOneWithoutSchoolsCreatedInput
    admins?: SchoolAdminCreateNestedManyWithoutSchoolInput
    teachers?: TeacherCreateNestedManyWithoutSchoolInput
    students?: StudentCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    subjects?: SubjectCreateNestedManyWithoutSchoolInput
    feeStructures?: FeeStructureCreateNestedManyWithoutSchoolInput
    timetableSlots?: TimetableSlotCreateNestedManyWithoutSchoolInput
    announcements?: SchoolAnnouncementCreateNestedManyWithoutSchoolInput
    classAnnouncements?: ClassAnnouncementCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutInvoicesInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    schoolEmail: string
    website?: string | null
    logoUrl?: string | null
    currentAcademicYear?: string | null
    currentTerm?: $Enums.TermPeriod | null
    currency?: string
    timezone?: string
    isActive?: boolean
    createdBySuperAdminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admins?: SchoolAdminUncheckedCreateNestedManyWithoutSchoolInput
    teachers?: TeacherUncheckedCreateNestedManyWithoutSchoolInput
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutSchoolInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutSchoolInput
    timetableSlots?: TimetableSlotUncheckedCreateNestedManyWithoutSchoolInput
    announcements?: SchoolAnnouncementUncheckedCreateNestedManyWithoutSchoolInput
    classAnnouncements?: ClassAnnouncementUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutInvoicesInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutInvoicesInput, SchoolUncheckedCreateWithoutInvoicesInput>
  }

  export type StudentCreateWithoutInvoicesInput = {
    id?: string
    studentIdNumber: string
    firstName: string
    lastName: string
    middleName?: string | null
    dateOfBirth: Date | string
    gender: $Enums.Gender
    enrollmentDate: Date | string
    profilePictureUrl?: string | null
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    bloodGroup?: string | null
    allergies?: string | null
    medicalNotes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentLinkInput
    school: SchoolCreateNestedOneWithoutStudentsInput
    currentClass?: ClassCreateNestedOneWithoutCurrentStudentsInput
    parents?: StudentParentLinkCreateNestedManyWithoutStudentInput
    enrollments?: StudentClassEnrollmentCreateNestedManyWithoutStudentInput
    attendances?: StudentAttendanceCreateNestedManyWithoutStudentInput
    grades?: StudentGradeCreateNestedManyWithoutStudentInput
    invoiceLineItems?: InvoiceLineItemCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutInvoicesInput = {
    id?: string
    userId?: string | null
    schoolId: string
    studentIdNumber: string
    firstName: string
    lastName: string
    middleName?: string | null
    dateOfBirth: Date | string
    gender: $Enums.Gender
    enrollmentDate: Date | string
    profilePictureUrl?: string | null
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    bloodGroup?: string | null
    allergies?: string | null
    medicalNotes?: string | null
    isActive?: boolean
    currentClassId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: StudentParentLinkUncheckedCreateNestedManyWithoutStudentInput
    enrollments?: StudentClassEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    attendances?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    grades?: StudentGradeUncheckedCreateNestedManyWithoutStudentInput
    invoiceLineItems?: InvoiceLineItemUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutInvoicesInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutInvoicesInput, StudentUncheckedCreateWithoutInvoicesInput>
  }

  export type ParentCreateWithoutInvoicesInput = {
    id?: string
    occupation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutParentLinkInput
    children?: StudentParentLinkCreateNestedManyWithoutParentInput
  }

  export type ParentUncheckedCreateWithoutInvoicesInput = {
    id?: string
    userId: string
    occupation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: StudentParentLinkUncheckedCreateNestedManyWithoutParentInput
  }

  export type ParentCreateOrConnectWithoutInvoicesInput = {
    where: ParentWhereUniqueInput
    create: XOR<ParentCreateWithoutInvoicesInput, ParentUncheckedCreateWithoutInvoicesInput>
  }

  export type InvoiceLineItemCreateWithoutInvoiceInput = {
    id?: string
    description: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    feeStructure?: FeeStructureCreateNestedOneWithoutInvoiceLineItemsInput
    student: StudentCreateNestedOneWithoutInvoiceLineItemsInput
  }

  export type InvoiceLineItemUncheckedCreateWithoutInvoiceInput = {
    id?: string
    feeStructureId?: string | null
    studentId: string
    description: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceLineItemCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceLineItemWhereUniqueInput
    create: XOR<InvoiceLineItemCreateWithoutInvoiceInput, InvoiceLineItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceLineItemCreateManyInvoiceInputEnvelope = {
    data: InvoiceLineItemCreateManyInvoiceInput | InvoiceLineItemCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutInvoiceInput = {
    id?: string
    paymentDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedBy?: UserCreateNestedOneWithoutRecordedPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutInvoiceInput = {
    id?: string
    paymentDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    reference?: string | null
    notes?: string | null
    recordedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentCreateManyInvoiceInputEnvelope = {
    data: PaymentCreateManyInvoiceInput | PaymentCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type SchoolUpsertWithoutInvoicesInput = {
    update: XOR<SchoolUpdateWithoutInvoicesInput, SchoolUncheckedUpdateWithoutInvoicesInput>
    create: XOR<SchoolCreateWithoutInvoicesInput, SchoolUncheckedCreateWithoutInvoicesInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutInvoicesInput, SchoolUncheckedUpdateWithoutInvoicesInput>
  }

  export type SchoolUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    schoolEmail?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    currentAcademicYear?: NullableStringFieldUpdateOperationsInput | string | null
    currentTerm?: NullableEnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBySuperAdmin?: SuperAdminUpdateOneWithoutSchoolsCreatedNestedInput
    admins?: SchoolAdminUpdateManyWithoutSchoolNestedInput
    teachers?: TeacherUpdateManyWithoutSchoolNestedInput
    students?: StudentUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUpdateManyWithoutSchoolNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutSchoolNestedInput
    timetableSlots?: TimetableSlotUpdateManyWithoutSchoolNestedInput
    announcements?: SchoolAnnouncementUpdateManyWithoutSchoolNestedInput
    classAnnouncements?: ClassAnnouncementUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    schoolEmail?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    currentAcademicYear?: NullableStringFieldUpdateOperationsInput | string | null
    currentTerm?: NullableEnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBySuperAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admins?: SchoolAdminUncheckedUpdateManyWithoutSchoolNestedInput
    teachers?: TeacherUncheckedUpdateManyWithoutSchoolNestedInput
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutSchoolNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutSchoolNestedInput
    timetableSlots?: TimetableSlotUncheckedUpdateManyWithoutSchoolNestedInput
    announcements?: SchoolAnnouncementUncheckedUpdateManyWithoutSchoolNestedInput
    classAnnouncements?: ClassAnnouncementUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type StudentUpsertWithoutInvoicesInput = {
    update: XOR<StudentUpdateWithoutInvoicesInput, StudentUncheckedUpdateWithoutInvoicesInput>
    create: XOR<StudentCreateWithoutInvoicesInput, StudentUncheckedCreateWithoutInvoicesInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutInvoicesInput, StudentUncheckedUpdateWithoutInvoicesInput>
  }

  export type StudentUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentIdNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentLinkNestedInput
    school?: SchoolUpdateOneRequiredWithoutStudentsNestedInput
    currentClass?: ClassUpdateOneWithoutCurrentStudentsNestedInput
    parents?: StudentParentLinkUpdateManyWithoutStudentNestedInput
    enrollments?: StudentClassEnrollmentUpdateManyWithoutStudentNestedInput
    attendances?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    grades?: StudentGradeUpdateManyWithoutStudentNestedInput
    invoiceLineItems?: InvoiceLineItemUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    studentIdNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    currentClassId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: StudentParentLinkUncheckedUpdateManyWithoutStudentNestedInput
    enrollments?: StudentClassEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    grades?: StudentGradeUncheckedUpdateManyWithoutStudentNestedInput
    invoiceLineItems?: InvoiceLineItemUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ParentUpsertWithoutInvoicesInput = {
    update: XOR<ParentUpdateWithoutInvoicesInput, ParentUncheckedUpdateWithoutInvoicesInput>
    create: XOR<ParentCreateWithoutInvoicesInput, ParentUncheckedCreateWithoutInvoicesInput>
    where?: ParentWhereInput
  }

  export type ParentUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: ParentWhereInput
    data: XOR<ParentUpdateWithoutInvoicesInput, ParentUncheckedUpdateWithoutInvoicesInput>
  }

  export type ParentUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutParentLinkNestedInput
    children?: StudentParentLinkUpdateManyWithoutParentNestedInput
  }

  export type ParentUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: StudentParentLinkUncheckedUpdateManyWithoutParentNestedInput
  }

  export type InvoiceLineItemUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceLineItemWhereUniqueInput
    update: XOR<InvoiceLineItemUpdateWithoutInvoiceInput, InvoiceLineItemUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoiceLineItemCreateWithoutInvoiceInput, InvoiceLineItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceLineItemUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceLineItemWhereUniqueInput
    data: XOR<InvoiceLineItemUpdateWithoutInvoiceInput, InvoiceLineItemUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceLineItemUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceLineItemScalarWhereInput
    data: XOR<InvoiceLineItemUpdateManyMutationInput, InvoiceLineItemUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
  }

  export type PaymentUpdateManyWithWhereWithoutInvoiceInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoiceCreateWithoutLineItemsInput = {
    id?: string
    invoiceNumber: string
    issueDate: Date | string
    dueDate: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.PaymentStatus
    notes?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutInvoicesInput
    student: StudentCreateNestedOneWithoutInvoicesInput
    parentToBill?: ParentCreateNestedOneWithoutInvoicesInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutLineItemsInput = {
    id?: string
    schoolId: string
    studentId: string
    parentToBillId?: string | null
    invoiceNumber: string
    issueDate: Date | string
    dueDate: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.PaymentStatus
    notes?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutLineItemsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutLineItemsInput, InvoiceUncheckedCreateWithoutLineItemsInput>
  }

  export type FeeStructureCreateWithoutInvoiceLineItemsInput = {
    id?: string
    name: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    academicYear: string
    term?: $Enums.TermPeriod | null
    frequency: string
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutFeeStructuresInput
  }

  export type FeeStructureUncheckedCreateWithoutInvoiceLineItemsInput = {
    id?: string
    schoolId: string
    name: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    academicYear: string
    term?: $Enums.TermPeriod | null
    frequency: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeeStructureCreateOrConnectWithoutInvoiceLineItemsInput = {
    where: FeeStructureWhereUniqueInput
    create: XOR<FeeStructureCreateWithoutInvoiceLineItemsInput, FeeStructureUncheckedCreateWithoutInvoiceLineItemsInput>
  }

  export type StudentCreateWithoutInvoiceLineItemsInput = {
    id?: string
    studentIdNumber: string
    firstName: string
    lastName: string
    middleName?: string | null
    dateOfBirth: Date | string
    gender: $Enums.Gender
    enrollmentDate: Date | string
    profilePictureUrl?: string | null
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    bloodGroup?: string | null
    allergies?: string | null
    medicalNotes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentLinkInput
    school: SchoolCreateNestedOneWithoutStudentsInput
    currentClass?: ClassCreateNestedOneWithoutCurrentStudentsInput
    parents?: StudentParentLinkCreateNestedManyWithoutStudentInput
    enrollments?: StudentClassEnrollmentCreateNestedManyWithoutStudentInput
    attendances?: StudentAttendanceCreateNestedManyWithoutStudentInput
    grades?: StudentGradeCreateNestedManyWithoutStudentInput
    invoices?: InvoiceCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutInvoiceLineItemsInput = {
    id?: string
    userId?: string | null
    schoolId: string
    studentIdNumber: string
    firstName: string
    lastName: string
    middleName?: string | null
    dateOfBirth: Date | string
    gender: $Enums.Gender
    enrollmentDate: Date | string
    profilePictureUrl?: string | null
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    bloodGroup?: string | null
    allergies?: string | null
    medicalNotes?: string | null
    isActive?: boolean
    currentClassId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: StudentParentLinkUncheckedCreateNestedManyWithoutStudentInput
    enrollments?: StudentClassEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    attendances?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    grades?: StudentGradeUncheckedCreateNestedManyWithoutStudentInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutInvoiceLineItemsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutInvoiceLineItemsInput, StudentUncheckedCreateWithoutInvoiceLineItemsInput>
  }

  export type InvoiceUpsertWithoutLineItemsInput = {
    update: XOR<InvoiceUpdateWithoutLineItemsInput, InvoiceUncheckedUpdateWithoutLineItemsInput>
    create: XOR<InvoiceCreateWithoutLineItemsInput, InvoiceUncheckedCreateWithoutLineItemsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutLineItemsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutLineItemsInput, InvoiceUncheckedUpdateWithoutLineItemsInput>
  }

  export type InvoiceUpdateWithoutLineItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutInvoicesNestedInput
    student?: StudentUpdateOneRequiredWithoutInvoicesNestedInput
    parentToBill?: ParentUpdateOneWithoutInvoicesNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutLineItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    parentToBillId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type FeeStructureUpsertWithoutInvoiceLineItemsInput = {
    update: XOR<FeeStructureUpdateWithoutInvoiceLineItemsInput, FeeStructureUncheckedUpdateWithoutInvoiceLineItemsInput>
    create: XOR<FeeStructureCreateWithoutInvoiceLineItemsInput, FeeStructureUncheckedCreateWithoutInvoiceLineItemsInput>
    where?: FeeStructureWhereInput
  }

  export type FeeStructureUpdateToOneWithWhereWithoutInvoiceLineItemsInput = {
    where?: FeeStructureWhereInput
    data: XOR<FeeStructureUpdateWithoutInvoiceLineItemsInput, FeeStructureUncheckedUpdateWithoutInvoiceLineItemsInput>
  }

  export type FeeStructureUpdateWithoutInvoiceLineItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: NullableEnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod | null
    frequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutFeeStructuresNestedInput
  }

  export type FeeStructureUncheckedUpdateWithoutInvoiceLineItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: NullableEnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod | null
    frequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUpsertWithoutInvoiceLineItemsInput = {
    update: XOR<StudentUpdateWithoutInvoiceLineItemsInput, StudentUncheckedUpdateWithoutInvoiceLineItemsInput>
    create: XOR<StudentCreateWithoutInvoiceLineItemsInput, StudentUncheckedCreateWithoutInvoiceLineItemsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutInvoiceLineItemsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutInvoiceLineItemsInput, StudentUncheckedUpdateWithoutInvoiceLineItemsInput>
  }

  export type StudentUpdateWithoutInvoiceLineItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentIdNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentLinkNestedInput
    school?: SchoolUpdateOneRequiredWithoutStudentsNestedInput
    currentClass?: ClassUpdateOneWithoutCurrentStudentsNestedInput
    parents?: StudentParentLinkUpdateManyWithoutStudentNestedInput
    enrollments?: StudentClassEnrollmentUpdateManyWithoutStudentNestedInput
    attendances?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    grades?: StudentGradeUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutInvoiceLineItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    studentIdNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    currentClassId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: StudentParentLinkUncheckedUpdateManyWithoutStudentNestedInput
    enrollments?: StudentClassEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    grades?: StudentGradeUncheckedUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type InvoiceCreateWithoutPaymentsInput = {
    id?: string
    invoiceNumber: string
    issueDate: Date | string
    dueDate: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.PaymentStatus
    notes?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutInvoicesInput
    student: StudentCreateNestedOneWithoutInvoicesInput
    parentToBill?: ParentCreateNestedOneWithoutInvoicesInput
    lineItems?: InvoiceLineItemCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPaymentsInput = {
    id?: string
    schoolId: string
    studentId: string
    parentToBillId?: string | null
    invoiceNumber: string
    issueDate: Date | string
    dueDate: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.PaymentStatus
    notes?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    createdAt?: Date | string
    updatedAt?: Date | string
    lineItems?: InvoiceLineItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPaymentsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
  }

  export type UserCreateWithoutRecordedPaymentsInput = {
    id?: string
    email: string
    hashedPassword: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    profilePicture?: string | null
    isActive?: boolean
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    schoolAdmins?: SchoolAdminCreateNestedManyWithoutUserInput
    teacherLinks?: TeacherCreateNestedManyWithoutUserInput
    studentLink?: StudentCreateNestedOneWithoutUserInput
    parentLink?: ParentCreateNestedOneWithoutUserInput
    recordedAttendances?: StudentAttendanceCreateNestedManyWithoutRecordedByInput
  }

  export type UserUncheckedCreateWithoutRecordedPaymentsInput = {
    id?: string
    email: string
    hashedPassword: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    profilePicture?: string | null
    isActive?: boolean
    role: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    schoolAdmins?: SchoolAdminUncheckedCreateNestedManyWithoutUserInput
    teacherLinks?: TeacherUncheckedCreateNestedManyWithoutUserInput
    studentLink?: StudentUncheckedCreateNestedOneWithoutUserInput
    parentLink?: ParentUncheckedCreateNestedOneWithoutUserInput
    recordedAttendances?: StudentAttendanceUncheckedCreateNestedManyWithoutRecordedByInput
  }

  export type UserCreateOrConnectWithoutRecordedPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecordedPaymentsInput, UserUncheckedCreateWithoutRecordedPaymentsInput>
  }

  export type InvoiceUpsertWithoutPaymentsInput = {
    update: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutInvoicesNestedInput
    student?: StudentUpdateOneRequiredWithoutInvoicesNestedInput
    parentToBill?: ParentUpdateOneWithoutInvoicesNestedInput
    lineItems?: InvoiceLineItemUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    parentToBillId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lineItems?: InvoiceLineItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type UserUpsertWithoutRecordedPaymentsInput = {
    update: XOR<UserUpdateWithoutRecordedPaymentsInput, UserUncheckedUpdateWithoutRecordedPaymentsInput>
    create: XOR<UserCreateWithoutRecordedPaymentsInput, UserUncheckedCreateWithoutRecordedPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRecordedPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRecordedPaymentsInput, UserUncheckedUpdateWithoutRecordedPaymentsInput>
  }

  export type UserUpdateWithoutRecordedPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    schoolAdmins?: SchoolAdminUpdateManyWithoutUserNestedInput
    teacherLinks?: TeacherUpdateManyWithoutUserNestedInput
    studentLink?: StudentUpdateOneWithoutUserNestedInput
    parentLink?: ParentUpdateOneWithoutUserNestedInput
    recordedAttendances?: StudentAttendanceUpdateManyWithoutRecordedByNestedInput
  }

  export type UserUncheckedUpdateWithoutRecordedPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    schoolAdmins?: SchoolAdminUncheckedUpdateManyWithoutUserNestedInput
    teacherLinks?: TeacherUncheckedUpdateManyWithoutUserNestedInput
    studentLink?: StudentUncheckedUpdateOneWithoutUserNestedInput
    parentLink?: ParentUncheckedUpdateOneWithoutUserNestedInput
    recordedAttendances?: StudentAttendanceUncheckedUpdateManyWithoutRecordedByNestedInput
  }

  export type SchoolCreateWithoutAnnouncementsInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    schoolEmail: string
    website?: string | null
    logoUrl?: string | null
    currentAcademicYear?: string | null
    currentTerm?: $Enums.TermPeriod | null
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBySuperAdmin?: SuperAdminCreateNestedOneWithoutSchoolsCreatedInput
    admins?: SchoolAdminCreateNestedManyWithoutSchoolInput
    teachers?: TeacherCreateNestedManyWithoutSchoolInput
    students?: StudentCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    subjects?: SubjectCreateNestedManyWithoutSchoolInput
    feeStructures?: FeeStructureCreateNestedManyWithoutSchoolInput
    invoices?: InvoiceCreateNestedManyWithoutSchoolInput
    timetableSlots?: TimetableSlotCreateNestedManyWithoutSchoolInput
    classAnnouncements?: ClassAnnouncementCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutAnnouncementsInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    schoolEmail: string
    website?: string | null
    logoUrl?: string | null
    currentAcademicYear?: string | null
    currentTerm?: $Enums.TermPeriod | null
    currency?: string
    timezone?: string
    isActive?: boolean
    createdBySuperAdminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admins?: SchoolAdminUncheckedCreateNestedManyWithoutSchoolInput
    teachers?: TeacherUncheckedCreateNestedManyWithoutSchoolInput
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutSchoolInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutSchoolInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSchoolInput
    timetableSlots?: TimetableSlotUncheckedCreateNestedManyWithoutSchoolInput
    classAnnouncements?: ClassAnnouncementUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutAnnouncementsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutAnnouncementsInput, SchoolUncheckedCreateWithoutAnnouncementsInput>
  }

  export type SchoolAdminCreateWithoutCreatedSchoolAnnouncementsInput = {
    id?: string
    jobTitle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSchoolAdminsInput
    school: SchoolCreateNestedOneWithoutAdminsInput
  }

  export type SchoolAdminUncheckedCreateWithoutCreatedSchoolAnnouncementsInput = {
    id?: string
    userId: string
    schoolId: string
    jobTitle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolAdminCreateOrConnectWithoutCreatedSchoolAnnouncementsInput = {
    where: SchoolAdminWhereUniqueInput
    create: XOR<SchoolAdminCreateWithoutCreatedSchoolAnnouncementsInput, SchoolAdminUncheckedCreateWithoutCreatedSchoolAnnouncementsInput>
  }

  export type SchoolUpsertWithoutAnnouncementsInput = {
    update: XOR<SchoolUpdateWithoutAnnouncementsInput, SchoolUncheckedUpdateWithoutAnnouncementsInput>
    create: XOR<SchoolCreateWithoutAnnouncementsInput, SchoolUncheckedCreateWithoutAnnouncementsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutAnnouncementsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutAnnouncementsInput, SchoolUncheckedUpdateWithoutAnnouncementsInput>
  }

  export type SchoolUpdateWithoutAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    schoolEmail?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    currentAcademicYear?: NullableStringFieldUpdateOperationsInput | string | null
    currentTerm?: NullableEnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBySuperAdmin?: SuperAdminUpdateOneWithoutSchoolsCreatedNestedInput
    admins?: SchoolAdminUpdateManyWithoutSchoolNestedInput
    teachers?: TeacherUpdateManyWithoutSchoolNestedInput
    students?: StudentUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUpdateManyWithoutSchoolNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutSchoolNestedInput
    invoices?: InvoiceUpdateManyWithoutSchoolNestedInput
    timetableSlots?: TimetableSlotUpdateManyWithoutSchoolNestedInput
    classAnnouncements?: ClassAnnouncementUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    schoolEmail?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    currentAcademicYear?: NullableStringFieldUpdateOperationsInput | string | null
    currentTerm?: NullableEnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBySuperAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admins?: SchoolAdminUncheckedUpdateManyWithoutSchoolNestedInput
    teachers?: TeacherUncheckedUpdateManyWithoutSchoolNestedInput
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutSchoolNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutSchoolNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSchoolNestedInput
    timetableSlots?: TimetableSlotUncheckedUpdateManyWithoutSchoolNestedInput
    classAnnouncements?: ClassAnnouncementUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolAdminUpsertWithoutCreatedSchoolAnnouncementsInput = {
    update: XOR<SchoolAdminUpdateWithoutCreatedSchoolAnnouncementsInput, SchoolAdminUncheckedUpdateWithoutCreatedSchoolAnnouncementsInput>
    create: XOR<SchoolAdminCreateWithoutCreatedSchoolAnnouncementsInput, SchoolAdminUncheckedCreateWithoutCreatedSchoolAnnouncementsInput>
    where?: SchoolAdminWhereInput
  }

  export type SchoolAdminUpdateToOneWithWhereWithoutCreatedSchoolAnnouncementsInput = {
    where?: SchoolAdminWhereInput
    data: XOR<SchoolAdminUpdateWithoutCreatedSchoolAnnouncementsInput, SchoolAdminUncheckedUpdateWithoutCreatedSchoolAnnouncementsInput>
  }

  export type SchoolAdminUpdateWithoutCreatedSchoolAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSchoolAdminsNestedInput
    school?: SchoolUpdateOneRequiredWithoutAdminsNestedInput
  }

  export type SchoolAdminUncheckedUpdateWithoutCreatedSchoolAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolCreateWithoutClassAnnouncementsInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    schoolEmail: string
    website?: string | null
    logoUrl?: string | null
    currentAcademicYear?: string | null
    currentTerm?: $Enums.TermPeriod | null
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBySuperAdmin?: SuperAdminCreateNestedOneWithoutSchoolsCreatedInput
    admins?: SchoolAdminCreateNestedManyWithoutSchoolInput
    teachers?: TeacherCreateNestedManyWithoutSchoolInput
    students?: StudentCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    subjects?: SubjectCreateNestedManyWithoutSchoolInput
    feeStructures?: FeeStructureCreateNestedManyWithoutSchoolInput
    invoices?: InvoiceCreateNestedManyWithoutSchoolInput
    timetableSlots?: TimetableSlotCreateNestedManyWithoutSchoolInput
    announcements?: SchoolAnnouncementCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutClassAnnouncementsInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    schoolEmail: string
    website?: string | null
    logoUrl?: string | null
    currentAcademicYear?: string | null
    currentTerm?: $Enums.TermPeriod | null
    currency?: string
    timezone?: string
    isActive?: boolean
    createdBySuperAdminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admins?: SchoolAdminUncheckedCreateNestedManyWithoutSchoolInput
    teachers?: TeacherUncheckedCreateNestedManyWithoutSchoolInput
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutSchoolInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutSchoolInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSchoolInput
    timetableSlots?: TimetableSlotUncheckedCreateNestedManyWithoutSchoolInput
    announcements?: SchoolAnnouncementUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutClassAnnouncementsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutClassAnnouncementsInput, SchoolUncheckedCreateWithoutClassAnnouncementsInput>
  }

  export type ClassCreateWithoutAnnouncementsInput = {
    id?: string
    name: string
    section?: string | null
    academicYear: string
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutClassesInput
    homeroomTeacher?: TeacherCreateNestedOneWithoutClassTeacherOfInput
    studentsEnrolled?: StudentClassEnrollmentCreateNestedManyWithoutClassInput
    currentStudents?: StudentCreateNestedManyWithoutCurrentClassInput
    timetableSlots?: TimetableSlotCreateNestedManyWithoutClassInput
    assignments?: AssignmentCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutAnnouncementsInput = {
    id?: string
    schoolId: string
    name: string
    section?: string | null
    academicYear: string
    homeroomTeacherId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentsEnrolled?: StudentClassEnrollmentUncheckedCreateNestedManyWithoutClassInput
    currentStudents?: StudentUncheckedCreateNestedManyWithoutCurrentClassInput
    timetableSlots?: TimetableSlotUncheckedCreateNestedManyWithoutClassInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutAnnouncementsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutAnnouncementsInput, ClassUncheckedCreateWithoutAnnouncementsInput>
  }

  export type TeacherCreateWithoutCreatedClassAnnouncementsInput = {
    id?: string
    teacherIdNumber?: string | null
    dateOfJoining?: Date | string | null
    qualifications?: string | null
    specialization?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTeacherLinksInput
    school: SchoolCreateNestedOneWithoutTeachersInput
    classTeacherOf?: ClassCreateNestedManyWithoutHomeroomTeacherInput
    timetableSlots?: TimetableSlotCreateNestedManyWithoutTeacherInput
    gradesGiven?: StudentGradeCreateNestedManyWithoutTeacherInput
    assignmentsCreated?: AssignmentCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutCreatedClassAnnouncementsInput = {
    id?: string
    userId: string
    schoolId: string
    teacherIdNumber?: string | null
    dateOfJoining?: Date | string | null
    qualifications?: string | null
    specialization?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classTeacherOf?: ClassUncheckedCreateNestedManyWithoutHomeroomTeacherInput
    timetableSlots?: TimetableSlotUncheckedCreateNestedManyWithoutTeacherInput
    gradesGiven?: StudentGradeUncheckedCreateNestedManyWithoutTeacherInput
    assignmentsCreated?: AssignmentUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutCreatedClassAnnouncementsInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutCreatedClassAnnouncementsInput, TeacherUncheckedCreateWithoutCreatedClassAnnouncementsInput>
  }

  export type SchoolUpsertWithoutClassAnnouncementsInput = {
    update: XOR<SchoolUpdateWithoutClassAnnouncementsInput, SchoolUncheckedUpdateWithoutClassAnnouncementsInput>
    create: XOR<SchoolCreateWithoutClassAnnouncementsInput, SchoolUncheckedCreateWithoutClassAnnouncementsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutClassAnnouncementsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutClassAnnouncementsInput, SchoolUncheckedUpdateWithoutClassAnnouncementsInput>
  }

  export type SchoolUpdateWithoutClassAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    schoolEmail?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    currentAcademicYear?: NullableStringFieldUpdateOperationsInput | string | null
    currentTerm?: NullableEnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBySuperAdmin?: SuperAdminUpdateOneWithoutSchoolsCreatedNestedInput
    admins?: SchoolAdminUpdateManyWithoutSchoolNestedInput
    teachers?: TeacherUpdateManyWithoutSchoolNestedInput
    students?: StudentUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUpdateManyWithoutSchoolNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutSchoolNestedInput
    invoices?: InvoiceUpdateManyWithoutSchoolNestedInput
    timetableSlots?: TimetableSlotUpdateManyWithoutSchoolNestedInput
    announcements?: SchoolAnnouncementUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutClassAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    schoolEmail?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    currentAcademicYear?: NullableStringFieldUpdateOperationsInput | string | null
    currentTerm?: NullableEnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBySuperAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admins?: SchoolAdminUncheckedUpdateManyWithoutSchoolNestedInput
    teachers?: TeacherUncheckedUpdateManyWithoutSchoolNestedInput
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutSchoolNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutSchoolNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSchoolNestedInput
    timetableSlots?: TimetableSlotUncheckedUpdateManyWithoutSchoolNestedInput
    announcements?: SchoolAnnouncementUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type ClassUpsertWithoutAnnouncementsInput = {
    update: XOR<ClassUpdateWithoutAnnouncementsInput, ClassUncheckedUpdateWithoutAnnouncementsInput>
    create: XOR<ClassCreateWithoutAnnouncementsInput, ClassUncheckedCreateWithoutAnnouncementsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutAnnouncementsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutAnnouncementsInput, ClassUncheckedUpdateWithoutAnnouncementsInput>
  }

  export type ClassUpdateWithoutAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    homeroomTeacher?: TeacherUpdateOneWithoutClassTeacherOfNestedInput
    studentsEnrolled?: StudentClassEnrollmentUpdateManyWithoutClassNestedInput
    currentStudents?: StudentUpdateManyWithoutCurrentClassNestedInput
    timetableSlots?: TimetableSlotUpdateManyWithoutClassNestedInput
    assignments?: AssignmentUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    homeroomTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentsEnrolled?: StudentClassEnrollmentUncheckedUpdateManyWithoutClassNestedInput
    currentStudents?: StudentUncheckedUpdateManyWithoutCurrentClassNestedInput
    timetableSlots?: TimetableSlotUncheckedUpdateManyWithoutClassNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutClassNestedInput
  }

  export type TeacherUpsertWithoutCreatedClassAnnouncementsInput = {
    update: XOR<TeacherUpdateWithoutCreatedClassAnnouncementsInput, TeacherUncheckedUpdateWithoutCreatedClassAnnouncementsInput>
    create: XOR<TeacherCreateWithoutCreatedClassAnnouncementsInput, TeacherUncheckedCreateWithoutCreatedClassAnnouncementsInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutCreatedClassAnnouncementsInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutCreatedClassAnnouncementsInput, TeacherUncheckedUpdateWithoutCreatedClassAnnouncementsInput>
  }

  export type TeacherUpdateWithoutCreatedClassAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeacherLinksNestedInput
    school?: SchoolUpdateOneRequiredWithoutTeachersNestedInput
    classTeacherOf?: ClassUpdateManyWithoutHomeroomTeacherNestedInput
    timetableSlots?: TimetableSlotUpdateManyWithoutTeacherNestedInput
    gradesGiven?: StudentGradeUpdateManyWithoutTeacherNestedInput
    assignmentsCreated?: AssignmentUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutCreatedClassAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    teacherIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classTeacherOf?: ClassUncheckedUpdateManyWithoutHomeroomTeacherNestedInput
    timetableSlots?: TimetableSlotUncheckedUpdateManyWithoutTeacherNestedInput
    gradesGiven?: StudentGradeUncheckedUpdateManyWithoutTeacherNestedInput
    assignmentsCreated?: AssignmentUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolAdminCreateManyUserInput = {
    id?: string
    schoolId: string
    jobTitle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherCreateManyUserInput = {
    id?: string
    schoolId: string
    teacherIdNumber?: string | null
    dateOfJoining?: Date | string | null
    qualifications?: string | null
    specialization?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAttendanceCreateManyRecordedByInput = {
    id?: string
    studentId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    classId?: string | null
    subjectId?: string | null
    timetableSlotId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyRecordedByInput = {
    id?: string
    invoiceId: string
    paymentDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolAdminUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutAdminsNestedInput
    createdSchoolAnnouncements?: SchoolAnnouncementUpdateManyWithoutCreatedByAdminNestedInput
  }

  export type SchoolAdminUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdSchoolAnnouncements?: SchoolAnnouncementUncheckedUpdateManyWithoutCreatedByAdminNestedInput
  }

  export type SchoolAdminUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutTeachersNestedInput
    classTeacherOf?: ClassUpdateManyWithoutHomeroomTeacherNestedInput
    timetableSlots?: TimetableSlotUpdateManyWithoutTeacherNestedInput
    gradesGiven?: StudentGradeUpdateManyWithoutTeacherNestedInput
    assignmentsCreated?: AssignmentUpdateManyWithoutTeacherNestedInput
    createdClassAnnouncements?: ClassAnnouncementUpdateManyWithoutCreatedByTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    teacherIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classTeacherOf?: ClassUncheckedUpdateManyWithoutHomeroomTeacherNestedInput
    timetableSlots?: TimetableSlotUncheckedUpdateManyWithoutTeacherNestedInput
    gradesGiven?: StudentGradeUncheckedUpdateManyWithoutTeacherNestedInput
    assignmentsCreated?: AssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    createdClassAnnouncements?: ClassAnnouncementUncheckedUpdateManyWithoutCreatedByTeacherNestedInput
  }

  export type TeacherUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    teacherIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAttendanceUpdateWithoutRecordedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutAttendancesNestedInput
    timetableSlot?: TimetableSlotUpdateOneWithoutAttendancesNestedInput
  }

  export type StudentAttendanceUncheckedUpdateWithoutRecordedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    timetableSlotId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAttendanceUncheckedUpdateManyWithoutRecordedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    timetableSlotId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutRecordedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutRecordedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutRecordedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolCreateManyCreatedBySuperAdminInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    schoolEmail: string
    website?: string | null
    logoUrl?: string | null
    currentAcademicYear?: string | null
    currentTerm?: $Enums.TermPeriod | null
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolUpdateWithoutCreatedBySuperAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    schoolEmail?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    currentAcademicYear?: NullableStringFieldUpdateOperationsInput | string | null
    currentTerm?: NullableEnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admins?: SchoolAdminUpdateManyWithoutSchoolNestedInput
    teachers?: TeacherUpdateManyWithoutSchoolNestedInput
    students?: StudentUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUpdateManyWithoutSchoolNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutSchoolNestedInput
    invoices?: InvoiceUpdateManyWithoutSchoolNestedInput
    timetableSlots?: TimetableSlotUpdateManyWithoutSchoolNestedInput
    announcements?: SchoolAnnouncementUpdateManyWithoutSchoolNestedInput
    classAnnouncements?: ClassAnnouncementUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutCreatedBySuperAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    schoolEmail?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    currentAcademicYear?: NullableStringFieldUpdateOperationsInput | string | null
    currentTerm?: NullableEnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admins?: SchoolAdminUncheckedUpdateManyWithoutSchoolNestedInput
    teachers?: TeacherUncheckedUpdateManyWithoutSchoolNestedInput
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutSchoolNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutSchoolNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSchoolNestedInput
    timetableSlots?: TimetableSlotUncheckedUpdateManyWithoutSchoolNestedInput
    announcements?: SchoolAnnouncementUncheckedUpdateManyWithoutSchoolNestedInput
    classAnnouncements?: ClassAnnouncementUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateManyWithoutCreatedBySuperAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    schoolEmail?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    currentAcademicYear?: NullableStringFieldUpdateOperationsInput | string | null
    currentTerm?: NullableEnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolAdminCreateManySchoolInput = {
    id?: string
    userId: string
    jobTitle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherCreateManySchoolInput = {
    id?: string
    userId: string
    teacherIdNumber?: string | null
    dateOfJoining?: Date | string | null
    qualifications?: string | null
    specialization?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentCreateManySchoolInput = {
    id?: string
    userId?: string | null
    studentIdNumber: string
    firstName: string
    lastName: string
    middleName?: string | null
    dateOfBirth: Date | string
    gender: $Enums.Gender
    enrollmentDate: Date | string
    profilePictureUrl?: string | null
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    bloodGroup?: string | null
    allergies?: string | null
    medicalNotes?: string | null
    isActive?: boolean
    currentClassId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassCreateManySchoolInput = {
    id?: string
    name: string
    section?: string | null
    academicYear: string
    homeroomTeacherId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectCreateManySchoolInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeeStructureCreateManySchoolInput = {
    id?: string
    name: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    academicYear: string
    term?: $Enums.TermPeriod | null
    frequency: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManySchoolInput = {
    id?: string
    studentId: string
    parentToBillId?: string | null
    invoiceNumber: string
    issueDate: Date | string
    dueDate: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.PaymentStatus
    notes?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimetableSlotCreateManySchoolInput = {
    id?: string
    classId: string
    subjectId: string
    teacherId: string
    dayOfWeek: $Enums.DayOfWeek
    startTime: string
    endTime: string
    room?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolAnnouncementCreateManySchoolInput = {
    id?: string
    title: string
    content: string
    publishDate: Date | string
    expiryDate?: Date | string | null
    audience?: string | null
    isPublished?: boolean
    createdByAdminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassAnnouncementCreateManySchoolInput = {
    id?: string
    classId: string
    title: string
    content: string
    publishDate: Date | string
    isPublished?: boolean
    createdByTeacherId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolAdminUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSchoolAdminsNestedInput
    createdSchoolAnnouncements?: SchoolAnnouncementUpdateManyWithoutCreatedByAdminNestedInput
  }

  export type SchoolAdminUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdSchoolAnnouncements?: SchoolAnnouncementUncheckedUpdateManyWithoutCreatedByAdminNestedInput
  }

  export type SchoolAdminUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeacherLinksNestedInput
    classTeacherOf?: ClassUpdateManyWithoutHomeroomTeacherNestedInput
    timetableSlots?: TimetableSlotUpdateManyWithoutTeacherNestedInput
    gradesGiven?: StudentGradeUpdateManyWithoutTeacherNestedInput
    assignmentsCreated?: AssignmentUpdateManyWithoutTeacherNestedInput
    createdClassAnnouncements?: ClassAnnouncementUpdateManyWithoutCreatedByTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    teacherIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classTeacherOf?: ClassUncheckedUpdateManyWithoutHomeroomTeacherNestedInput
    timetableSlots?: TimetableSlotUncheckedUpdateManyWithoutTeacherNestedInput
    gradesGiven?: StudentGradeUncheckedUpdateManyWithoutTeacherNestedInput
    assignmentsCreated?: AssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    createdClassAnnouncements?: ClassAnnouncementUncheckedUpdateManyWithoutCreatedByTeacherNestedInput
  }

  export type TeacherUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    teacherIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentIdNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentLinkNestedInput
    currentClass?: ClassUpdateOneWithoutCurrentStudentsNestedInput
    parents?: StudentParentLinkUpdateManyWithoutStudentNestedInput
    enrollments?: StudentClassEnrollmentUpdateManyWithoutStudentNestedInput
    attendances?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    grades?: StudentGradeUpdateManyWithoutStudentNestedInput
    invoiceLineItems?: InvoiceLineItemUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    studentIdNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    currentClassId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: StudentParentLinkUncheckedUpdateManyWithoutStudentNestedInput
    enrollments?: StudentClassEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    grades?: StudentGradeUncheckedUpdateManyWithoutStudentNestedInput
    invoiceLineItems?: InvoiceLineItemUncheckedUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    studentIdNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    currentClassId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    homeroomTeacher?: TeacherUpdateOneWithoutClassTeacherOfNestedInput
    studentsEnrolled?: StudentClassEnrollmentUpdateManyWithoutClassNestedInput
    currentStudents?: StudentUpdateManyWithoutCurrentClassNestedInput
    timetableSlots?: TimetableSlotUpdateManyWithoutClassNestedInput
    assignments?: AssignmentUpdateManyWithoutClassNestedInput
    announcements?: ClassAnnouncementUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    homeroomTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentsEnrolled?: StudentClassEnrollmentUncheckedUpdateManyWithoutClassNestedInput
    currentStudents?: StudentUncheckedUpdateManyWithoutCurrentClassNestedInput
    timetableSlots?: TimetableSlotUncheckedUpdateManyWithoutClassNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutClassNestedInput
    announcements?: ClassAnnouncementUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    homeroomTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timetableSlots?: TimetableSlotUpdateManyWithoutSubjectNestedInput
    assignments?: AssignmentUpdateManyWithoutSubjectNestedInput
    grades?: StudentGradeUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timetableSlots?: TimetableSlotUncheckedUpdateManyWithoutSubjectNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutSubjectNestedInput
    grades?: StudentGradeUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeStructureUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: NullableEnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod | null
    frequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceLineItems?: InvoiceLineItemUpdateManyWithoutFeeStructureNestedInput
  }

  export type FeeStructureUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: NullableEnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod | null
    frequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceLineItems?: InvoiceLineItemUncheckedUpdateManyWithoutFeeStructureNestedInput
  }

  export type FeeStructureUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: NullableEnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod | null
    frequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutInvoicesNestedInput
    parentToBill?: ParentUpdateOneWithoutInvoicesNestedInput
    lineItems?: InvoiceLineItemUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    parentToBillId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lineItems?: InvoiceLineItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    parentToBillId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimetableSlotUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutTimetableSlotsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutTimetableSlotsNestedInput
    teacher?: TeacherUpdateOneRequiredWithoutTimetableSlotsNestedInput
    attendances?: StudentAttendanceUpdateManyWithoutTimetableSlotNestedInput
  }

  export type TimetableSlotUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: StudentAttendanceUncheckedUpdateManyWithoutTimetableSlotNestedInput
  }

  export type TimetableSlotUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolAnnouncementUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audience?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByAdmin?: SchoolAdminUpdateOneWithoutCreatedSchoolAnnouncementsNestedInput
  }

  export type SchoolAnnouncementUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audience?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolAnnouncementUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audience?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassAnnouncementUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutAnnouncementsNestedInput
    createdByTeacher?: TeacherUpdateOneWithoutCreatedClassAnnouncementsNestedInput
  }

  export type ClassAnnouncementUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdByTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassAnnouncementUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdByTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolAnnouncementCreateManyCreatedByAdminInput = {
    id?: string
    schoolId: string
    title: string
    content: string
    publishDate: Date | string
    expiryDate?: Date | string | null
    audience?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolAnnouncementUpdateWithoutCreatedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audience?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutAnnouncementsNestedInput
  }

  export type SchoolAnnouncementUncheckedUpdateWithoutCreatedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audience?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolAnnouncementUncheckedUpdateManyWithoutCreatedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audience?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassCreateManyHomeroomTeacherInput = {
    id?: string
    schoolId: string
    name: string
    section?: string | null
    academicYear: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimetableSlotCreateManyTeacherInput = {
    id?: string
    schoolId: string
    classId: string
    subjectId: string
    dayOfWeek: $Enums.DayOfWeek
    startTime: string
    endTime: string
    room?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentGradeCreateManyTeacherInput = {
    id?: string
    studentId: string
    subjectId: string
    assignmentId?: string | null
    grade: string
    numericValue?: number | null
    comments?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    dateRecorded?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentCreateManyTeacherInput = {
    id?: string
    schoolId: string
    classId: string
    subjectId: string
    title: string
    description?: string | null
    maxPoints?: number | null
    dueDate?: Date | string | null
    academicYear: string
    term: $Enums.TermPeriod
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassAnnouncementCreateManyCreatedByTeacherInput = {
    id?: string
    schoolId: string
    classId: string
    title: string
    content: string
    publishDate: Date | string
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassUpdateWithoutHomeroomTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    studentsEnrolled?: StudentClassEnrollmentUpdateManyWithoutClassNestedInput
    currentStudents?: StudentUpdateManyWithoutCurrentClassNestedInput
    timetableSlots?: TimetableSlotUpdateManyWithoutClassNestedInput
    assignments?: AssignmentUpdateManyWithoutClassNestedInput
    announcements?: ClassAnnouncementUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutHomeroomTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentsEnrolled?: StudentClassEnrollmentUncheckedUpdateManyWithoutClassNestedInput
    currentStudents?: StudentUncheckedUpdateManyWithoutCurrentClassNestedInput
    timetableSlots?: TimetableSlotUncheckedUpdateManyWithoutClassNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutClassNestedInput
    announcements?: ClassAnnouncementUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateManyWithoutHomeroomTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimetableSlotUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutTimetableSlotsNestedInput
    class?: ClassUpdateOneRequiredWithoutTimetableSlotsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutTimetableSlotsNestedInput
    attendances?: StudentAttendanceUpdateManyWithoutTimetableSlotNestedInput
  }

  export type TimetableSlotUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: StudentAttendanceUncheckedUpdateManyWithoutTimetableSlotNestedInput
  }

  export type TimetableSlotUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentGradeUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    numericValue?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    dateRecorded?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutGradesNestedInput
    subject?: SubjectUpdateOneRequiredWithoutGradesNestedInput
    assignment?: AssignmentUpdateOneWithoutGradesNestedInput
  }

  export type StudentGradeUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: StringFieldUpdateOperationsInput | string
    numericValue?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    dateRecorded?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentGradeUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: StringFieldUpdateOperationsInput | string
    numericValue?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    dateRecorded?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutAssignmentsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutAssignmentsNestedInput
    grades?: StudentGradeUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grades?: StudentGradeUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassAnnouncementUpdateWithoutCreatedByTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutClassAnnouncementsNestedInput
    class?: ClassUpdateOneRequiredWithoutAnnouncementsNestedInput
  }

  export type ClassAnnouncementUncheckedUpdateWithoutCreatedByTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassAnnouncementUncheckedUpdateManyWithoutCreatedByTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentParentLinkCreateManyStudentInput = {
    id?: string
    parentId: string
    relationshipToStudent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentClassEnrollmentCreateManyStudentInput = {
    id?: string
    classId: string
    academicYear: string
    enrollmentDate?: Date | string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAttendanceCreateManyStudentInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    classId?: string | null
    subjectId?: string | null
    timetableSlotId?: string | null
    recordedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentGradeCreateManyStudentInput = {
    id?: string
    subjectId: string
    assignmentId?: string | null
    teacherId?: string | null
    grade: string
    numericValue?: number | null
    comments?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    dateRecorded?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceLineItemCreateManyStudentInput = {
    id?: string
    invoiceId: string
    feeStructureId?: string | null
    description: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyStudentInput = {
    id?: string
    schoolId: string
    parentToBillId?: string | null
    invoiceNumber: string
    issueDate: Date | string
    dueDate: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.PaymentStatus
    notes?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentParentLinkUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipToStudent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: ParentUpdateOneRequiredWithoutChildrenNestedInput
  }

  export type StudentParentLinkUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    relationshipToStudent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentParentLinkUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    relationshipToStudent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentClassEnrollmentUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutStudentsEnrolledNestedInput
  }

  export type StudentClassEnrollmentUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentClassEnrollmentUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAttendanceUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timetableSlot?: TimetableSlotUpdateOneWithoutAttendancesNestedInput
    recordedBy?: UserUpdateOneWithoutRecordedAttendancesNestedInput
  }

  export type StudentAttendanceUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    timetableSlotId?: NullableStringFieldUpdateOperationsInput | string | null
    recordedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAttendanceUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    timetableSlotId?: NullableStringFieldUpdateOperationsInput | string | null
    recordedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentGradeUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    numericValue?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    dateRecorded?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneRequiredWithoutGradesNestedInput
    assignment?: AssignmentUpdateOneWithoutGradesNestedInput
    teacher?: TeacherUpdateOneWithoutGradesGivenNestedInput
  }

  export type StudentGradeUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: StringFieldUpdateOperationsInput | string
    numericValue?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    dateRecorded?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentGradeUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: StringFieldUpdateOperationsInput | string
    numericValue?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    dateRecorded?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLineItemUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutLineItemsNestedInput
    feeStructure?: FeeStructureUpdateOneWithoutInvoiceLineItemsNestedInput
  }

  export type InvoiceLineItemUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    feeStructureId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLineItemUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    feeStructureId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutInvoicesNestedInput
    parentToBill?: ParentUpdateOneWithoutInvoicesNestedInput
    lineItems?: InvoiceLineItemUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    parentToBillId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lineItems?: InvoiceLineItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    parentToBillId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentParentLinkCreateManyParentInput = {
    id?: string
    studentId: string
    relationshipToStudent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyParentToBillInput = {
    id?: string
    schoolId: string
    studentId: string
    invoiceNumber: string
    issueDate: Date | string
    dueDate: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.PaymentStatus
    notes?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentParentLinkUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipToStudent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutParentsNestedInput
  }

  export type StudentParentLinkUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    relationshipToStudent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentParentLinkUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    relationshipToStudent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutParentToBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutInvoicesNestedInput
    student?: StudentUpdateOneRequiredWithoutInvoicesNestedInput
    lineItems?: InvoiceLineItemUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutParentToBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lineItems?: InvoiceLineItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutParentToBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentClassEnrollmentCreateManyClassInput = {
    id?: string
    studentId: string
    academicYear: string
    enrollmentDate?: Date | string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentCreateManyCurrentClassInput = {
    id?: string
    userId?: string | null
    schoolId: string
    studentIdNumber: string
    firstName: string
    lastName: string
    middleName?: string | null
    dateOfBirth: Date | string
    gender: $Enums.Gender
    enrollmentDate: Date | string
    profilePictureUrl?: string | null
    address?: string | null
    city?: string | null
    stateOrRegion?: string | null
    country?: string | null
    postalCode?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    bloodGroup?: string | null
    allergies?: string | null
    medicalNotes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimetableSlotCreateManyClassInput = {
    id?: string
    schoolId: string
    subjectId: string
    teacherId: string
    dayOfWeek: $Enums.DayOfWeek
    startTime: string
    endTime: string
    room?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentCreateManyClassInput = {
    id?: string
    schoolId: string
    subjectId: string
    teacherId: string
    title: string
    description?: string | null
    maxPoints?: number | null
    dueDate?: Date | string | null
    academicYear: string
    term: $Enums.TermPeriod
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassAnnouncementCreateManyClassInput = {
    id?: string
    schoolId: string
    title: string
    content: string
    publishDate: Date | string
    isPublished?: boolean
    createdByTeacherId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentClassEnrollmentUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type StudentClassEnrollmentUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentClassEnrollmentUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUpdateWithoutCurrentClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentIdNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentLinkNestedInput
    school?: SchoolUpdateOneRequiredWithoutStudentsNestedInput
    parents?: StudentParentLinkUpdateManyWithoutStudentNestedInput
    enrollments?: StudentClassEnrollmentUpdateManyWithoutStudentNestedInput
    attendances?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    grades?: StudentGradeUpdateManyWithoutStudentNestedInput
    invoiceLineItems?: InvoiceLineItemUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutCurrentClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    studentIdNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: StudentParentLinkUncheckedUpdateManyWithoutStudentNestedInput
    enrollments?: StudentClassEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    grades?: StudentGradeUncheckedUpdateManyWithoutStudentNestedInput
    invoiceLineItems?: InvoiceLineItemUncheckedUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutCurrentClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    studentIdNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    stateOrRegion?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimetableSlotUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutTimetableSlotsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutTimetableSlotsNestedInput
    teacher?: TeacherUpdateOneRequiredWithoutTimetableSlotsNestedInput
    attendances?: StudentAttendanceUpdateManyWithoutTimetableSlotNestedInput
  }

  export type TimetableSlotUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: StudentAttendanceUncheckedUpdateManyWithoutTimetableSlotNestedInput
  }

  export type TimetableSlotUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneRequiredWithoutAssignmentsNestedInput
    teacher?: TeacherUpdateOneRequiredWithoutAssignmentsCreatedNestedInput
    grades?: StudentGradeUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grades?: StudentGradeUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassAnnouncementUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutClassAnnouncementsNestedInput
    createdByTeacher?: TeacherUpdateOneWithoutCreatedClassAnnouncementsNestedInput
  }

  export type ClassAnnouncementUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdByTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassAnnouncementUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdByTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimetableSlotCreateManySubjectInput = {
    id?: string
    schoolId: string
    classId: string
    teacherId: string
    dayOfWeek: $Enums.DayOfWeek
    startTime: string
    endTime: string
    room?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentCreateManySubjectInput = {
    id?: string
    schoolId: string
    classId: string
    teacherId: string
    title: string
    description?: string | null
    maxPoints?: number | null
    dueDate?: Date | string | null
    academicYear: string
    term: $Enums.TermPeriod
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentGradeCreateManySubjectInput = {
    id?: string
    studentId: string
    assignmentId?: string | null
    teacherId?: string | null
    grade: string
    numericValue?: number | null
    comments?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    dateRecorded?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimetableSlotUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutTimetableSlotsNestedInput
    class?: ClassUpdateOneRequiredWithoutTimetableSlotsNestedInput
    teacher?: TeacherUpdateOneRequiredWithoutTimetableSlotsNestedInput
    attendances?: StudentAttendanceUpdateManyWithoutTimetableSlotNestedInput
  }

  export type TimetableSlotUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: StudentAttendanceUncheckedUpdateManyWithoutTimetableSlotNestedInput
  }

  export type TimetableSlotUncheckedUpdateManyWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutAssignmentsNestedInput
    teacher?: TeacherUpdateOneRequiredWithoutAssignmentsCreatedNestedInput
    grades?: StudentGradeUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grades?: StudentGradeUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateManyWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentGradeUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    numericValue?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    dateRecorded?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutGradesNestedInput
    assignment?: AssignmentUpdateOneWithoutGradesNestedInput
    teacher?: TeacherUpdateOneWithoutGradesGivenNestedInput
  }

  export type StudentGradeUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: StringFieldUpdateOperationsInput | string
    numericValue?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    dateRecorded?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentGradeUncheckedUpdateManyWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: StringFieldUpdateOperationsInput | string
    numericValue?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    dateRecorded?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAttendanceCreateManyTimetableSlotInput = {
    id?: string
    studentId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    classId?: string | null
    subjectId?: string | null
    recordedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAttendanceUpdateWithoutTimetableSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutAttendancesNestedInput
    recordedBy?: UserUpdateOneWithoutRecordedAttendancesNestedInput
  }

  export type StudentAttendanceUncheckedUpdateWithoutTimetableSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    recordedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAttendanceUncheckedUpdateManyWithoutTimetableSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    recordedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentGradeCreateManyAssignmentInput = {
    id?: string
    studentId: string
    subjectId: string
    teacherId?: string | null
    grade: string
    numericValue?: number | null
    comments?: string | null
    academicYear: string
    term: $Enums.TermPeriod
    dateRecorded?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentGradeUpdateWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    numericValue?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    dateRecorded?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutGradesNestedInput
    subject?: SubjectUpdateOneRequiredWithoutGradesNestedInput
    teacher?: TeacherUpdateOneWithoutGradesGivenNestedInput
  }

  export type StudentGradeUncheckedUpdateWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: StringFieldUpdateOperationsInput | string
    numericValue?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    dateRecorded?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentGradeUncheckedUpdateManyWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: StringFieldUpdateOperationsInput | string
    numericValue?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    term?: EnumTermPeriodFieldUpdateOperationsInput | $Enums.TermPeriod
    dateRecorded?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLineItemCreateManyFeeStructureInput = {
    id?: string
    invoiceId: string
    studentId: string
    description: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceLineItemUpdateWithoutFeeStructureInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutLineItemsNestedInput
    student?: StudentUpdateOneRequiredWithoutInvoiceLineItemsNestedInput
  }

  export type InvoiceLineItemUncheckedUpdateWithoutFeeStructureInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLineItemUncheckedUpdateManyWithoutFeeStructureInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLineItemCreateManyInvoiceInput = {
    id?: string
    feeStructureId?: string | null
    studentId: string
    description: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyInvoiceInput = {
    id?: string
    paymentDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    reference?: string | null
    notes?: string | null
    recordedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceLineItemUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feeStructure?: FeeStructureUpdateOneWithoutInvoiceLineItemsNestedInput
    student?: StudentUpdateOneRequiredWithoutInvoiceLineItemsNestedInput
  }

  export type InvoiceLineItemUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    feeStructureId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLineItemUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    feeStructureId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: UserUpdateOneWithoutRecordedPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}